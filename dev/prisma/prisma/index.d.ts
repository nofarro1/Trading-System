
/**
 * Client
**/

import * as runtime from './runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Member
 * 
 */
export type Member = {
  username: string
}

/**
 * Model Role
 * 
 */
export type Role = {
  username: string
  shopId: number
  job_type: JobType
  permissions: Permissions[]
}

/**
 * Model Product
 * 
 */
export type Product = {
  id: number
  name: string
  shopId: number
  category: ProductCategory
  rate: ProductRate
  description: string | null
}

/**
 * Model Shop
 * 
 */
export type Shop = {
  id: number
  name: string
  status: ShopStatus
  shop_founder: string
  rate: ShopRate
  description: string | null
}

/**
 * Model ShopOwner
 * 
 */
export type ShopOwner = {
  username: string
  shopId: number
}

/**
 * Model ShopManager
 * 
 */
export type ShopManager = {
  username: string
  shopId: number
}

/**
 * Model ProductInShop
 * 
 */
export type ProductInShop = {
  shopId: number
  productId: number
  product_quantity: number
}

/**
 * Model ShoppingCart
 * 
 */
export type ShoppingCart = {
  username: string
}

/**
 * Model ShoppingBag
 * 
 */
export type ShoppingBag = {
  username: string
  shopId: number
}

/**
 * Model ProductInBag
 * 
 */
export type ProductInBag = {
  username: string
  shopId: number
  productId: number
  product_quantity: number
}

/**
 * Model MemberCredentials
 * 
 */
export type MemberCredentials = {
  username: string
  password: string
}

/**
 * Model Message
 * 
 */
export type Message = {
  id: number
  timestamp: number
  isRead: boolean
  messageType: MessageType
}

/**
 * Model MessageRecipients
 * 
 */
export type MessageRecipients = {
  messageId: number
  username: string
}

/**
 * Model Discount
 * 
 */
export type Discount = {
  id: number
  shopId: number
  kind: DiscountKinds
}

/**
 * Model SimpleDiscount
 * 
 */
export type SimpleDiscount = {
  id: number
  shopId: number
  discountType: DiscountType
  discountPercent: number
  description: string
  productId: number | null
  category: ProductCategory | null
}

/**
 * Model ConditionalDiscount
 * 
 */
export type ConditionalDiscount = {
  id: number
  shopId: number
  simpleId: number
  simpleShopId: number
}

/**
 * Model DiscountPredicate
 * 
 */
export type DiscountPredicate = {
  discountId: number
  shopId: number
  discountType: DiscountType
  relation: RelationType
  value: number
  description: string
  productId: number | null
  category: ProductCategory | null
}

/**
 * Model DiscountContainer
 * 
 */
export type DiscountContainer = {
  id: number
  shopId: number
  description: string
  type: DiscountRelation
}

/**
 * Model DiscountInContainer
 * 
 */
export type DiscountInContainer = {
  containedDiscount: number
  shopId: number
  containingDiscount: number
}

/**
 * Model Policy
 * 
 */
export type Policy = {
  id: number
  shopId: number
}

/**
 * Model SimplePolicy
 * 
 */
export type SimplePolicy = {
  id: number
  shopId: number
  okay: boolean
  message: string
}

/**
 * Model ConditionalPolicy
 * 
 */
export type ConditionalPolicy = {
  id: number
  shopId: number
  dependent: number
  dependentShopId: number
  dependentOn: number
  dependentOnShopId: number
  description: string
}

/**
 * Model PolicyPredicate
 * 
 */
export type PolicyPredicate = {
  policyId: number
  shopId: number
  policyType: SimplePolicyType
  relation: RelationType
  value: number
  description: string
  productId: number | null
  productCategory: ProductCategory | null
  guest: string | null
}

/**
 * Model LogicalPolicy
 * 
 */
export type LogicalPolicy = {
  id: number
  shopId: number
  description: string
  purchasePoliciesRelation: PurchasePoliciesRelation
}

/**
 * Model PolicyInContainer
 * 
 */
export type PolicyInContainer = {
  containedPolicy: number
  shopId: number
  containingPolicy: number
}

/**
 * Model Offer
 * 
 */
export type Offer = {
  id: number
  username: string
  shopId: number
  productId: number
  price: number
}

/**
 * Model OfferApprover
 * 
 */
export type OfferApprover = {
  username: string
  offerId: number
  answered: boolean
  approved: boolean
}

/**
 * Model Appointment
 * 
 */
export type Appointment = {
  username: string
  shopId: number
  assigner: string
}

/**
 * Model AppointmentAgreement
 * 
 */
export type AppointmentAgreement = {
  username: string
  shopId: number
  approver: string
  answered: boolean
  approved: boolean
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const JobType: {
  Admin: 'Admin',
  Founder: 'Founder',
  Owner: 'Owner',
  Manager: 'Manager'
};

export type JobType = (typeof JobType)[keyof typeof JobType]


export const Permissions: {
  AddProduct: 'AddProduct',
  RemoveProduct: 'RemoveProduct',
  ModifyProduct: 'ModifyProduct',
  RequestPersonnelInfo: 'RequestPersonnelInfo',
  GetPurchaseHistory: 'GetPurchaseHistory',
  AddShopOwner: 'AddShopOwner',
  AddShopManager: 'AddShopManager',
  AddPermission: 'AddPermission',
  RemovePermission: 'RemovePermission',
  CloseShop: 'CloseShop',
  ReopenShop: 'ReopenShop',
  AdminControl: 'AdminControl',
  AddDiscount: 'AddDiscount',
  RemoveDiscount: 'RemoveDiscount',
  AddPurchasePolicy: 'AddPurchasePolicy',
  RemovePurchasePolicy: 'RemovePurchasePolicy',
  ShopOwner: 'ShopOwner'
};

export type Permissions = (typeof Permissions)[keyof typeof Permissions]


export const ProductCategory: {
  A: 'A',
  B: 'B',
  C: 'C'
};

export type ProductCategory = (typeof ProductCategory)[keyof typeof ProductCategory]


export const ProductRate: {
  NotRated: 'NotRated'
};

export type ProductRate = (typeof ProductRate)[keyof typeof ProductRate]


export const ShopStatus: {
  Open: 'Open',
  Closed: 'Closed'
};

export type ShopStatus = (typeof ShopStatus)[keyof typeof ShopStatus]


export const ShopRate: {
  NotRated: 'NotRated'
};

export type ShopRate = (typeof ShopRate)[keyof typeof ShopRate]


export const MessageType: {
  Simple: 'Simple',
  ShopPurchase: 'ShopPurchase',
  ShopStatusChanged: 'ShopStatusChanged',
  AddedNewOffer2Shop: 'AddedNewOffer2Shop',
  CounterOffer: 'CounterOffer'
};

export type MessageType = (typeof MessageType)[keyof typeof MessageType]


export const DiscountKinds: {
  SimpleDiscount: 'SimpleDiscount',
  ConditionalDiscount: 'ConditionalDiscount',
  ContainerDiscount: 'ContainerDiscount'
};

export type DiscountKinds = (typeof DiscountKinds)[keyof typeof DiscountKinds]


export const DiscountType: {
  Product: 'Product',
  Category: 'Category',
  Bag: 'Bag'
};

export type DiscountType = (typeof DiscountType)[keyof typeof DiscountType]


export const RelationType: {
  LessThan: 'LessThan',
  LessThanOrEqual: 'LessThanOrEqual',
  Equal: 'Equal',
  GreaterThan: 'GreaterThan',
  GreaterThanOrEqual: 'GreaterThanOrEqual',
  NotEqual: 'NotEqual'
};

export type RelationType = (typeof RelationType)[keyof typeof RelationType]


export const DiscountRelation: {
  And: 'And',
  Or: 'Or',
  Xor: 'Xor',
  Addition: 'Addition',
  Max: 'Max'
};

export type DiscountRelation = (typeof DiscountRelation)[keyof typeof DiscountRelation]


export const SimplePolicyType: {
  Product: 'Product',
  Category: 'Category',
  ShoppingBag: 'ShoppingBag',
  UserInfo: 'UserInfo'
};

export type SimplePolicyType = (typeof SimplePolicyType)[keyof typeof SimplePolicyType]


export const PurchasePoliciesRelation: {
  And: 'And',
  Conditional: 'Conditional',
  Or: 'Or'
};

export type PurchasePoliciesRelation = (typeof PurchasePoliciesRelation)[keyof typeof PurchasePoliciesRelation]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Members
 * const members = await prisma.member.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Members
   * const members = await prisma.member.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.member`: Exposes CRUD operations for the **Member** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Members
    * const members = await prisma.member.findMany()
    * ```
    */
  get member(): Prisma.MemberDelegate<GlobalReject>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<GlobalReject>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<GlobalReject>;

  /**
   * `prisma.shop`: Exposes CRUD operations for the **Shop** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shops
    * const shops = await prisma.shop.findMany()
    * ```
    */
  get shop(): Prisma.ShopDelegate<GlobalReject>;

  /**
   * `prisma.shopOwner`: Exposes CRUD operations for the **ShopOwner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShopOwners
    * const shopOwners = await prisma.shopOwner.findMany()
    * ```
    */
  get shopOwner(): Prisma.ShopOwnerDelegate<GlobalReject>;

  /**
   * `prisma.shopManager`: Exposes CRUD operations for the **ShopManager** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShopManagers
    * const shopManagers = await prisma.shopManager.findMany()
    * ```
    */
  get shopManager(): Prisma.ShopManagerDelegate<GlobalReject>;

  /**
   * `prisma.productInShop`: Exposes CRUD operations for the **ProductInShop** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductInShops
    * const productInShops = await prisma.productInShop.findMany()
    * ```
    */
  get productInShop(): Prisma.ProductInShopDelegate<GlobalReject>;

  /**
   * `prisma.shoppingCart`: Exposes CRUD operations for the **ShoppingCart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShoppingCarts
    * const shoppingCarts = await prisma.shoppingCart.findMany()
    * ```
    */
  get shoppingCart(): Prisma.ShoppingCartDelegate<GlobalReject>;

  /**
   * `prisma.shoppingBag`: Exposes CRUD operations for the **ShoppingBag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShoppingBags
    * const shoppingBags = await prisma.shoppingBag.findMany()
    * ```
    */
  get shoppingBag(): Prisma.ShoppingBagDelegate<GlobalReject>;

  /**
   * `prisma.productInBag`: Exposes CRUD operations for the **ProductInBag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductInBags
    * const productInBags = await prisma.productInBag.findMany()
    * ```
    */
  get productInBag(): Prisma.ProductInBagDelegate<GlobalReject>;

  /**
   * `prisma.memberCredentials`: Exposes CRUD operations for the **MemberCredentials** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MemberCredentials
    * const memberCredentials = await prisma.memberCredentials.findMany()
    * ```
    */
  get memberCredentials(): Prisma.MemberCredentialsDelegate<GlobalReject>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<GlobalReject>;

  /**
   * `prisma.messageRecipients`: Exposes CRUD operations for the **MessageRecipients** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageRecipients
    * const messageRecipients = await prisma.messageRecipients.findMany()
    * ```
    */
  get messageRecipients(): Prisma.MessageRecipientsDelegate<GlobalReject>;

  /**
   * `prisma.discount`: Exposes CRUD operations for the **Discount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Discounts
    * const discounts = await prisma.discount.findMany()
    * ```
    */
  get discount(): Prisma.DiscountDelegate<GlobalReject>;

  /**
   * `prisma.simpleDiscount`: Exposes CRUD operations for the **SimpleDiscount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SimpleDiscounts
    * const simpleDiscounts = await prisma.simpleDiscount.findMany()
    * ```
    */
  get simpleDiscount(): Prisma.SimpleDiscountDelegate<GlobalReject>;

  /**
   * `prisma.conditionalDiscount`: Exposes CRUD operations for the **ConditionalDiscount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConditionalDiscounts
    * const conditionalDiscounts = await prisma.conditionalDiscount.findMany()
    * ```
    */
  get conditionalDiscount(): Prisma.ConditionalDiscountDelegate<GlobalReject>;

  /**
   * `prisma.discountPredicate`: Exposes CRUD operations for the **DiscountPredicate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DiscountPredicates
    * const discountPredicates = await prisma.discountPredicate.findMany()
    * ```
    */
  get discountPredicate(): Prisma.DiscountPredicateDelegate<GlobalReject>;

  /**
   * `prisma.discountContainer`: Exposes CRUD operations for the **DiscountContainer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DiscountContainers
    * const discountContainers = await prisma.discountContainer.findMany()
    * ```
    */
  get discountContainer(): Prisma.DiscountContainerDelegate<GlobalReject>;

  /**
   * `prisma.discountInContainer`: Exposes CRUD operations for the **DiscountInContainer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DiscountInContainers
    * const discountInContainers = await prisma.discountInContainer.findMany()
    * ```
    */
  get discountInContainer(): Prisma.DiscountInContainerDelegate<GlobalReject>;

  /**
   * `prisma.policy`: Exposes CRUD operations for the **Policy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Policies
    * const policies = await prisma.policy.findMany()
    * ```
    */
  get policy(): Prisma.PolicyDelegate<GlobalReject>;

  /**
   * `prisma.simplePolicy`: Exposes CRUD operations for the **SimplePolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SimplePolicies
    * const simplePolicies = await prisma.simplePolicy.findMany()
    * ```
    */
  get simplePolicy(): Prisma.SimplePolicyDelegate<GlobalReject>;

  /**
   * `prisma.conditionalPolicy`: Exposes CRUD operations for the **ConditionalPolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConditionalPolicies
    * const conditionalPolicies = await prisma.conditionalPolicy.findMany()
    * ```
    */
  get conditionalPolicy(): Prisma.ConditionalPolicyDelegate<GlobalReject>;

  /**
   * `prisma.policyPredicate`: Exposes CRUD operations for the **PolicyPredicate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PolicyPredicates
    * const policyPredicates = await prisma.policyPredicate.findMany()
    * ```
    */
  get policyPredicate(): Prisma.PolicyPredicateDelegate<GlobalReject>;

  /**
   * `prisma.logicalPolicy`: Exposes CRUD operations for the **LogicalPolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LogicalPolicies
    * const logicalPolicies = await prisma.logicalPolicy.findMany()
    * ```
    */
  get logicalPolicy(): Prisma.LogicalPolicyDelegate<GlobalReject>;

  /**
   * `prisma.policyInContainer`: Exposes CRUD operations for the **PolicyInContainer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PolicyInContainers
    * const policyInContainers = await prisma.policyInContainer.findMany()
    * ```
    */
  get policyInContainer(): Prisma.PolicyInContainerDelegate<GlobalReject>;

  /**
   * `prisma.offer`: Exposes CRUD operations for the **Offer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Offers
    * const offers = await prisma.offer.findMany()
    * ```
    */
  get offer(): Prisma.OfferDelegate<GlobalReject>;

  /**
   * `prisma.offerApprover`: Exposes CRUD operations for the **OfferApprover** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OfferApprovers
    * const offerApprovers = await prisma.offerApprover.findMany()
    * ```
    */
  get offerApprover(): Prisma.OfferApproverDelegate<GlobalReject>;

  /**
   * `prisma.appointment`: Exposes CRUD operations for the **Appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointment.findMany()
    * ```
    */
  get appointment(): Prisma.AppointmentDelegate<GlobalReject>;

  /**
   * `prisma.appointmentAgreement`: Exposes CRUD operations for the **AppointmentAgreement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AppointmentAgreements
    * const appointmentAgreements = await prisma.appointmentAgreement.findMany()
    * ```
    */
  get appointmentAgreement(): Prisma.AppointmentAgreementDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Prisma Client JS version: 3.15.2
   * Query Engine version: 461d6a05159055555eb7dfb337c9fb271cbd4d7e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull'

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull'

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull'

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Member: 'Member',
    Role: 'Role',
    Product: 'Product',
    Shop: 'Shop',
    ShopOwner: 'ShopOwner',
    ShopManager: 'ShopManager',
    ProductInShop: 'ProductInShop',
    ShoppingCart: 'ShoppingCart',
    ShoppingBag: 'ShoppingBag',
    ProductInBag: 'ProductInBag',
    MemberCredentials: 'MemberCredentials',
    Message: 'Message',
    MessageRecipients: 'MessageRecipients',
    Discount: 'Discount',
    SimpleDiscount: 'SimpleDiscount',
    ConditionalDiscount: 'ConditionalDiscount',
    DiscountPredicate: 'DiscountPredicate',
    DiscountContainer: 'DiscountContainer',
    DiscountInContainer: 'DiscountInContainer',
    Policy: 'Policy',
    SimplePolicy: 'SimplePolicy',
    ConditionalPolicy: 'ConditionalPolicy',
    PolicyPredicate: 'PolicyPredicate',
    LogicalPolicy: 'LogicalPolicy',
    PolicyInContainer: 'PolicyInContainer',
    Offer: 'Offer',
    OfferApprover: 'OfferApprover',
    Appointment: 'Appointment',
    AppointmentAgreement: 'AppointmentAgreement'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type MemberCountOutputType
   */


  export type MemberCountOutputType = {
    roles: number
    shops: number
    offers: number
    offerApprovers: number
    appointments: number
    messageRecipients: number
  }

  export type MemberCountOutputTypeSelect = {
    roles?: boolean
    shops?: boolean
    offers?: boolean
    offerApprovers?: boolean
    appointments?: boolean
    messageRecipients?: boolean
  }

  export type MemberCountOutputTypeGetPayload<
    S extends boolean | null | undefined | MemberCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? MemberCountOutputType
    : S extends undefined
    ? never
    : S extends MemberCountOutputTypeArgs
    ?'include' extends U
    ? MemberCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof MemberCountOutputType ? MemberCountOutputType[P] : never
  } 
    : MemberCountOutputType
  : MemberCountOutputType




  // Custom InputTypes

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MemberCountOutputType
     * 
    **/
    select?: MemberCountOutputTypeSelect | null
  }



  /**
   * Count Type RoleCountOutputType
   */


  export type RoleCountOutputType = {
    shop_owners: number
    shop_managers: number
  }

  export type RoleCountOutputTypeSelect = {
    shop_owners?: boolean
    shop_managers?: boolean
  }

  export type RoleCountOutputTypeGetPayload<
    S extends boolean | null | undefined | RoleCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? RoleCountOutputType
    : S extends undefined
    ? never
    : S extends RoleCountOutputTypeArgs
    ?'include' extends U
    ? RoleCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof RoleCountOutputType ? RoleCountOutputType[P] : never
  } 
    : RoleCountOutputType
  : RoleCountOutputType




  // Custom InputTypes

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     * 
    **/
    select?: RoleCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductCountOutputType
   */


  export type ProductCountOutputType = {
    products_in_shop: number
    products_in_bag: number
    offers: number
  }

  export type ProductCountOutputTypeSelect = {
    products_in_shop?: boolean
    products_in_bag?: boolean
    offers?: boolean
  }

  export type ProductCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ProductCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ProductCountOutputType
    : S extends undefined
    ? never
    : S extends ProductCountOutputTypeArgs
    ?'include' extends U
    ? ProductCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ProductCountOutputType ? ProductCountOutputType[P] : never
  } 
    : ProductCountOutputType
  : ProductCountOutputType




  // Custom InputTypes

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     * 
    **/
    select?: ProductCountOutputTypeSelect | null
  }



  /**
   * Count Type ShopCountOutputType
   */


  export type ShopCountOutputType = {
    role: number
    products: number
    products_in_shop: number
    bags: number
    discounts: number
    policies: number
    offers: number
    appointments: number
  }

  export type ShopCountOutputTypeSelect = {
    role?: boolean
    products?: boolean
    products_in_shop?: boolean
    bags?: boolean
    discounts?: boolean
    policies?: boolean
    offers?: boolean
    appointments?: boolean
  }

  export type ShopCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ShopCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ShopCountOutputType
    : S extends undefined
    ? never
    : S extends ShopCountOutputTypeArgs
    ?'include' extends U
    ? ShopCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ShopCountOutputType ? ShopCountOutputType[P] : never
  } 
    : ShopCountOutputType
  : ShopCountOutputType




  // Custom InputTypes

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ShopCountOutputType
     * 
    **/
    select?: ShopCountOutputTypeSelect | null
  }



  /**
   * Count Type ShoppingCartCountOutputType
   */


  export type ShoppingCartCountOutputType = {
    bags: number
  }

  export type ShoppingCartCountOutputTypeSelect = {
    bags?: boolean
  }

  export type ShoppingCartCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ShoppingCartCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ShoppingCartCountOutputType
    : S extends undefined
    ? never
    : S extends ShoppingCartCountOutputTypeArgs
    ?'include' extends U
    ? ShoppingCartCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ShoppingCartCountOutputType ? ShoppingCartCountOutputType[P] : never
  } 
    : ShoppingCartCountOutputType
  : ShoppingCartCountOutputType




  // Custom InputTypes

  /**
   * ShoppingCartCountOutputType without action
   */
  export type ShoppingCartCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ShoppingCartCountOutputType
     * 
    **/
    select?: ShoppingCartCountOutputTypeSelect | null
  }



  /**
   * Count Type ShoppingBagCountOutputType
   */


  export type ShoppingBagCountOutputType = {
    products_in_bag: number
  }

  export type ShoppingBagCountOutputTypeSelect = {
    products_in_bag?: boolean
  }

  export type ShoppingBagCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ShoppingBagCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ShoppingBagCountOutputType
    : S extends undefined
    ? never
    : S extends ShoppingBagCountOutputTypeArgs
    ?'include' extends U
    ? ShoppingBagCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ShoppingBagCountOutputType ? ShoppingBagCountOutputType[P] : never
  } 
    : ShoppingBagCountOutputType
  : ShoppingBagCountOutputType




  // Custom InputTypes

  /**
   * ShoppingBagCountOutputType without action
   */
  export type ShoppingBagCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ShoppingBagCountOutputType
     * 
    **/
    select?: ShoppingBagCountOutputTypeSelect | null
  }



  /**
   * Count Type MessageCountOutputType
   */


  export type MessageCountOutputType = {
    recipients: number
  }

  export type MessageCountOutputTypeSelect = {
    recipients?: boolean
  }

  export type MessageCountOutputTypeGetPayload<
    S extends boolean | null | undefined | MessageCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? MessageCountOutputType
    : S extends undefined
    ? never
    : S extends MessageCountOutputTypeArgs
    ?'include' extends U
    ? MessageCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof MessageCountOutputType ? MessageCountOutputType[P] : never
  } 
    : MessageCountOutputType
  : MessageCountOutputType




  // Custom InputTypes

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     * 
    **/
    select?: MessageCountOutputTypeSelect | null
  }



  /**
   * Count Type DiscountContainerCountOutputType
   */


  export type DiscountContainerCountOutputType = {
    discounts: number
  }

  export type DiscountContainerCountOutputTypeSelect = {
    discounts?: boolean
  }

  export type DiscountContainerCountOutputTypeGetPayload<
    S extends boolean | null | undefined | DiscountContainerCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? DiscountContainerCountOutputType
    : S extends undefined
    ? never
    : S extends DiscountContainerCountOutputTypeArgs
    ?'include' extends U
    ? DiscountContainerCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof DiscountContainerCountOutputType ? DiscountContainerCountOutputType[P] : never
  } 
    : DiscountContainerCountOutputType
  : DiscountContainerCountOutputType




  // Custom InputTypes

  /**
   * DiscountContainerCountOutputType without action
   */
  export type DiscountContainerCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DiscountContainerCountOutputType
     * 
    **/
    select?: DiscountContainerCountOutputTypeSelect | null
  }



  /**
   * Count Type LogicalPolicyCountOutputType
   */


  export type LogicalPolicyCountOutputType = {
    policies: number
  }

  export type LogicalPolicyCountOutputTypeSelect = {
    policies?: boolean
  }

  export type LogicalPolicyCountOutputTypeGetPayload<
    S extends boolean | null | undefined | LogicalPolicyCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? LogicalPolicyCountOutputType
    : S extends undefined
    ? never
    : S extends LogicalPolicyCountOutputTypeArgs
    ?'include' extends U
    ? LogicalPolicyCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof LogicalPolicyCountOutputType ? LogicalPolicyCountOutputType[P] : never
  } 
    : LogicalPolicyCountOutputType
  : LogicalPolicyCountOutputType




  // Custom InputTypes

  /**
   * LogicalPolicyCountOutputType without action
   */
  export type LogicalPolicyCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LogicalPolicyCountOutputType
     * 
    **/
    select?: LogicalPolicyCountOutputTypeSelect | null
  }



  /**
   * Count Type OfferCountOutputType
   */


  export type OfferCountOutputType = {
    offerApprover: number
  }

  export type OfferCountOutputTypeSelect = {
    offerApprover?: boolean
  }

  export type OfferCountOutputTypeGetPayload<
    S extends boolean | null | undefined | OfferCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? OfferCountOutputType
    : S extends undefined
    ? never
    : S extends OfferCountOutputTypeArgs
    ?'include' extends U
    ? OfferCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof OfferCountOutputType ? OfferCountOutputType[P] : never
  } 
    : OfferCountOutputType
  : OfferCountOutputType




  // Custom InputTypes

  /**
   * OfferCountOutputType without action
   */
  export type OfferCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OfferCountOutputType
     * 
    **/
    select?: OfferCountOutputTypeSelect | null
  }



  /**
   * Count Type AppointmentCountOutputType
   */


  export type AppointmentCountOutputType = {
    appointmentAgreements: number
  }

  export type AppointmentCountOutputTypeSelect = {
    appointmentAgreements?: boolean
  }

  export type AppointmentCountOutputTypeGetPayload<
    S extends boolean | null | undefined | AppointmentCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? AppointmentCountOutputType
    : S extends undefined
    ? never
    : S extends AppointmentCountOutputTypeArgs
    ?'include' extends U
    ? AppointmentCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof AppointmentCountOutputType ? AppointmentCountOutputType[P] : never
  } 
    : AppointmentCountOutputType
  : AppointmentCountOutputType




  // Custom InputTypes

  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the AppointmentCountOutputType
     * 
    **/
    select?: AppointmentCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Member
   */


  export type AggregateMember = {
    _count: MemberCountAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  export type MemberMinAggregateOutputType = {
    username: string | null
  }

  export type MemberMaxAggregateOutputType = {
    username: string | null
  }

  export type MemberCountAggregateOutputType = {
    username: number
    _all: number
  }


  export type MemberMinAggregateInputType = {
    username?: true
  }

  export type MemberMaxAggregateInputType = {
    username?: true
  }

  export type MemberCountAggregateInputType = {
    username?: true
    _all?: true
  }

  export type MemberAggregateArgs = {
    /**
     * Filter which Member to aggregate.
     * 
    **/
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     * 
    **/
    orderBy?: Enumerable<MemberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Members
    **/
    _count?: true | MemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberMaxAggregateInputType
  }

  export type GetMemberAggregateType<T extends MemberAggregateArgs> = {
        [P in keyof T & keyof AggregateMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMember[P]>
      : GetScalarType<T[P], AggregateMember[P]>
  }




  export type MemberGroupByArgs = {
    where?: MemberWhereInput
    orderBy?: Enumerable<MemberOrderByWithAggregationInput>
    by: Array<MemberScalarFieldEnum>
    having?: MemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberCountAggregateInputType | true
    _min?: MemberMinAggregateInputType
    _max?: MemberMaxAggregateInputType
  }


  export type MemberGroupByOutputType = {
    username: string
    _count: MemberCountAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  type GetMemberGroupByPayload<T extends MemberGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberGroupByOutputType[P]>
            : GetScalarType<T[P], MemberGroupByOutputType[P]>
        }
      >
    >


  export type MemberSelect = {
    username?: boolean
    roles?: boolean | RoleFindManyArgs
    shops?: boolean | ShopFindManyArgs
    ShoppingCart?: boolean | ShoppingCartArgs
    MemberCredentials?: boolean | MemberCredentialsArgs
    offers?: boolean | OfferFindManyArgs
    offerApprovers?: boolean | OfferApproverFindManyArgs
    appointments?: boolean | AppointmentFindManyArgs
    messageRecipients?: boolean | MessageRecipientsFindManyArgs
    _count?: boolean | MemberCountOutputTypeArgs
  }

  export type MemberInclude = {
    roles?: boolean | RoleFindManyArgs
    shops?: boolean | ShopFindManyArgs
    ShoppingCart?: boolean | ShoppingCartArgs
    MemberCredentials?: boolean | MemberCredentialsArgs
    offers?: boolean | OfferFindManyArgs
    offerApprovers?: boolean | OfferApproverFindManyArgs
    appointments?: boolean | AppointmentFindManyArgs
    messageRecipients?: boolean | MessageRecipientsFindManyArgs
    _count?: boolean | MemberCountOutputTypeArgs
  }

  export type MemberGetPayload<
    S extends boolean | null | undefined | MemberArgs,
    U = keyof S
      > = S extends true
        ? Member
    : S extends undefined
    ? never
    : S extends MemberArgs | MemberFindManyArgs
    ?'include' extends U
    ? Member  & {
    [P in TrueKeys<S['include']>]:
        P extends 'roles' ? Array < RoleGetPayload<S['include'][P]>>  :
        P extends 'shops' ? Array < ShopGetPayload<S['include'][P]>>  :
        P extends 'ShoppingCart' ? ShoppingCartGetPayload<S['include'][P]> | null :
        P extends 'MemberCredentials' ? MemberCredentialsGetPayload<S['include'][P]> | null :
        P extends 'offers' ? Array < OfferGetPayload<S['include'][P]>>  :
        P extends 'offerApprovers' ? Array < OfferApproverGetPayload<S['include'][P]>>  :
        P extends 'appointments' ? Array < AppointmentGetPayload<S['include'][P]>>  :
        P extends 'messageRecipients' ? Array < MessageRecipientsGetPayload<S['include'][P]>>  :
        P extends '_count' ? MemberCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'roles' ? Array < RoleGetPayload<S['select'][P]>>  :
        P extends 'shops' ? Array < ShopGetPayload<S['select'][P]>>  :
        P extends 'ShoppingCart' ? ShoppingCartGetPayload<S['select'][P]> | null :
        P extends 'MemberCredentials' ? MemberCredentialsGetPayload<S['select'][P]> | null :
        P extends 'offers' ? Array < OfferGetPayload<S['select'][P]>>  :
        P extends 'offerApprovers' ? Array < OfferApproverGetPayload<S['select'][P]>>  :
        P extends 'appointments' ? Array < AppointmentGetPayload<S['select'][P]>>  :
        P extends 'messageRecipients' ? Array < MessageRecipientsGetPayload<S['select'][P]>>  :
        P extends '_count' ? MemberCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Member ? Member[P] : never
  } 
    : Member
  : Member


  type MemberCountArgs = Merge<
    Omit<MemberFindManyArgs, 'select' | 'include'> & {
      select?: MemberCountAggregateInputType | true
    }
  >

  export interface MemberDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Member that matches the filter.
     * @param {MemberFindUniqueArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MemberFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MemberFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Member'> extends True ? CheckSelect<T, Prisma__MemberClient<Member>, Prisma__MemberClient<MemberGetPayload<T>>> : CheckSelect<T, Prisma__MemberClient<Member | null >, Prisma__MemberClient<MemberGetPayload<T> | null >>

    /**
     * Find the first Member that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MemberFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MemberFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Member'> extends True ? CheckSelect<T, Prisma__MemberClient<Member>, Prisma__MemberClient<MemberGetPayload<T>>> : CheckSelect<T, Prisma__MemberClient<Member | null >, Prisma__MemberClient<MemberGetPayload<T> | null >>

    /**
     * Find zero or more Members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Members
     * const members = await prisma.member.findMany()
     * 
     * // Get first 10 Members
     * const members = await prisma.member.findMany({ take: 10 })
     * 
     * // Only select the `username`
     * const memberWithUsernameOnly = await prisma.member.findMany({ select: { username: true } })
     * 
    **/
    findMany<T extends MemberFindManyArgs>(
      args?: SelectSubset<T, MemberFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Member>>, PrismaPromise<Array<MemberGetPayload<T>>>>

    /**
     * Create a Member.
     * @param {MemberCreateArgs} args - Arguments to create a Member.
     * @example
     * // Create one Member
     * const Member = await prisma.member.create({
     *   data: {
     *     // ... data to create a Member
     *   }
     * })
     * 
    **/
    create<T extends MemberCreateArgs>(
      args: SelectSubset<T, MemberCreateArgs>
    ): CheckSelect<T, Prisma__MemberClient<Member>, Prisma__MemberClient<MemberGetPayload<T>>>

    /**
     * Create many Members.
     *     @param {MemberCreateManyArgs} args - Arguments to create many Members.
     *     @example
     *     // Create many Members
     *     const member = await prisma.member.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MemberCreateManyArgs>(
      args?: SelectSubset<T, MemberCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Member.
     * @param {MemberDeleteArgs} args - Arguments to delete one Member.
     * @example
     * // Delete one Member
     * const Member = await prisma.member.delete({
     *   where: {
     *     // ... filter to delete one Member
     *   }
     * })
     * 
    **/
    delete<T extends MemberDeleteArgs>(
      args: SelectSubset<T, MemberDeleteArgs>
    ): CheckSelect<T, Prisma__MemberClient<Member>, Prisma__MemberClient<MemberGetPayload<T>>>

    /**
     * Update one Member.
     * @param {MemberUpdateArgs} args - Arguments to update one Member.
     * @example
     * // Update one Member
     * const member = await prisma.member.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MemberUpdateArgs>(
      args: SelectSubset<T, MemberUpdateArgs>
    ): CheckSelect<T, Prisma__MemberClient<Member>, Prisma__MemberClient<MemberGetPayload<T>>>

    /**
     * Delete zero or more Members.
     * @param {MemberDeleteManyArgs} args - Arguments to filter Members to delete.
     * @example
     * // Delete a few Members
     * const { count } = await prisma.member.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MemberDeleteManyArgs>(
      args?: SelectSubset<T, MemberDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MemberUpdateManyArgs>(
      args: SelectSubset<T, MemberUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Member.
     * @param {MemberUpsertArgs} args - Arguments to update or create a Member.
     * @example
     * // Update or create a Member
     * const member = await prisma.member.upsert({
     *   create: {
     *     // ... data to create a Member
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Member we want to update
     *   }
     * })
    **/
    upsert<T extends MemberUpsertArgs>(
      args: SelectSubset<T, MemberUpsertArgs>
    ): CheckSelect<T, Prisma__MemberClient<Member>, Prisma__MemberClient<MemberGetPayload<T>>>

    /**
     * Count the number of Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCountArgs} args - Arguments to filter Members to count.
     * @example
     * // Count the number of Members
     * const count = await prisma.member.count({
     *   where: {
     *     // ... the filter for the Members we want to count
     *   }
     * })
    **/
    count<T extends MemberCountArgs>(
      args?: Subset<T, MemberCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberAggregateArgs>(args: Subset<T, MemberAggregateArgs>): PrismaPromise<GetMemberAggregateType<T>>

    /**
     * Group by Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberGroupByArgs['orderBy'] }
        : { orderBy?: MemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Member.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MemberClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    roles<T extends RoleFindManyArgs = {}>(args?: Subset<T, RoleFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Role>>, PrismaPromise<Array<RoleGetPayload<T>>>>;

    shops<T extends ShopFindManyArgs = {}>(args?: Subset<T, ShopFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Shop>>, PrismaPromise<Array<ShopGetPayload<T>>>>;

    ShoppingCart<T extends ShoppingCartArgs = {}>(args?: Subset<T, ShoppingCartArgs>): CheckSelect<T, Prisma__ShoppingCartClient<ShoppingCart | null >, Prisma__ShoppingCartClient<ShoppingCartGetPayload<T> | null >>;

    MemberCredentials<T extends MemberCredentialsArgs = {}>(args?: Subset<T, MemberCredentialsArgs>): CheckSelect<T, Prisma__MemberCredentialsClient<MemberCredentials | null >, Prisma__MemberCredentialsClient<MemberCredentialsGetPayload<T> | null >>;

    offers<T extends OfferFindManyArgs = {}>(args?: Subset<T, OfferFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Offer>>, PrismaPromise<Array<OfferGetPayload<T>>>>;

    offerApprovers<T extends OfferApproverFindManyArgs = {}>(args?: Subset<T, OfferApproverFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OfferApprover>>, PrismaPromise<Array<OfferApproverGetPayload<T>>>>;

    appointments<T extends AppointmentFindManyArgs = {}>(args?: Subset<T, AppointmentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Appointment>>, PrismaPromise<Array<AppointmentGetPayload<T>>>>;

    messageRecipients<T extends MessageRecipientsFindManyArgs = {}>(args?: Subset<T, MessageRecipientsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<MessageRecipients>>, PrismaPromise<Array<MessageRecipientsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Member findUnique
   */
  export type MemberFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Member
     * 
    **/
    select?: MemberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MemberInclude | null
    /**
     * Throw an Error if a Member can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Member to fetch.
     * 
    **/
    where: MemberWhereUniqueInput
  }


  /**
   * Member findFirst
   */
  export type MemberFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Member
     * 
    **/
    select?: MemberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MemberInclude | null
    /**
     * Throw an Error if a Member can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Member to fetch.
     * 
    **/
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     * 
    **/
    orderBy?: Enumerable<MemberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     * 
    **/
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     * 
    **/
    distinct?: Enumerable<MemberScalarFieldEnum>
  }


  /**
   * Member findMany
   */
  export type MemberFindManyArgs = {
    /**
     * Select specific fields to fetch from the Member
     * 
    **/
    select?: MemberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MemberInclude | null
    /**
     * Filter, which Members to fetch.
     * 
    **/
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     * 
    **/
    orderBy?: Enumerable<MemberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Members.
     * 
    **/
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MemberScalarFieldEnum>
  }


  /**
   * Member create
   */
  export type MemberCreateArgs = {
    /**
     * Select specific fields to fetch from the Member
     * 
    **/
    select?: MemberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MemberInclude | null
    /**
     * The data needed to create a Member.
     * 
    **/
    data: XOR<MemberCreateInput, MemberUncheckedCreateInput>
  }


  /**
   * Member createMany
   */
  export type MemberCreateManyArgs = {
    /**
     * The data used to create many Members.
     * 
    **/
    data: Enumerable<MemberCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Member update
   */
  export type MemberUpdateArgs = {
    /**
     * Select specific fields to fetch from the Member
     * 
    **/
    select?: MemberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MemberInclude | null
    /**
     * The data needed to update a Member.
     * 
    **/
    data: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
    /**
     * Choose, which Member to update.
     * 
    **/
    where: MemberWhereUniqueInput
  }


  /**
   * Member updateMany
   */
  export type MemberUpdateManyArgs = {
    /**
     * The data used to update Members.
     * 
    **/
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     * 
    **/
    where?: MemberWhereInput
  }


  /**
   * Member upsert
   */
  export type MemberUpsertArgs = {
    /**
     * Select specific fields to fetch from the Member
     * 
    **/
    select?: MemberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MemberInclude | null
    /**
     * The filter to search for the Member to update in case it exists.
     * 
    **/
    where: MemberWhereUniqueInput
    /**
     * In case the Member found by the `where` argument doesn't exist, create a new Member with this data.
     * 
    **/
    create: XOR<MemberCreateInput, MemberUncheckedCreateInput>
    /**
     * In case the Member was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
  }


  /**
   * Member delete
   */
  export type MemberDeleteArgs = {
    /**
     * Select specific fields to fetch from the Member
     * 
    **/
    select?: MemberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MemberInclude | null
    /**
     * Filter which Member to delete.
     * 
    **/
    where: MemberWhereUniqueInput
  }


  /**
   * Member deleteMany
   */
  export type MemberDeleteManyArgs = {
    /**
     * Filter which Members to delete
     * 
    **/
    where?: MemberWhereInput
  }


  /**
   * Member without action
   */
  export type MemberArgs = {
    /**
     * Select specific fields to fetch from the Member
     * 
    **/
    select?: MemberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MemberInclude | null
  }



  /**
   * Model Role
   */


  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    shopId: number | null
  }

  export type RoleSumAggregateOutputType = {
    shopId: number | null
  }

  export type RoleMinAggregateOutputType = {
    username: string | null
    shopId: number | null
    job_type: JobType | null
  }

  export type RoleMaxAggregateOutputType = {
    username: string | null
    shopId: number | null
    job_type: JobType | null
  }

  export type RoleCountAggregateOutputType = {
    username: number
    shopId: number
    job_type: number
    permissions: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    shopId?: true
  }

  export type RoleSumAggregateInputType = {
    shopId?: true
  }

  export type RoleMinAggregateInputType = {
    username?: true
    shopId?: true
    job_type?: true
  }

  export type RoleMaxAggregateInputType = {
    username?: true
    shopId?: true
    job_type?: true
  }

  export type RoleCountAggregateInputType = {
    username?: true
    shopId?: true
    job_type?: true
    permissions?: true
    _all?: true
  }

  export type RoleAggregateArgs = {
    /**
     * Filter which Role to aggregate.
     * 
    **/
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     * 
    **/
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs = {
    where?: RoleWhereInput
    orderBy?: Enumerable<RoleOrderByWithAggregationInput>
    by: Array<RoleScalarFieldEnum>
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }


  export type RoleGroupByOutputType = {
    username: string
    shopId: number
    job_type: JobType
    permissions: Permissions[]
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect = {
    member?: boolean | MemberArgs
    username?: boolean
    shop?: boolean | ShopArgs
    shopId?: boolean
    job_type?: boolean
    permissions?: boolean
    shop_owners?: boolean | ShopOwnerFindManyArgs
    shop_managers?: boolean | ShopManagerFindManyArgs
    _count?: boolean | RoleCountOutputTypeArgs
  }

  export type RoleInclude = {
    member?: boolean | MemberArgs
    shop?: boolean | ShopArgs
    shop_owners?: boolean | ShopOwnerFindManyArgs
    shop_managers?: boolean | ShopManagerFindManyArgs
    _count?: boolean | RoleCountOutputTypeArgs
  }

  export type RoleGetPayload<
    S extends boolean | null | undefined | RoleArgs,
    U = keyof S
      > = S extends true
        ? Role
    : S extends undefined
    ? never
    : S extends RoleArgs | RoleFindManyArgs
    ?'include' extends U
    ? Role  & {
    [P in TrueKeys<S['include']>]:
        P extends 'member' ? MemberGetPayload<S['include'][P]> :
        P extends 'shop' ? ShopGetPayload<S['include'][P]> :
        P extends 'shop_owners' ? Array < ShopOwnerGetPayload<S['include'][P]>>  :
        P extends 'shop_managers' ? Array < ShopManagerGetPayload<S['include'][P]>>  :
        P extends '_count' ? RoleCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'member' ? MemberGetPayload<S['select'][P]> :
        P extends 'shop' ? ShopGetPayload<S['select'][P]> :
        P extends 'shop_owners' ? Array < ShopOwnerGetPayload<S['select'][P]>>  :
        P extends 'shop_managers' ? Array < ShopManagerGetPayload<S['select'][P]>>  :
        P extends '_count' ? RoleCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Role ? Role[P] : never
  } 
    : Role
  : Role


  type RoleCountArgs = Merge<
    Omit<RoleFindManyArgs, 'select' | 'include'> & {
      select?: RoleCountAggregateInputType | true
    }
  >

  export interface RoleDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RoleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Role'> extends True ? CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>> : CheckSelect<T, Prisma__RoleClient<Role | null >, Prisma__RoleClient<RoleGetPayload<T> | null >>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RoleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Role'> extends True ? CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>> : CheckSelect<T, Prisma__RoleClient<Role | null >, Prisma__RoleClient<RoleGetPayload<T> | null >>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `username`
     * const roleWithUsernameOnly = await prisma.role.findMany({ select: { username: true } })
     * 
    **/
    findMany<T extends RoleFindManyArgs>(
      args?: SelectSubset<T, RoleFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Role>>, PrismaPromise<Array<RoleGetPayload<T>>>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
    **/
    create<T extends RoleCreateArgs>(
      args: SelectSubset<T, RoleCreateArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Create many Roles.
     *     @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     *     @example
     *     // Create many Roles
     *     const role = await prisma.role.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoleCreateManyArgs>(
      args?: SelectSubset<T, RoleCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
    **/
    delete<T extends RoleDeleteArgs>(
      args: SelectSubset<T, RoleDeleteArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoleUpdateArgs>(
      args: SelectSubset<T, RoleUpdateArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoleDeleteManyArgs>(
      args?: SelectSubset<T, RoleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoleUpdateManyArgs>(
      args: SelectSubset<T, RoleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
    **/
    upsert<T extends RoleUpsertArgs>(
      args: SelectSubset<T, RoleUpsertArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RoleClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    member<T extends MemberArgs = {}>(args?: Subset<T, MemberArgs>): CheckSelect<T, Prisma__MemberClient<Member | null >, Prisma__MemberClient<MemberGetPayload<T> | null >>;

    shop<T extends ShopArgs = {}>(args?: Subset<T, ShopArgs>): CheckSelect<T, Prisma__ShopClient<Shop | null >, Prisma__ShopClient<ShopGetPayload<T> | null >>;

    shop_owners<T extends ShopOwnerFindManyArgs = {}>(args?: Subset<T, ShopOwnerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ShopOwner>>, PrismaPromise<Array<ShopOwnerGetPayload<T>>>>;

    shop_managers<T extends ShopManagerFindManyArgs = {}>(args?: Subset<T, ShopManagerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ShopManager>>, PrismaPromise<Array<ShopManagerGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * Throw an Error if a Role can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Role to fetch.
     * 
    **/
    where: RoleWhereUniqueInput
  }


  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * Throw an Error if a Role can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Role to fetch.
     * 
    **/
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     * 
    **/
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     * 
    **/
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     * 
    **/
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * Role findMany
   */
  export type RoleFindManyArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * Filter, which Roles to fetch.
     * 
    **/
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     * 
    **/
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     * 
    **/
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * Role create
   */
  export type RoleCreateArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * The data needed to create a Role.
     * 
    **/
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }


  /**
   * Role createMany
   */
  export type RoleCreateManyArgs = {
    /**
     * The data used to create many Roles.
     * 
    **/
    data: Enumerable<RoleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Role update
   */
  export type RoleUpdateArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * The data needed to update a Role.
     * 
    **/
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     * 
    **/
    where: RoleWhereUniqueInput
  }


  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs = {
    /**
     * The data used to update Roles.
     * 
    **/
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     * 
    **/
    where?: RoleWhereInput
  }


  /**
   * Role upsert
   */
  export type RoleUpsertArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * The filter to search for the Role to update in case it exists.
     * 
    **/
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     * 
    **/
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }


  /**
   * Role delete
   */
  export type RoleDeleteArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * Filter which Role to delete.
     * 
    **/
    where: RoleWhereUniqueInput
  }


  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs = {
    /**
     * Filter which Roles to delete
     * 
    **/
    where?: RoleWhereInput
  }


  /**
   * Role without action
   */
  export type RoleArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
  }



  /**
   * Model Product
   */


  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    shopId: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    shopId: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    name: string | null
    shopId: number | null
    category: ProductCategory | null
    rate: ProductRate | null
    description: string | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    name: string | null
    shopId: number | null
    category: ProductCategory | null
    rate: ProductRate | null
    description: string | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    shopId: number
    category: number
    rate: number
    description: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    shopId?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    shopId?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    shopId?: true
    category?: true
    rate?: true
    description?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    shopId?: true
    category?: true
    rate?: true
    description?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    shopId?: true
    category?: true
    rate?: true
    description?: true
    _all?: true
  }

  export type ProductAggregateArgs = {
    /**
     * Filter which Product to aggregate.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs = {
    where?: ProductWhereInput
    orderBy?: Enumerable<ProductOrderByWithAggregationInput>
    by: Array<ProductScalarFieldEnum>
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }


  export type ProductGroupByOutputType = {
    id: number
    name: string
    shopId: number
    category: ProductCategory
    rate: ProductRate
    description: string | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect = {
    id?: boolean
    name?: boolean
    shop?: boolean | ShopArgs
    shopId?: boolean
    category?: boolean
    rate?: boolean
    description?: boolean
    products_in_shop?: boolean | ProductInShopFindManyArgs
    products_in_bag?: boolean | ProductInBagFindManyArgs
    offers?: boolean | OfferFindManyArgs
    _count?: boolean | ProductCountOutputTypeArgs
  }

  export type ProductInclude = {
    shop?: boolean | ShopArgs
    products_in_shop?: boolean | ProductInShopFindManyArgs
    products_in_bag?: boolean | ProductInBagFindManyArgs
    offers?: boolean | OfferFindManyArgs
    _count?: boolean | ProductCountOutputTypeArgs
  }

  export type ProductGetPayload<
    S extends boolean | null | undefined | ProductArgs,
    U = keyof S
      > = S extends true
        ? Product
    : S extends undefined
    ? never
    : S extends ProductArgs | ProductFindManyArgs
    ?'include' extends U
    ? Product  & {
    [P in TrueKeys<S['include']>]:
        P extends 'shop' ? ShopGetPayload<S['include'][P]> :
        P extends 'products_in_shop' ? Array < ProductInShopGetPayload<S['include'][P]>>  :
        P extends 'products_in_bag' ? Array < ProductInBagGetPayload<S['include'][P]>>  :
        P extends 'offers' ? Array < OfferGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProductCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'shop' ? ShopGetPayload<S['select'][P]> :
        P extends 'products_in_shop' ? Array < ProductInShopGetPayload<S['select'][P]>>  :
        P extends 'products_in_bag' ? Array < ProductInBagGetPayload<S['select'][P]>>  :
        P extends 'offers' ? Array < OfferGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProductCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Product ? Product[P] : never
  } 
    : Product
  : Product


  type ProductCountArgs = Merge<
    Omit<ProductFindManyArgs, 'select' | 'include'> & {
      select?: ProductCountAggregateInputType | true
    }
  >

  export interface ProductDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Product'> extends True ? CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>> : CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Product'> extends True ? CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>> : CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductFindManyArgs>(
      args?: SelectSubset<T, ProductFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends ProductCreateArgs>(
      args: SelectSubset<T, ProductCreateArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Create many Products.
     *     @param {ProductCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const product = await prisma.product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductCreateManyArgs>(
      args?: SelectSubset<T, ProductCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends ProductDeleteArgs>(
      args: SelectSubset<T, ProductDeleteArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductUpdateArgs>(
      args: SelectSubset<T, ProductUpdateArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductDeleteManyArgs>(
      args?: SelectSubset<T, ProductDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductUpdateManyArgs>(
      args: SelectSubset<T, ProductUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends ProductUpsertArgs>(
      args: SelectSubset<T, ProductUpsertArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    shop<T extends ShopArgs = {}>(args?: Subset<T, ShopArgs>): CheckSelect<T, Prisma__ShopClient<Shop | null >, Prisma__ShopClient<ShopGetPayload<T> | null >>;

    products_in_shop<T extends ProductInShopFindManyArgs = {}>(args?: Subset<T, ProductInShopFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ProductInShop>>, PrismaPromise<Array<ProductInShopGetPayload<T>>>>;

    products_in_bag<T extends ProductInBagFindManyArgs = {}>(args?: Subset<T, ProductInBagFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ProductInBag>>, PrismaPromise<Array<ProductInBagGetPayload<T>>>>;

    offers<T extends OfferFindManyArgs = {}>(args?: Subset<T, OfferFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Offer>>, PrismaPromise<Array<OfferGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Throw an Error if a Product can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Product to fetch.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Throw an Error if a Product can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Product to fetch.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     * 
    **/
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product findMany
   */
  export type ProductFindManyArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter, which Products to fetch.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product create
   */
  export type ProductCreateArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The data needed to create a Product.
     * 
    **/
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }


  /**
   * Product createMany
   */
  export type ProductCreateManyArgs = {
    /**
     * The data used to create many Products.
     * 
    **/
    data: Enumerable<ProductCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Product update
   */
  export type ProductUpdateArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The data needed to update a Product.
     * 
    **/
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs = {
    /**
     * The data used to update Products.
     * 
    **/
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     * 
    **/
    where?: ProductWhereInput
  }


  /**
   * Product upsert
   */
  export type ProductUpsertArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The filter to search for the Product to update in case it exists.
     * 
    **/
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     * 
    **/
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }


  /**
   * Product delete
   */
  export type ProductDeleteArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter which Product to delete.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs = {
    /**
     * Filter which Products to delete
     * 
    **/
    where?: ProductWhereInput
  }


  /**
   * Product without action
   */
  export type ProductArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
  }



  /**
   * Model Shop
   */


  export type AggregateShop = {
    _count: ShopCountAggregateOutputType | null
    _avg: ShopAvgAggregateOutputType | null
    _sum: ShopSumAggregateOutputType | null
    _min: ShopMinAggregateOutputType | null
    _max: ShopMaxAggregateOutputType | null
  }

  export type ShopAvgAggregateOutputType = {
    id: number | null
  }

  export type ShopSumAggregateOutputType = {
    id: number | null
  }

  export type ShopMinAggregateOutputType = {
    id: number | null
    name: string | null
    status: ShopStatus | null
    shop_founder: string | null
    rate: ShopRate | null
    description: string | null
  }

  export type ShopMaxAggregateOutputType = {
    id: number | null
    name: string | null
    status: ShopStatus | null
    shop_founder: string | null
    rate: ShopRate | null
    description: string | null
  }

  export type ShopCountAggregateOutputType = {
    id: number
    name: number
    status: number
    shop_founder: number
    rate: number
    description: number
    _all: number
  }


  export type ShopAvgAggregateInputType = {
    id?: true
  }

  export type ShopSumAggregateInputType = {
    id?: true
  }

  export type ShopMinAggregateInputType = {
    id?: true
    name?: true
    status?: true
    shop_founder?: true
    rate?: true
    description?: true
  }

  export type ShopMaxAggregateInputType = {
    id?: true
    name?: true
    status?: true
    shop_founder?: true
    rate?: true
    description?: true
  }

  export type ShopCountAggregateInputType = {
    id?: true
    name?: true
    status?: true
    shop_founder?: true
    rate?: true
    description?: true
    _all?: true
  }

  export type ShopAggregateArgs = {
    /**
     * Filter which Shop to aggregate.
     * 
    **/
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     * 
    **/
    orderBy?: Enumerable<ShopOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shops
    **/
    _count?: true | ShopCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShopAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShopSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopMaxAggregateInputType
  }

  export type GetShopAggregateType<T extends ShopAggregateArgs> = {
        [P in keyof T & keyof AggregateShop]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShop[P]>
      : GetScalarType<T[P], AggregateShop[P]>
  }




  export type ShopGroupByArgs = {
    where?: ShopWhereInput
    orderBy?: Enumerable<ShopOrderByWithAggregationInput>
    by: Array<ShopScalarFieldEnum>
    having?: ShopScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopCountAggregateInputType | true
    _avg?: ShopAvgAggregateInputType
    _sum?: ShopSumAggregateInputType
    _min?: ShopMinAggregateInputType
    _max?: ShopMaxAggregateInputType
  }


  export type ShopGroupByOutputType = {
    id: number
    name: string
    status: ShopStatus
    shop_founder: string
    rate: ShopRate
    description: string | null
    _count: ShopCountAggregateOutputType | null
    _avg: ShopAvgAggregateOutputType | null
    _sum: ShopSumAggregateOutputType | null
    _min: ShopMinAggregateOutputType | null
    _max: ShopMaxAggregateOutputType | null
  }

  type GetShopGroupByPayload<T extends ShopGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ShopGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopGroupByOutputType[P]>
            : GetScalarType<T[P], ShopGroupByOutputType[P]>
        }
      >
    >


  export type ShopSelect = {
    id?: boolean
    name?: boolean
    status?: boolean
    member?: boolean | MemberArgs
    shop_founder?: boolean
    rate?: boolean
    description?: boolean
    role?: boolean | RoleFindManyArgs
    products?: boolean | ProductFindManyArgs
    products_in_shop?: boolean | ProductInShopFindManyArgs
    bags?: boolean | ShoppingBagFindManyArgs
    discounts?: boolean | DiscountFindManyArgs
    policies?: boolean | PolicyFindManyArgs
    offers?: boolean | OfferFindManyArgs
    appointments?: boolean | AppointmentFindManyArgs
    _count?: boolean | ShopCountOutputTypeArgs
  }

  export type ShopInclude = {
    member?: boolean | MemberArgs
    role?: boolean | RoleFindManyArgs
    products?: boolean | ProductFindManyArgs
    products_in_shop?: boolean | ProductInShopFindManyArgs
    bags?: boolean | ShoppingBagFindManyArgs
    discounts?: boolean | DiscountFindManyArgs
    policies?: boolean | PolicyFindManyArgs
    offers?: boolean | OfferFindManyArgs
    appointments?: boolean | AppointmentFindManyArgs
    _count?: boolean | ShopCountOutputTypeArgs
  }

  export type ShopGetPayload<
    S extends boolean | null | undefined | ShopArgs,
    U = keyof S
      > = S extends true
        ? Shop
    : S extends undefined
    ? never
    : S extends ShopArgs | ShopFindManyArgs
    ?'include' extends U
    ? Shop  & {
    [P in TrueKeys<S['include']>]:
        P extends 'member' ? MemberGetPayload<S['include'][P]> :
        P extends 'role' ? Array < RoleGetPayload<S['include'][P]>>  :
        P extends 'products' ? Array < ProductGetPayload<S['include'][P]>>  :
        P extends 'products_in_shop' ? Array < ProductInShopGetPayload<S['include'][P]>>  :
        P extends 'bags' ? Array < ShoppingBagGetPayload<S['include'][P]>>  :
        P extends 'discounts' ? Array < DiscountGetPayload<S['include'][P]>>  :
        P extends 'policies' ? Array < PolicyGetPayload<S['include'][P]>>  :
        P extends 'offers' ? Array < OfferGetPayload<S['include'][P]>>  :
        P extends 'appointments' ? Array < AppointmentGetPayload<S['include'][P]>>  :
        P extends '_count' ? ShopCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'member' ? MemberGetPayload<S['select'][P]> :
        P extends 'role' ? Array < RoleGetPayload<S['select'][P]>>  :
        P extends 'products' ? Array < ProductGetPayload<S['select'][P]>>  :
        P extends 'products_in_shop' ? Array < ProductInShopGetPayload<S['select'][P]>>  :
        P extends 'bags' ? Array < ShoppingBagGetPayload<S['select'][P]>>  :
        P extends 'discounts' ? Array < DiscountGetPayload<S['select'][P]>>  :
        P extends 'policies' ? Array < PolicyGetPayload<S['select'][P]>>  :
        P extends 'offers' ? Array < OfferGetPayload<S['select'][P]>>  :
        P extends 'appointments' ? Array < AppointmentGetPayload<S['select'][P]>>  :
        P extends '_count' ? ShopCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Shop ? Shop[P] : never
  } 
    : Shop
  : Shop


  type ShopCountArgs = Merge<
    Omit<ShopFindManyArgs, 'select' | 'include'> & {
      select?: ShopCountAggregateInputType | true
    }
  >

  export interface ShopDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Shop that matches the filter.
     * @param {ShopFindUniqueArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ShopFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ShopFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Shop'> extends True ? CheckSelect<T, Prisma__ShopClient<Shop>, Prisma__ShopClient<ShopGetPayload<T>>> : CheckSelect<T, Prisma__ShopClient<Shop | null >, Prisma__ShopClient<ShopGetPayload<T> | null >>

    /**
     * Find the first Shop that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopFindFirstArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ShopFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ShopFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Shop'> extends True ? CheckSelect<T, Prisma__ShopClient<Shop>, Prisma__ShopClient<ShopGetPayload<T>>> : CheckSelect<T, Prisma__ShopClient<Shop | null >, Prisma__ShopClient<ShopGetPayload<T> | null >>

    /**
     * Find zero or more Shops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shops
     * const shops = await prisma.shop.findMany()
     * 
     * // Get first 10 Shops
     * const shops = await prisma.shop.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shopWithIdOnly = await prisma.shop.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ShopFindManyArgs>(
      args?: SelectSubset<T, ShopFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Shop>>, PrismaPromise<Array<ShopGetPayload<T>>>>

    /**
     * Create a Shop.
     * @param {ShopCreateArgs} args - Arguments to create a Shop.
     * @example
     * // Create one Shop
     * const Shop = await prisma.shop.create({
     *   data: {
     *     // ... data to create a Shop
     *   }
     * })
     * 
    **/
    create<T extends ShopCreateArgs>(
      args: SelectSubset<T, ShopCreateArgs>
    ): CheckSelect<T, Prisma__ShopClient<Shop>, Prisma__ShopClient<ShopGetPayload<T>>>

    /**
     * Create many Shops.
     *     @param {ShopCreateManyArgs} args - Arguments to create many Shops.
     *     @example
     *     // Create many Shops
     *     const shop = await prisma.shop.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ShopCreateManyArgs>(
      args?: SelectSubset<T, ShopCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Shop.
     * @param {ShopDeleteArgs} args - Arguments to delete one Shop.
     * @example
     * // Delete one Shop
     * const Shop = await prisma.shop.delete({
     *   where: {
     *     // ... filter to delete one Shop
     *   }
     * })
     * 
    **/
    delete<T extends ShopDeleteArgs>(
      args: SelectSubset<T, ShopDeleteArgs>
    ): CheckSelect<T, Prisma__ShopClient<Shop>, Prisma__ShopClient<ShopGetPayload<T>>>

    /**
     * Update one Shop.
     * @param {ShopUpdateArgs} args - Arguments to update one Shop.
     * @example
     * // Update one Shop
     * const shop = await prisma.shop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ShopUpdateArgs>(
      args: SelectSubset<T, ShopUpdateArgs>
    ): CheckSelect<T, Prisma__ShopClient<Shop>, Prisma__ShopClient<ShopGetPayload<T>>>

    /**
     * Delete zero or more Shops.
     * @param {ShopDeleteManyArgs} args - Arguments to filter Shops to delete.
     * @example
     * // Delete a few Shops
     * const { count } = await prisma.shop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ShopDeleteManyArgs>(
      args?: SelectSubset<T, ShopDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shops
     * const shop = await prisma.shop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ShopUpdateManyArgs>(
      args: SelectSubset<T, ShopUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Shop.
     * @param {ShopUpsertArgs} args - Arguments to update or create a Shop.
     * @example
     * // Update or create a Shop
     * const shop = await prisma.shop.upsert({
     *   create: {
     *     // ... data to create a Shop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shop we want to update
     *   }
     * })
    **/
    upsert<T extends ShopUpsertArgs>(
      args: SelectSubset<T, ShopUpsertArgs>
    ): CheckSelect<T, Prisma__ShopClient<Shop>, Prisma__ShopClient<ShopGetPayload<T>>>

    /**
     * Count the number of Shops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopCountArgs} args - Arguments to filter Shops to count.
     * @example
     * // Count the number of Shops
     * const count = await prisma.shop.count({
     *   where: {
     *     // ... the filter for the Shops we want to count
     *   }
     * })
    **/
    count<T extends ShopCountArgs>(
      args?: Subset<T, ShopCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopAggregateArgs>(args: Subset<T, ShopAggregateArgs>): PrismaPromise<GetShopAggregateType<T>>

    /**
     * Group by Shop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopGroupByArgs['orderBy'] }
        : { orderBy?: ShopGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ShopClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    member<T extends MemberArgs = {}>(args?: Subset<T, MemberArgs>): CheckSelect<T, Prisma__MemberClient<Member | null >, Prisma__MemberClient<MemberGetPayload<T> | null >>;

    role<T extends RoleFindManyArgs = {}>(args?: Subset<T, RoleFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Role>>, PrismaPromise<Array<RoleGetPayload<T>>>>;

    products<T extends ProductFindManyArgs = {}>(args?: Subset<T, ProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>;

    products_in_shop<T extends ProductInShopFindManyArgs = {}>(args?: Subset<T, ProductInShopFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ProductInShop>>, PrismaPromise<Array<ProductInShopGetPayload<T>>>>;

    bags<T extends ShoppingBagFindManyArgs = {}>(args?: Subset<T, ShoppingBagFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ShoppingBag>>, PrismaPromise<Array<ShoppingBagGetPayload<T>>>>;

    discounts<T extends DiscountFindManyArgs = {}>(args?: Subset<T, DiscountFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Discount>>, PrismaPromise<Array<DiscountGetPayload<T>>>>;

    policies<T extends PolicyFindManyArgs = {}>(args?: Subset<T, PolicyFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Policy>>, PrismaPromise<Array<PolicyGetPayload<T>>>>;

    offers<T extends OfferFindManyArgs = {}>(args?: Subset<T, OfferFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Offer>>, PrismaPromise<Array<OfferGetPayload<T>>>>;

    appointments<T extends AppointmentFindManyArgs = {}>(args?: Subset<T, AppointmentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Appointment>>, PrismaPromise<Array<AppointmentGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Shop findUnique
   */
  export type ShopFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Shop
     * 
    **/
    select?: ShopSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShopInclude | null
    /**
     * Throw an Error if a Shop can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Shop to fetch.
     * 
    **/
    where: ShopWhereUniqueInput
  }


  /**
   * Shop findFirst
   */
  export type ShopFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Shop
     * 
    **/
    select?: ShopSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShopInclude | null
    /**
     * Throw an Error if a Shop can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Shop to fetch.
     * 
    **/
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     * 
    **/
    orderBy?: Enumerable<ShopOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shops.
     * 
    **/
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shops.
     * 
    **/
    distinct?: Enumerable<ShopScalarFieldEnum>
  }


  /**
   * Shop findMany
   */
  export type ShopFindManyArgs = {
    /**
     * Select specific fields to fetch from the Shop
     * 
    **/
    select?: ShopSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShopInclude | null
    /**
     * Filter, which Shops to fetch.
     * 
    **/
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     * 
    **/
    orderBy?: Enumerable<ShopOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shops.
     * 
    **/
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ShopScalarFieldEnum>
  }


  /**
   * Shop create
   */
  export type ShopCreateArgs = {
    /**
     * Select specific fields to fetch from the Shop
     * 
    **/
    select?: ShopSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShopInclude | null
    /**
     * The data needed to create a Shop.
     * 
    **/
    data: XOR<ShopCreateInput, ShopUncheckedCreateInput>
  }


  /**
   * Shop createMany
   */
  export type ShopCreateManyArgs = {
    /**
     * The data used to create many Shops.
     * 
    **/
    data: Enumerable<ShopCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Shop update
   */
  export type ShopUpdateArgs = {
    /**
     * Select specific fields to fetch from the Shop
     * 
    **/
    select?: ShopSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShopInclude | null
    /**
     * The data needed to update a Shop.
     * 
    **/
    data: XOR<ShopUpdateInput, ShopUncheckedUpdateInput>
    /**
     * Choose, which Shop to update.
     * 
    **/
    where: ShopWhereUniqueInput
  }


  /**
   * Shop updateMany
   */
  export type ShopUpdateManyArgs = {
    /**
     * The data used to update Shops.
     * 
    **/
    data: XOR<ShopUpdateManyMutationInput, ShopUncheckedUpdateManyInput>
    /**
     * Filter which Shops to update
     * 
    **/
    where?: ShopWhereInput
  }


  /**
   * Shop upsert
   */
  export type ShopUpsertArgs = {
    /**
     * Select specific fields to fetch from the Shop
     * 
    **/
    select?: ShopSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShopInclude | null
    /**
     * The filter to search for the Shop to update in case it exists.
     * 
    **/
    where: ShopWhereUniqueInput
    /**
     * In case the Shop found by the `where` argument doesn't exist, create a new Shop with this data.
     * 
    **/
    create: XOR<ShopCreateInput, ShopUncheckedCreateInput>
    /**
     * In case the Shop was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ShopUpdateInput, ShopUncheckedUpdateInput>
  }


  /**
   * Shop delete
   */
  export type ShopDeleteArgs = {
    /**
     * Select specific fields to fetch from the Shop
     * 
    **/
    select?: ShopSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShopInclude | null
    /**
     * Filter which Shop to delete.
     * 
    **/
    where: ShopWhereUniqueInput
  }


  /**
   * Shop deleteMany
   */
  export type ShopDeleteManyArgs = {
    /**
     * Filter which Shops to delete
     * 
    **/
    where?: ShopWhereInput
  }


  /**
   * Shop without action
   */
  export type ShopArgs = {
    /**
     * Select specific fields to fetch from the Shop
     * 
    **/
    select?: ShopSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShopInclude | null
  }



  /**
   * Model ShopOwner
   */


  export type AggregateShopOwner = {
    _count: ShopOwnerCountAggregateOutputType | null
    _avg: ShopOwnerAvgAggregateOutputType | null
    _sum: ShopOwnerSumAggregateOutputType | null
    _min: ShopOwnerMinAggregateOutputType | null
    _max: ShopOwnerMaxAggregateOutputType | null
  }

  export type ShopOwnerAvgAggregateOutputType = {
    shopId: number | null
  }

  export type ShopOwnerSumAggregateOutputType = {
    shopId: number | null
  }

  export type ShopOwnerMinAggregateOutputType = {
    username: string | null
    shopId: number | null
  }

  export type ShopOwnerMaxAggregateOutputType = {
    username: string | null
    shopId: number | null
  }

  export type ShopOwnerCountAggregateOutputType = {
    username: number
    shopId: number
    _all: number
  }


  export type ShopOwnerAvgAggregateInputType = {
    shopId?: true
  }

  export type ShopOwnerSumAggregateInputType = {
    shopId?: true
  }

  export type ShopOwnerMinAggregateInputType = {
    username?: true
    shopId?: true
  }

  export type ShopOwnerMaxAggregateInputType = {
    username?: true
    shopId?: true
  }

  export type ShopOwnerCountAggregateInputType = {
    username?: true
    shopId?: true
    _all?: true
  }

  export type ShopOwnerAggregateArgs = {
    /**
     * Filter which ShopOwner to aggregate.
     * 
    **/
    where?: ShopOwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopOwners to fetch.
     * 
    **/
    orderBy?: Enumerable<ShopOwnerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ShopOwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopOwners from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopOwners.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShopOwners
    **/
    _count?: true | ShopOwnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShopOwnerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShopOwnerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopOwnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopOwnerMaxAggregateInputType
  }

  export type GetShopOwnerAggregateType<T extends ShopOwnerAggregateArgs> = {
        [P in keyof T & keyof AggregateShopOwner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShopOwner[P]>
      : GetScalarType<T[P], AggregateShopOwner[P]>
  }




  export type ShopOwnerGroupByArgs = {
    where?: ShopOwnerWhereInput
    orderBy?: Enumerable<ShopOwnerOrderByWithAggregationInput>
    by: Array<ShopOwnerScalarFieldEnum>
    having?: ShopOwnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopOwnerCountAggregateInputType | true
    _avg?: ShopOwnerAvgAggregateInputType
    _sum?: ShopOwnerSumAggregateInputType
    _min?: ShopOwnerMinAggregateInputType
    _max?: ShopOwnerMaxAggregateInputType
  }


  export type ShopOwnerGroupByOutputType = {
    username: string
    shopId: number
    _count: ShopOwnerCountAggregateOutputType | null
    _avg: ShopOwnerAvgAggregateOutputType | null
    _sum: ShopOwnerSumAggregateOutputType | null
    _min: ShopOwnerMinAggregateOutputType | null
    _max: ShopOwnerMaxAggregateOutputType | null
  }

  type GetShopOwnerGroupByPayload<T extends ShopOwnerGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ShopOwnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopOwnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopOwnerGroupByOutputType[P]>
            : GetScalarType<T[P], ShopOwnerGroupByOutputType[P]>
        }
      >
    >


  export type ShopOwnerSelect = {
    role?: boolean | RoleArgs
    username?: boolean
    shopId?: boolean
  }

  export type ShopOwnerInclude = {
    role?: boolean | RoleArgs
  }

  export type ShopOwnerGetPayload<
    S extends boolean | null | undefined | ShopOwnerArgs,
    U = keyof S
      > = S extends true
        ? ShopOwner
    : S extends undefined
    ? never
    : S extends ShopOwnerArgs | ShopOwnerFindManyArgs
    ?'include' extends U
    ? ShopOwner  & {
    [P in TrueKeys<S['include']>]:
        P extends 'role' ? RoleGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'role' ? RoleGetPayload<S['select'][P]> :  P extends keyof ShopOwner ? ShopOwner[P] : never
  } 
    : ShopOwner
  : ShopOwner


  type ShopOwnerCountArgs = Merge<
    Omit<ShopOwnerFindManyArgs, 'select' | 'include'> & {
      select?: ShopOwnerCountAggregateInputType | true
    }
  >

  export interface ShopOwnerDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ShopOwner that matches the filter.
     * @param {ShopOwnerFindUniqueArgs} args - Arguments to find a ShopOwner
     * @example
     * // Get one ShopOwner
     * const shopOwner = await prisma.shopOwner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ShopOwnerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ShopOwnerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ShopOwner'> extends True ? CheckSelect<T, Prisma__ShopOwnerClient<ShopOwner>, Prisma__ShopOwnerClient<ShopOwnerGetPayload<T>>> : CheckSelect<T, Prisma__ShopOwnerClient<ShopOwner | null >, Prisma__ShopOwnerClient<ShopOwnerGetPayload<T> | null >>

    /**
     * Find the first ShopOwner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopOwnerFindFirstArgs} args - Arguments to find a ShopOwner
     * @example
     * // Get one ShopOwner
     * const shopOwner = await prisma.shopOwner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ShopOwnerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ShopOwnerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ShopOwner'> extends True ? CheckSelect<T, Prisma__ShopOwnerClient<ShopOwner>, Prisma__ShopOwnerClient<ShopOwnerGetPayload<T>>> : CheckSelect<T, Prisma__ShopOwnerClient<ShopOwner | null >, Prisma__ShopOwnerClient<ShopOwnerGetPayload<T> | null >>

    /**
     * Find zero or more ShopOwners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopOwnerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShopOwners
     * const shopOwners = await prisma.shopOwner.findMany()
     * 
     * // Get first 10 ShopOwners
     * const shopOwners = await prisma.shopOwner.findMany({ take: 10 })
     * 
     * // Only select the `username`
     * const shopOwnerWithUsernameOnly = await prisma.shopOwner.findMany({ select: { username: true } })
     * 
    **/
    findMany<T extends ShopOwnerFindManyArgs>(
      args?: SelectSubset<T, ShopOwnerFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ShopOwner>>, PrismaPromise<Array<ShopOwnerGetPayload<T>>>>

    /**
     * Create a ShopOwner.
     * @param {ShopOwnerCreateArgs} args - Arguments to create a ShopOwner.
     * @example
     * // Create one ShopOwner
     * const ShopOwner = await prisma.shopOwner.create({
     *   data: {
     *     // ... data to create a ShopOwner
     *   }
     * })
     * 
    **/
    create<T extends ShopOwnerCreateArgs>(
      args: SelectSubset<T, ShopOwnerCreateArgs>
    ): CheckSelect<T, Prisma__ShopOwnerClient<ShopOwner>, Prisma__ShopOwnerClient<ShopOwnerGetPayload<T>>>

    /**
     * Create many ShopOwners.
     *     @param {ShopOwnerCreateManyArgs} args - Arguments to create many ShopOwners.
     *     @example
     *     // Create many ShopOwners
     *     const shopOwner = await prisma.shopOwner.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ShopOwnerCreateManyArgs>(
      args?: SelectSubset<T, ShopOwnerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ShopOwner.
     * @param {ShopOwnerDeleteArgs} args - Arguments to delete one ShopOwner.
     * @example
     * // Delete one ShopOwner
     * const ShopOwner = await prisma.shopOwner.delete({
     *   where: {
     *     // ... filter to delete one ShopOwner
     *   }
     * })
     * 
    **/
    delete<T extends ShopOwnerDeleteArgs>(
      args: SelectSubset<T, ShopOwnerDeleteArgs>
    ): CheckSelect<T, Prisma__ShopOwnerClient<ShopOwner>, Prisma__ShopOwnerClient<ShopOwnerGetPayload<T>>>

    /**
     * Update one ShopOwner.
     * @param {ShopOwnerUpdateArgs} args - Arguments to update one ShopOwner.
     * @example
     * // Update one ShopOwner
     * const shopOwner = await prisma.shopOwner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ShopOwnerUpdateArgs>(
      args: SelectSubset<T, ShopOwnerUpdateArgs>
    ): CheckSelect<T, Prisma__ShopOwnerClient<ShopOwner>, Prisma__ShopOwnerClient<ShopOwnerGetPayload<T>>>

    /**
     * Delete zero or more ShopOwners.
     * @param {ShopOwnerDeleteManyArgs} args - Arguments to filter ShopOwners to delete.
     * @example
     * // Delete a few ShopOwners
     * const { count } = await prisma.shopOwner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ShopOwnerDeleteManyArgs>(
      args?: SelectSubset<T, ShopOwnerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShopOwners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopOwnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShopOwners
     * const shopOwner = await prisma.shopOwner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ShopOwnerUpdateManyArgs>(
      args: SelectSubset<T, ShopOwnerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ShopOwner.
     * @param {ShopOwnerUpsertArgs} args - Arguments to update or create a ShopOwner.
     * @example
     * // Update or create a ShopOwner
     * const shopOwner = await prisma.shopOwner.upsert({
     *   create: {
     *     // ... data to create a ShopOwner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShopOwner we want to update
     *   }
     * })
    **/
    upsert<T extends ShopOwnerUpsertArgs>(
      args: SelectSubset<T, ShopOwnerUpsertArgs>
    ): CheckSelect<T, Prisma__ShopOwnerClient<ShopOwner>, Prisma__ShopOwnerClient<ShopOwnerGetPayload<T>>>

    /**
     * Count the number of ShopOwners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopOwnerCountArgs} args - Arguments to filter ShopOwners to count.
     * @example
     * // Count the number of ShopOwners
     * const count = await prisma.shopOwner.count({
     *   where: {
     *     // ... the filter for the ShopOwners we want to count
     *   }
     * })
    **/
    count<T extends ShopOwnerCountArgs>(
      args?: Subset<T, ShopOwnerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopOwnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShopOwner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopOwnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopOwnerAggregateArgs>(args: Subset<T, ShopOwnerAggregateArgs>): PrismaPromise<GetShopOwnerAggregateType<T>>

    /**
     * Group by ShopOwner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopOwnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopOwnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopOwnerGroupByArgs['orderBy'] }
        : { orderBy?: ShopOwnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopOwnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopOwnerGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShopOwner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ShopOwnerClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    role<T extends RoleArgs = {}>(args?: Subset<T, RoleArgs>): CheckSelect<T, Prisma__RoleClient<Role | null >, Prisma__RoleClient<RoleGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ShopOwner findUnique
   */
  export type ShopOwnerFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ShopOwner
     * 
    **/
    select?: ShopOwnerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShopOwnerInclude | null
    /**
     * Throw an Error if a ShopOwner can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ShopOwner to fetch.
     * 
    **/
    where: ShopOwnerWhereUniqueInput
  }


  /**
   * ShopOwner findFirst
   */
  export type ShopOwnerFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ShopOwner
     * 
    **/
    select?: ShopOwnerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShopOwnerInclude | null
    /**
     * Throw an Error if a ShopOwner can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ShopOwner to fetch.
     * 
    **/
    where?: ShopOwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopOwners to fetch.
     * 
    **/
    orderBy?: Enumerable<ShopOwnerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopOwners.
     * 
    **/
    cursor?: ShopOwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopOwners from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopOwners.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopOwners.
     * 
    **/
    distinct?: Enumerable<ShopOwnerScalarFieldEnum>
  }


  /**
   * ShopOwner findMany
   */
  export type ShopOwnerFindManyArgs = {
    /**
     * Select specific fields to fetch from the ShopOwner
     * 
    **/
    select?: ShopOwnerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShopOwnerInclude | null
    /**
     * Filter, which ShopOwners to fetch.
     * 
    **/
    where?: ShopOwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopOwners to fetch.
     * 
    **/
    orderBy?: Enumerable<ShopOwnerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShopOwners.
     * 
    **/
    cursor?: ShopOwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopOwners from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopOwners.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ShopOwnerScalarFieldEnum>
  }


  /**
   * ShopOwner create
   */
  export type ShopOwnerCreateArgs = {
    /**
     * Select specific fields to fetch from the ShopOwner
     * 
    **/
    select?: ShopOwnerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShopOwnerInclude | null
    /**
     * The data needed to create a ShopOwner.
     * 
    **/
    data: XOR<ShopOwnerCreateInput, ShopOwnerUncheckedCreateInput>
  }


  /**
   * ShopOwner createMany
   */
  export type ShopOwnerCreateManyArgs = {
    /**
     * The data used to create many ShopOwners.
     * 
    **/
    data: Enumerable<ShopOwnerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ShopOwner update
   */
  export type ShopOwnerUpdateArgs = {
    /**
     * Select specific fields to fetch from the ShopOwner
     * 
    **/
    select?: ShopOwnerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShopOwnerInclude | null
    /**
     * The data needed to update a ShopOwner.
     * 
    **/
    data: XOR<ShopOwnerUpdateInput, ShopOwnerUncheckedUpdateInput>
    /**
     * Choose, which ShopOwner to update.
     * 
    **/
    where: ShopOwnerWhereUniqueInput
  }


  /**
   * ShopOwner updateMany
   */
  export type ShopOwnerUpdateManyArgs = {
    /**
     * The data used to update ShopOwners.
     * 
    **/
    data: XOR<ShopOwnerUpdateManyMutationInput, ShopOwnerUncheckedUpdateManyInput>
    /**
     * Filter which ShopOwners to update
     * 
    **/
    where?: ShopOwnerWhereInput
  }


  /**
   * ShopOwner upsert
   */
  export type ShopOwnerUpsertArgs = {
    /**
     * Select specific fields to fetch from the ShopOwner
     * 
    **/
    select?: ShopOwnerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShopOwnerInclude | null
    /**
     * The filter to search for the ShopOwner to update in case it exists.
     * 
    **/
    where: ShopOwnerWhereUniqueInput
    /**
     * In case the ShopOwner found by the `where` argument doesn't exist, create a new ShopOwner with this data.
     * 
    **/
    create: XOR<ShopOwnerCreateInput, ShopOwnerUncheckedCreateInput>
    /**
     * In case the ShopOwner was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ShopOwnerUpdateInput, ShopOwnerUncheckedUpdateInput>
  }


  /**
   * ShopOwner delete
   */
  export type ShopOwnerDeleteArgs = {
    /**
     * Select specific fields to fetch from the ShopOwner
     * 
    **/
    select?: ShopOwnerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShopOwnerInclude | null
    /**
     * Filter which ShopOwner to delete.
     * 
    **/
    where: ShopOwnerWhereUniqueInput
  }


  /**
   * ShopOwner deleteMany
   */
  export type ShopOwnerDeleteManyArgs = {
    /**
     * Filter which ShopOwners to delete
     * 
    **/
    where?: ShopOwnerWhereInput
  }


  /**
   * ShopOwner without action
   */
  export type ShopOwnerArgs = {
    /**
     * Select specific fields to fetch from the ShopOwner
     * 
    **/
    select?: ShopOwnerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShopOwnerInclude | null
  }



  /**
   * Model ShopManager
   */


  export type AggregateShopManager = {
    _count: ShopManagerCountAggregateOutputType | null
    _avg: ShopManagerAvgAggregateOutputType | null
    _sum: ShopManagerSumAggregateOutputType | null
    _min: ShopManagerMinAggregateOutputType | null
    _max: ShopManagerMaxAggregateOutputType | null
  }

  export type ShopManagerAvgAggregateOutputType = {
    shopId: number | null
  }

  export type ShopManagerSumAggregateOutputType = {
    shopId: number | null
  }

  export type ShopManagerMinAggregateOutputType = {
    username: string | null
    shopId: number | null
  }

  export type ShopManagerMaxAggregateOutputType = {
    username: string | null
    shopId: number | null
  }

  export type ShopManagerCountAggregateOutputType = {
    username: number
    shopId: number
    _all: number
  }


  export type ShopManagerAvgAggregateInputType = {
    shopId?: true
  }

  export type ShopManagerSumAggregateInputType = {
    shopId?: true
  }

  export type ShopManagerMinAggregateInputType = {
    username?: true
    shopId?: true
  }

  export type ShopManagerMaxAggregateInputType = {
    username?: true
    shopId?: true
  }

  export type ShopManagerCountAggregateInputType = {
    username?: true
    shopId?: true
    _all?: true
  }

  export type ShopManagerAggregateArgs = {
    /**
     * Filter which ShopManager to aggregate.
     * 
    **/
    where?: ShopManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopManagers to fetch.
     * 
    **/
    orderBy?: Enumerable<ShopManagerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ShopManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopManagers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopManagers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShopManagers
    **/
    _count?: true | ShopManagerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShopManagerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShopManagerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopManagerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopManagerMaxAggregateInputType
  }

  export type GetShopManagerAggregateType<T extends ShopManagerAggregateArgs> = {
        [P in keyof T & keyof AggregateShopManager]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShopManager[P]>
      : GetScalarType<T[P], AggregateShopManager[P]>
  }




  export type ShopManagerGroupByArgs = {
    where?: ShopManagerWhereInput
    orderBy?: Enumerable<ShopManagerOrderByWithAggregationInput>
    by: Array<ShopManagerScalarFieldEnum>
    having?: ShopManagerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopManagerCountAggregateInputType | true
    _avg?: ShopManagerAvgAggregateInputType
    _sum?: ShopManagerSumAggregateInputType
    _min?: ShopManagerMinAggregateInputType
    _max?: ShopManagerMaxAggregateInputType
  }


  export type ShopManagerGroupByOutputType = {
    username: string
    shopId: number
    _count: ShopManagerCountAggregateOutputType | null
    _avg: ShopManagerAvgAggregateOutputType | null
    _sum: ShopManagerSumAggregateOutputType | null
    _min: ShopManagerMinAggregateOutputType | null
    _max: ShopManagerMaxAggregateOutputType | null
  }

  type GetShopManagerGroupByPayload<T extends ShopManagerGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ShopManagerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopManagerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopManagerGroupByOutputType[P]>
            : GetScalarType<T[P], ShopManagerGroupByOutputType[P]>
        }
      >
    >


  export type ShopManagerSelect = {
    role?: boolean | RoleArgs
    username?: boolean
    shopId?: boolean
  }

  export type ShopManagerInclude = {
    role?: boolean | RoleArgs
  }

  export type ShopManagerGetPayload<
    S extends boolean | null | undefined | ShopManagerArgs,
    U = keyof S
      > = S extends true
        ? ShopManager
    : S extends undefined
    ? never
    : S extends ShopManagerArgs | ShopManagerFindManyArgs
    ?'include' extends U
    ? ShopManager  & {
    [P in TrueKeys<S['include']>]:
        P extends 'role' ? RoleGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'role' ? RoleGetPayload<S['select'][P]> :  P extends keyof ShopManager ? ShopManager[P] : never
  } 
    : ShopManager
  : ShopManager


  type ShopManagerCountArgs = Merge<
    Omit<ShopManagerFindManyArgs, 'select' | 'include'> & {
      select?: ShopManagerCountAggregateInputType | true
    }
  >

  export interface ShopManagerDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ShopManager that matches the filter.
     * @param {ShopManagerFindUniqueArgs} args - Arguments to find a ShopManager
     * @example
     * // Get one ShopManager
     * const shopManager = await prisma.shopManager.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ShopManagerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ShopManagerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ShopManager'> extends True ? CheckSelect<T, Prisma__ShopManagerClient<ShopManager>, Prisma__ShopManagerClient<ShopManagerGetPayload<T>>> : CheckSelect<T, Prisma__ShopManagerClient<ShopManager | null >, Prisma__ShopManagerClient<ShopManagerGetPayload<T> | null >>

    /**
     * Find the first ShopManager that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopManagerFindFirstArgs} args - Arguments to find a ShopManager
     * @example
     * // Get one ShopManager
     * const shopManager = await prisma.shopManager.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ShopManagerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ShopManagerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ShopManager'> extends True ? CheckSelect<T, Prisma__ShopManagerClient<ShopManager>, Prisma__ShopManagerClient<ShopManagerGetPayload<T>>> : CheckSelect<T, Prisma__ShopManagerClient<ShopManager | null >, Prisma__ShopManagerClient<ShopManagerGetPayload<T> | null >>

    /**
     * Find zero or more ShopManagers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopManagerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShopManagers
     * const shopManagers = await prisma.shopManager.findMany()
     * 
     * // Get first 10 ShopManagers
     * const shopManagers = await prisma.shopManager.findMany({ take: 10 })
     * 
     * // Only select the `username`
     * const shopManagerWithUsernameOnly = await prisma.shopManager.findMany({ select: { username: true } })
     * 
    **/
    findMany<T extends ShopManagerFindManyArgs>(
      args?: SelectSubset<T, ShopManagerFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ShopManager>>, PrismaPromise<Array<ShopManagerGetPayload<T>>>>

    /**
     * Create a ShopManager.
     * @param {ShopManagerCreateArgs} args - Arguments to create a ShopManager.
     * @example
     * // Create one ShopManager
     * const ShopManager = await prisma.shopManager.create({
     *   data: {
     *     // ... data to create a ShopManager
     *   }
     * })
     * 
    **/
    create<T extends ShopManagerCreateArgs>(
      args: SelectSubset<T, ShopManagerCreateArgs>
    ): CheckSelect<T, Prisma__ShopManagerClient<ShopManager>, Prisma__ShopManagerClient<ShopManagerGetPayload<T>>>

    /**
     * Create many ShopManagers.
     *     @param {ShopManagerCreateManyArgs} args - Arguments to create many ShopManagers.
     *     @example
     *     // Create many ShopManagers
     *     const shopManager = await prisma.shopManager.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ShopManagerCreateManyArgs>(
      args?: SelectSubset<T, ShopManagerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ShopManager.
     * @param {ShopManagerDeleteArgs} args - Arguments to delete one ShopManager.
     * @example
     * // Delete one ShopManager
     * const ShopManager = await prisma.shopManager.delete({
     *   where: {
     *     // ... filter to delete one ShopManager
     *   }
     * })
     * 
    **/
    delete<T extends ShopManagerDeleteArgs>(
      args: SelectSubset<T, ShopManagerDeleteArgs>
    ): CheckSelect<T, Prisma__ShopManagerClient<ShopManager>, Prisma__ShopManagerClient<ShopManagerGetPayload<T>>>

    /**
     * Update one ShopManager.
     * @param {ShopManagerUpdateArgs} args - Arguments to update one ShopManager.
     * @example
     * // Update one ShopManager
     * const shopManager = await prisma.shopManager.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ShopManagerUpdateArgs>(
      args: SelectSubset<T, ShopManagerUpdateArgs>
    ): CheckSelect<T, Prisma__ShopManagerClient<ShopManager>, Prisma__ShopManagerClient<ShopManagerGetPayload<T>>>

    /**
     * Delete zero or more ShopManagers.
     * @param {ShopManagerDeleteManyArgs} args - Arguments to filter ShopManagers to delete.
     * @example
     * // Delete a few ShopManagers
     * const { count } = await prisma.shopManager.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ShopManagerDeleteManyArgs>(
      args?: SelectSubset<T, ShopManagerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShopManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopManagerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShopManagers
     * const shopManager = await prisma.shopManager.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ShopManagerUpdateManyArgs>(
      args: SelectSubset<T, ShopManagerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ShopManager.
     * @param {ShopManagerUpsertArgs} args - Arguments to update or create a ShopManager.
     * @example
     * // Update or create a ShopManager
     * const shopManager = await prisma.shopManager.upsert({
     *   create: {
     *     // ... data to create a ShopManager
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShopManager we want to update
     *   }
     * })
    **/
    upsert<T extends ShopManagerUpsertArgs>(
      args: SelectSubset<T, ShopManagerUpsertArgs>
    ): CheckSelect<T, Prisma__ShopManagerClient<ShopManager>, Prisma__ShopManagerClient<ShopManagerGetPayload<T>>>

    /**
     * Count the number of ShopManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopManagerCountArgs} args - Arguments to filter ShopManagers to count.
     * @example
     * // Count the number of ShopManagers
     * const count = await prisma.shopManager.count({
     *   where: {
     *     // ... the filter for the ShopManagers we want to count
     *   }
     * })
    **/
    count<T extends ShopManagerCountArgs>(
      args?: Subset<T, ShopManagerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopManagerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShopManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopManagerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopManagerAggregateArgs>(args: Subset<T, ShopManagerAggregateArgs>): PrismaPromise<GetShopManagerAggregateType<T>>

    /**
     * Group by ShopManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopManagerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopManagerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopManagerGroupByArgs['orderBy'] }
        : { orderBy?: ShopManagerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopManagerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopManagerGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShopManager.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ShopManagerClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    role<T extends RoleArgs = {}>(args?: Subset<T, RoleArgs>): CheckSelect<T, Prisma__RoleClient<Role | null >, Prisma__RoleClient<RoleGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ShopManager findUnique
   */
  export type ShopManagerFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ShopManager
     * 
    **/
    select?: ShopManagerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShopManagerInclude | null
    /**
     * Throw an Error if a ShopManager can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ShopManager to fetch.
     * 
    **/
    where: ShopManagerWhereUniqueInput
  }


  /**
   * ShopManager findFirst
   */
  export type ShopManagerFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ShopManager
     * 
    **/
    select?: ShopManagerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShopManagerInclude | null
    /**
     * Throw an Error if a ShopManager can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ShopManager to fetch.
     * 
    **/
    where?: ShopManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopManagers to fetch.
     * 
    **/
    orderBy?: Enumerable<ShopManagerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopManagers.
     * 
    **/
    cursor?: ShopManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopManagers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopManagers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopManagers.
     * 
    **/
    distinct?: Enumerable<ShopManagerScalarFieldEnum>
  }


  /**
   * ShopManager findMany
   */
  export type ShopManagerFindManyArgs = {
    /**
     * Select specific fields to fetch from the ShopManager
     * 
    **/
    select?: ShopManagerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShopManagerInclude | null
    /**
     * Filter, which ShopManagers to fetch.
     * 
    **/
    where?: ShopManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopManagers to fetch.
     * 
    **/
    orderBy?: Enumerable<ShopManagerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShopManagers.
     * 
    **/
    cursor?: ShopManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopManagers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopManagers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ShopManagerScalarFieldEnum>
  }


  /**
   * ShopManager create
   */
  export type ShopManagerCreateArgs = {
    /**
     * Select specific fields to fetch from the ShopManager
     * 
    **/
    select?: ShopManagerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShopManagerInclude | null
    /**
     * The data needed to create a ShopManager.
     * 
    **/
    data: XOR<ShopManagerCreateInput, ShopManagerUncheckedCreateInput>
  }


  /**
   * ShopManager createMany
   */
  export type ShopManagerCreateManyArgs = {
    /**
     * The data used to create many ShopManagers.
     * 
    **/
    data: Enumerable<ShopManagerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ShopManager update
   */
  export type ShopManagerUpdateArgs = {
    /**
     * Select specific fields to fetch from the ShopManager
     * 
    **/
    select?: ShopManagerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShopManagerInclude | null
    /**
     * The data needed to update a ShopManager.
     * 
    **/
    data: XOR<ShopManagerUpdateInput, ShopManagerUncheckedUpdateInput>
    /**
     * Choose, which ShopManager to update.
     * 
    **/
    where: ShopManagerWhereUniqueInput
  }


  /**
   * ShopManager updateMany
   */
  export type ShopManagerUpdateManyArgs = {
    /**
     * The data used to update ShopManagers.
     * 
    **/
    data: XOR<ShopManagerUpdateManyMutationInput, ShopManagerUncheckedUpdateManyInput>
    /**
     * Filter which ShopManagers to update
     * 
    **/
    where?: ShopManagerWhereInput
  }


  /**
   * ShopManager upsert
   */
  export type ShopManagerUpsertArgs = {
    /**
     * Select specific fields to fetch from the ShopManager
     * 
    **/
    select?: ShopManagerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShopManagerInclude | null
    /**
     * The filter to search for the ShopManager to update in case it exists.
     * 
    **/
    where: ShopManagerWhereUniqueInput
    /**
     * In case the ShopManager found by the `where` argument doesn't exist, create a new ShopManager with this data.
     * 
    **/
    create: XOR<ShopManagerCreateInput, ShopManagerUncheckedCreateInput>
    /**
     * In case the ShopManager was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ShopManagerUpdateInput, ShopManagerUncheckedUpdateInput>
  }


  /**
   * ShopManager delete
   */
  export type ShopManagerDeleteArgs = {
    /**
     * Select specific fields to fetch from the ShopManager
     * 
    **/
    select?: ShopManagerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShopManagerInclude | null
    /**
     * Filter which ShopManager to delete.
     * 
    **/
    where: ShopManagerWhereUniqueInput
  }


  /**
   * ShopManager deleteMany
   */
  export type ShopManagerDeleteManyArgs = {
    /**
     * Filter which ShopManagers to delete
     * 
    **/
    where?: ShopManagerWhereInput
  }


  /**
   * ShopManager without action
   */
  export type ShopManagerArgs = {
    /**
     * Select specific fields to fetch from the ShopManager
     * 
    **/
    select?: ShopManagerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShopManagerInclude | null
  }



  /**
   * Model ProductInShop
   */


  export type AggregateProductInShop = {
    _count: ProductInShopCountAggregateOutputType | null
    _avg: ProductInShopAvgAggregateOutputType | null
    _sum: ProductInShopSumAggregateOutputType | null
    _min: ProductInShopMinAggregateOutputType | null
    _max: ProductInShopMaxAggregateOutputType | null
  }

  export type ProductInShopAvgAggregateOutputType = {
    shopId: number | null
    productId: number | null
    product_quantity: number | null
  }

  export type ProductInShopSumAggregateOutputType = {
    shopId: number | null
    productId: number | null
    product_quantity: number | null
  }

  export type ProductInShopMinAggregateOutputType = {
    shopId: number | null
    productId: number | null
    product_quantity: number | null
  }

  export type ProductInShopMaxAggregateOutputType = {
    shopId: number | null
    productId: number | null
    product_quantity: number | null
  }

  export type ProductInShopCountAggregateOutputType = {
    shopId: number
    productId: number
    product_quantity: number
    _all: number
  }


  export type ProductInShopAvgAggregateInputType = {
    shopId?: true
    productId?: true
    product_quantity?: true
  }

  export type ProductInShopSumAggregateInputType = {
    shopId?: true
    productId?: true
    product_quantity?: true
  }

  export type ProductInShopMinAggregateInputType = {
    shopId?: true
    productId?: true
    product_quantity?: true
  }

  export type ProductInShopMaxAggregateInputType = {
    shopId?: true
    productId?: true
    product_quantity?: true
  }

  export type ProductInShopCountAggregateInputType = {
    shopId?: true
    productId?: true
    product_quantity?: true
    _all?: true
  }

  export type ProductInShopAggregateArgs = {
    /**
     * Filter which ProductInShop to aggregate.
     * 
    **/
    where?: ProductInShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductInShops to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductInShopOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductInShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductInShops from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductInShops.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductInShops
    **/
    _count?: true | ProductInShopCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductInShopAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductInShopSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductInShopMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductInShopMaxAggregateInputType
  }

  export type GetProductInShopAggregateType<T extends ProductInShopAggregateArgs> = {
        [P in keyof T & keyof AggregateProductInShop]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductInShop[P]>
      : GetScalarType<T[P], AggregateProductInShop[P]>
  }




  export type ProductInShopGroupByArgs = {
    where?: ProductInShopWhereInput
    orderBy?: Enumerable<ProductInShopOrderByWithAggregationInput>
    by: Array<ProductInShopScalarFieldEnum>
    having?: ProductInShopScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductInShopCountAggregateInputType | true
    _avg?: ProductInShopAvgAggregateInputType
    _sum?: ProductInShopSumAggregateInputType
    _min?: ProductInShopMinAggregateInputType
    _max?: ProductInShopMaxAggregateInputType
  }


  export type ProductInShopGroupByOutputType = {
    shopId: number
    productId: number
    product_quantity: number
    _count: ProductInShopCountAggregateOutputType | null
    _avg: ProductInShopAvgAggregateOutputType | null
    _sum: ProductInShopSumAggregateOutputType | null
    _min: ProductInShopMinAggregateOutputType | null
    _max: ProductInShopMaxAggregateOutputType | null
  }

  type GetProductInShopGroupByPayload<T extends ProductInShopGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProductInShopGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductInShopGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductInShopGroupByOutputType[P]>
            : GetScalarType<T[P], ProductInShopGroupByOutputType[P]>
        }
      >
    >


  export type ProductInShopSelect = {
    shop?: boolean | ShopArgs
    shopId?: boolean
    product?: boolean | ProductArgs
    productId?: boolean
    product_quantity?: boolean
  }

  export type ProductInShopInclude = {
    shop?: boolean | ShopArgs
    product?: boolean | ProductArgs
  }

  export type ProductInShopGetPayload<
    S extends boolean | null | undefined | ProductInShopArgs,
    U = keyof S
      > = S extends true
        ? ProductInShop
    : S extends undefined
    ? never
    : S extends ProductInShopArgs | ProductInShopFindManyArgs
    ?'include' extends U
    ? ProductInShop  & {
    [P in TrueKeys<S['include']>]:
        P extends 'shop' ? ShopGetPayload<S['include'][P]> :
        P extends 'product' ? ProductGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'shop' ? ShopGetPayload<S['select'][P]> :
        P extends 'product' ? ProductGetPayload<S['select'][P]> :  P extends keyof ProductInShop ? ProductInShop[P] : never
  } 
    : ProductInShop
  : ProductInShop


  type ProductInShopCountArgs = Merge<
    Omit<ProductInShopFindManyArgs, 'select' | 'include'> & {
      select?: ProductInShopCountAggregateInputType | true
    }
  >

  export interface ProductInShopDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ProductInShop that matches the filter.
     * @param {ProductInShopFindUniqueArgs} args - Arguments to find a ProductInShop
     * @example
     * // Get one ProductInShop
     * const productInShop = await prisma.productInShop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductInShopFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductInShopFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductInShop'> extends True ? CheckSelect<T, Prisma__ProductInShopClient<ProductInShop>, Prisma__ProductInShopClient<ProductInShopGetPayload<T>>> : CheckSelect<T, Prisma__ProductInShopClient<ProductInShop | null >, Prisma__ProductInShopClient<ProductInShopGetPayload<T> | null >>

    /**
     * Find the first ProductInShop that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductInShopFindFirstArgs} args - Arguments to find a ProductInShop
     * @example
     * // Get one ProductInShop
     * const productInShop = await prisma.productInShop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductInShopFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductInShopFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductInShop'> extends True ? CheckSelect<T, Prisma__ProductInShopClient<ProductInShop>, Prisma__ProductInShopClient<ProductInShopGetPayload<T>>> : CheckSelect<T, Prisma__ProductInShopClient<ProductInShop | null >, Prisma__ProductInShopClient<ProductInShopGetPayload<T> | null >>

    /**
     * Find zero or more ProductInShops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductInShopFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductInShops
     * const productInShops = await prisma.productInShop.findMany()
     * 
     * // Get first 10 ProductInShops
     * const productInShops = await prisma.productInShop.findMany({ take: 10 })
     * 
     * // Only select the `shopId`
     * const productInShopWithShopIdOnly = await prisma.productInShop.findMany({ select: { shopId: true } })
     * 
    **/
    findMany<T extends ProductInShopFindManyArgs>(
      args?: SelectSubset<T, ProductInShopFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ProductInShop>>, PrismaPromise<Array<ProductInShopGetPayload<T>>>>

    /**
     * Create a ProductInShop.
     * @param {ProductInShopCreateArgs} args - Arguments to create a ProductInShop.
     * @example
     * // Create one ProductInShop
     * const ProductInShop = await prisma.productInShop.create({
     *   data: {
     *     // ... data to create a ProductInShop
     *   }
     * })
     * 
    **/
    create<T extends ProductInShopCreateArgs>(
      args: SelectSubset<T, ProductInShopCreateArgs>
    ): CheckSelect<T, Prisma__ProductInShopClient<ProductInShop>, Prisma__ProductInShopClient<ProductInShopGetPayload<T>>>

    /**
     * Create many ProductInShops.
     *     @param {ProductInShopCreateManyArgs} args - Arguments to create many ProductInShops.
     *     @example
     *     // Create many ProductInShops
     *     const productInShop = await prisma.productInShop.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductInShopCreateManyArgs>(
      args?: SelectSubset<T, ProductInShopCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ProductInShop.
     * @param {ProductInShopDeleteArgs} args - Arguments to delete one ProductInShop.
     * @example
     * // Delete one ProductInShop
     * const ProductInShop = await prisma.productInShop.delete({
     *   where: {
     *     // ... filter to delete one ProductInShop
     *   }
     * })
     * 
    **/
    delete<T extends ProductInShopDeleteArgs>(
      args: SelectSubset<T, ProductInShopDeleteArgs>
    ): CheckSelect<T, Prisma__ProductInShopClient<ProductInShop>, Prisma__ProductInShopClient<ProductInShopGetPayload<T>>>

    /**
     * Update one ProductInShop.
     * @param {ProductInShopUpdateArgs} args - Arguments to update one ProductInShop.
     * @example
     * // Update one ProductInShop
     * const productInShop = await prisma.productInShop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductInShopUpdateArgs>(
      args: SelectSubset<T, ProductInShopUpdateArgs>
    ): CheckSelect<T, Prisma__ProductInShopClient<ProductInShop>, Prisma__ProductInShopClient<ProductInShopGetPayload<T>>>

    /**
     * Delete zero or more ProductInShops.
     * @param {ProductInShopDeleteManyArgs} args - Arguments to filter ProductInShops to delete.
     * @example
     * // Delete a few ProductInShops
     * const { count } = await prisma.productInShop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductInShopDeleteManyArgs>(
      args?: SelectSubset<T, ProductInShopDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductInShops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductInShopUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductInShops
     * const productInShop = await prisma.productInShop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductInShopUpdateManyArgs>(
      args: SelectSubset<T, ProductInShopUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductInShop.
     * @param {ProductInShopUpsertArgs} args - Arguments to update or create a ProductInShop.
     * @example
     * // Update or create a ProductInShop
     * const productInShop = await prisma.productInShop.upsert({
     *   create: {
     *     // ... data to create a ProductInShop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductInShop we want to update
     *   }
     * })
    **/
    upsert<T extends ProductInShopUpsertArgs>(
      args: SelectSubset<T, ProductInShopUpsertArgs>
    ): CheckSelect<T, Prisma__ProductInShopClient<ProductInShop>, Prisma__ProductInShopClient<ProductInShopGetPayload<T>>>

    /**
     * Count the number of ProductInShops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductInShopCountArgs} args - Arguments to filter ProductInShops to count.
     * @example
     * // Count the number of ProductInShops
     * const count = await prisma.productInShop.count({
     *   where: {
     *     // ... the filter for the ProductInShops we want to count
     *   }
     * })
    **/
    count<T extends ProductInShopCountArgs>(
      args?: Subset<T, ProductInShopCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductInShopCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductInShop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductInShopAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductInShopAggregateArgs>(args: Subset<T, ProductInShopAggregateArgs>): PrismaPromise<GetProductInShopAggregateType<T>>

    /**
     * Group by ProductInShop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductInShopGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductInShopGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductInShopGroupByArgs['orderBy'] }
        : { orderBy?: ProductInShopGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductInShopGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductInShopGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductInShop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductInShopClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    shop<T extends ShopArgs = {}>(args?: Subset<T, ShopArgs>): CheckSelect<T, Prisma__ShopClient<Shop | null >, Prisma__ShopClient<ShopGetPayload<T> | null >>;

    product<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ProductInShop findUnique
   */
  export type ProductInShopFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ProductInShop
     * 
    **/
    select?: ProductInShopSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInShopInclude | null
    /**
     * Throw an Error if a ProductInShop can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductInShop to fetch.
     * 
    **/
    where: ProductInShopWhereUniqueInput
  }


  /**
   * ProductInShop findFirst
   */
  export type ProductInShopFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ProductInShop
     * 
    **/
    select?: ProductInShopSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInShopInclude | null
    /**
     * Throw an Error if a ProductInShop can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductInShop to fetch.
     * 
    **/
    where?: ProductInShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductInShops to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductInShopOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductInShops.
     * 
    **/
    cursor?: ProductInShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductInShops from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductInShops.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductInShops.
     * 
    **/
    distinct?: Enumerable<ProductInShopScalarFieldEnum>
  }


  /**
   * ProductInShop findMany
   */
  export type ProductInShopFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProductInShop
     * 
    **/
    select?: ProductInShopSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInShopInclude | null
    /**
     * Filter, which ProductInShops to fetch.
     * 
    **/
    where?: ProductInShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductInShops to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductInShopOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductInShops.
     * 
    **/
    cursor?: ProductInShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductInShops from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductInShops.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductInShopScalarFieldEnum>
  }


  /**
   * ProductInShop create
   */
  export type ProductInShopCreateArgs = {
    /**
     * Select specific fields to fetch from the ProductInShop
     * 
    **/
    select?: ProductInShopSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInShopInclude | null
    /**
     * The data needed to create a ProductInShop.
     * 
    **/
    data: XOR<ProductInShopCreateInput, ProductInShopUncheckedCreateInput>
  }


  /**
   * ProductInShop createMany
   */
  export type ProductInShopCreateManyArgs = {
    /**
     * The data used to create many ProductInShops.
     * 
    **/
    data: Enumerable<ProductInShopCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductInShop update
   */
  export type ProductInShopUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProductInShop
     * 
    **/
    select?: ProductInShopSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInShopInclude | null
    /**
     * The data needed to update a ProductInShop.
     * 
    **/
    data: XOR<ProductInShopUpdateInput, ProductInShopUncheckedUpdateInput>
    /**
     * Choose, which ProductInShop to update.
     * 
    **/
    where: ProductInShopWhereUniqueInput
  }


  /**
   * ProductInShop updateMany
   */
  export type ProductInShopUpdateManyArgs = {
    /**
     * The data used to update ProductInShops.
     * 
    **/
    data: XOR<ProductInShopUpdateManyMutationInput, ProductInShopUncheckedUpdateManyInput>
    /**
     * Filter which ProductInShops to update
     * 
    **/
    where?: ProductInShopWhereInput
  }


  /**
   * ProductInShop upsert
   */
  export type ProductInShopUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProductInShop
     * 
    **/
    select?: ProductInShopSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInShopInclude | null
    /**
     * The filter to search for the ProductInShop to update in case it exists.
     * 
    **/
    where: ProductInShopWhereUniqueInput
    /**
     * In case the ProductInShop found by the `where` argument doesn't exist, create a new ProductInShop with this data.
     * 
    **/
    create: XOR<ProductInShopCreateInput, ProductInShopUncheckedCreateInput>
    /**
     * In case the ProductInShop was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductInShopUpdateInput, ProductInShopUncheckedUpdateInput>
  }


  /**
   * ProductInShop delete
   */
  export type ProductInShopDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProductInShop
     * 
    **/
    select?: ProductInShopSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInShopInclude | null
    /**
     * Filter which ProductInShop to delete.
     * 
    **/
    where: ProductInShopWhereUniqueInput
  }


  /**
   * ProductInShop deleteMany
   */
  export type ProductInShopDeleteManyArgs = {
    /**
     * Filter which ProductInShops to delete
     * 
    **/
    where?: ProductInShopWhereInput
  }


  /**
   * ProductInShop without action
   */
  export type ProductInShopArgs = {
    /**
     * Select specific fields to fetch from the ProductInShop
     * 
    **/
    select?: ProductInShopSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInShopInclude | null
  }



  /**
   * Model ShoppingCart
   */


  export type AggregateShoppingCart = {
    _count: ShoppingCartCountAggregateOutputType | null
    _min: ShoppingCartMinAggregateOutputType | null
    _max: ShoppingCartMaxAggregateOutputType | null
  }

  export type ShoppingCartMinAggregateOutputType = {
    username: string | null
  }

  export type ShoppingCartMaxAggregateOutputType = {
    username: string | null
  }

  export type ShoppingCartCountAggregateOutputType = {
    username: number
    _all: number
  }


  export type ShoppingCartMinAggregateInputType = {
    username?: true
  }

  export type ShoppingCartMaxAggregateInputType = {
    username?: true
  }

  export type ShoppingCartCountAggregateInputType = {
    username?: true
    _all?: true
  }

  export type ShoppingCartAggregateArgs = {
    /**
     * Filter which ShoppingCart to aggregate.
     * 
    **/
    where?: ShoppingCartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShoppingCarts to fetch.
     * 
    **/
    orderBy?: Enumerable<ShoppingCartOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ShoppingCartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShoppingCarts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShoppingCarts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShoppingCarts
    **/
    _count?: true | ShoppingCartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShoppingCartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShoppingCartMaxAggregateInputType
  }

  export type GetShoppingCartAggregateType<T extends ShoppingCartAggregateArgs> = {
        [P in keyof T & keyof AggregateShoppingCart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShoppingCart[P]>
      : GetScalarType<T[P], AggregateShoppingCart[P]>
  }




  export type ShoppingCartGroupByArgs = {
    where?: ShoppingCartWhereInput
    orderBy?: Enumerable<ShoppingCartOrderByWithAggregationInput>
    by: Array<ShoppingCartScalarFieldEnum>
    having?: ShoppingCartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShoppingCartCountAggregateInputType | true
    _min?: ShoppingCartMinAggregateInputType
    _max?: ShoppingCartMaxAggregateInputType
  }


  export type ShoppingCartGroupByOutputType = {
    username: string
    _count: ShoppingCartCountAggregateOutputType | null
    _min: ShoppingCartMinAggregateOutputType | null
    _max: ShoppingCartMaxAggregateOutputType | null
  }

  type GetShoppingCartGroupByPayload<T extends ShoppingCartGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ShoppingCartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShoppingCartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShoppingCartGroupByOutputType[P]>
            : GetScalarType<T[P], ShoppingCartGroupByOutputType[P]>
        }
      >
    >


  export type ShoppingCartSelect = {
    member?: boolean | MemberArgs
    username?: boolean
    bags?: boolean | ShoppingBagFindManyArgs
    _count?: boolean | ShoppingCartCountOutputTypeArgs
  }

  export type ShoppingCartInclude = {
    member?: boolean | MemberArgs
    bags?: boolean | ShoppingBagFindManyArgs
    _count?: boolean | ShoppingCartCountOutputTypeArgs
  }

  export type ShoppingCartGetPayload<
    S extends boolean | null | undefined | ShoppingCartArgs,
    U = keyof S
      > = S extends true
        ? ShoppingCart
    : S extends undefined
    ? never
    : S extends ShoppingCartArgs | ShoppingCartFindManyArgs
    ?'include' extends U
    ? ShoppingCart  & {
    [P in TrueKeys<S['include']>]:
        P extends 'member' ? MemberGetPayload<S['include'][P]> :
        P extends 'bags' ? Array < ShoppingBagGetPayload<S['include'][P]>>  :
        P extends '_count' ? ShoppingCartCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'member' ? MemberGetPayload<S['select'][P]> :
        P extends 'bags' ? Array < ShoppingBagGetPayload<S['select'][P]>>  :
        P extends '_count' ? ShoppingCartCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ShoppingCart ? ShoppingCart[P] : never
  } 
    : ShoppingCart
  : ShoppingCart


  type ShoppingCartCountArgs = Merge<
    Omit<ShoppingCartFindManyArgs, 'select' | 'include'> & {
      select?: ShoppingCartCountAggregateInputType | true
    }
  >

  export interface ShoppingCartDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ShoppingCart that matches the filter.
     * @param {ShoppingCartFindUniqueArgs} args - Arguments to find a ShoppingCart
     * @example
     * // Get one ShoppingCart
     * const shoppingCart = await prisma.shoppingCart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ShoppingCartFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ShoppingCartFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ShoppingCart'> extends True ? CheckSelect<T, Prisma__ShoppingCartClient<ShoppingCart>, Prisma__ShoppingCartClient<ShoppingCartGetPayload<T>>> : CheckSelect<T, Prisma__ShoppingCartClient<ShoppingCart | null >, Prisma__ShoppingCartClient<ShoppingCartGetPayload<T> | null >>

    /**
     * Find the first ShoppingCart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingCartFindFirstArgs} args - Arguments to find a ShoppingCart
     * @example
     * // Get one ShoppingCart
     * const shoppingCart = await prisma.shoppingCart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ShoppingCartFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ShoppingCartFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ShoppingCart'> extends True ? CheckSelect<T, Prisma__ShoppingCartClient<ShoppingCart>, Prisma__ShoppingCartClient<ShoppingCartGetPayload<T>>> : CheckSelect<T, Prisma__ShoppingCartClient<ShoppingCart | null >, Prisma__ShoppingCartClient<ShoppingCartGetPayload<T> | null >>

    /**
     * Find zero or more ShoppingCarts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingCartFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShoppingCarts
     * const shoppingCarts = await prisma.shoppingCart.findMany()
     * 
     * // Get first 10 ShoppingCarts
     * const shoppingCarts = await prisma.shoppingCart.findMany({ take: 10 })
     * 
     * // Only select the `username`
     * const shoppingCartWithUsernameOnly = await prisma.shoppingCart.findMany({ select: { username: true } })
     * 
    **/
    findMany<T extends ShoppingCartFindManyArgs>(
      args?: SelectSubset<T, ShoppingCartFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ShoppingCart>>, PrismaPromise<Array<ShoppingCartGetPayload<T>>>>

    /**
     * Create a ShoppingCart.
     * @param {ShoppingCartCreateArgs} args - Arguments to create a ShoppingCart.
     * @example
     * // Create one ShoppingCart
     * const ShoppingCart = await prisma.shoppingCart.create({
     *   data: {
     *     // ... data to create a ShoppingCart
     *   }
     * })
     * 
    **/
    create<T extends ShoppingCartCreateArgs>(
      args: SelectSubset<T, ShoppingCartCreateArgs>
    ): CheckSelect<T, Prisma__ShoppingCartClient<ShoppingCart>, Prisma__ShoppingCartClient<ShoppingCartGetPayload<T>>>

    /**
     * Create many ShoppingCarts.
     *     @param {ShoppingCartCreateManyArgs} args - Arguments to create many ShoppingCarts.
     *     @example
     *     // Create many ShoppingCarts
     *     const shoppingCart = await prisma.shoppingCart.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ShoppingCartCreateManyArgs>(
      args?: SelectSubset<T, ShoppingCartCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ShoppingCart.
     * @param {ShoppingCartDeleteArgs} args - Arguments to delete one ShoppingCart.
     * @example
     * // Delete one ShoppingCart
     * const ShoppingCart = await prisma.shoppingCart.delete({
     *   where: {
     *     // ... filter to delete one ShoppingCart
     *   }
     * })
     * 
    **/
    delete<T extends ShoppingCartDeleteArgs>(
      args: SelectSubset<T, ShoppingCartDeleteArgs>
    ): CheckSelect<T, Prisma__ShoppingCartClient<ShoppingCart>, Prisma__ShoppingCartClient<ShoppingCartGetPayload<T>>>

    /**
     * Update one ShoppingCart.
     * @param {ShoppingCartUpdateArgs} args - Arguments to update one ShoppingCart.
     * @example
     * // Update one ShoppingCart
     * const shoppingCart = await prisma.shoppingCart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ShoppingCartUpdateArgs>(
      args: SelectSubset<T, ShoppingCartUpdateArgs>
    ): CheckSelect<T, Prisma__ShoppingCartClient<ShoppingCart>, Prisma__ShoppingCartClient<ShoppingCartGetPayload<T>>>

    /**
     * Delete zero or more ShoppingCarts.
     * @param {ShoppingCartDeleteManyArgs} args - Arguments to filter ShoppingCarts to delete.
     * @example
     * // Delete a few ShoppingCarts
     * const { count } = await prisma.shoppingCart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ShoppingCartDeleteManyArgs>(
      args?: SelectSubset<T, ShoppingCartDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShoppingCarts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingCartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShoppingCarts
     * const shoppingCart = await prisma.shoppingCart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ShoppingCartUpdateManyArgs>(
      args: SelectSubset<T, ShoppingCartUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ShoppingCart.
     * @param {ShoppingCartUpsertArgs} args - Arguments to update or create a ShoppingCart.
     * @example
     * // Update or create a ShoppingCart
     * const shoppingCart = await prisma.shoppingCart.upsert({
     *   create: {
     *     // ... data to create a ShoppingCart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShoppingCart we want to update
     *   }
     * })
    **/
    upsert<T extends ShoppingCartUpsertArgs>(
      args: SelectSubset<T, ShoppingCartUpsertArgs>
    ): CheckSelect<T, Prisma__ShoppingCartClient<ShoppingCart>, Prisma__ShoppingCartClient<ShoppingCartGetPayload<T>>>

    /**
     * Count the number of ShoppingCarts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingCartCountArgs} args - Arguments to filter ShoppingCarts to count.
     * @example
     * // Count the number of ShoppingCarts
     * const count = await prisma.shoppingCart.count({
     *   where: {
     *     // ... the filter for the ShoppingCarts we want to count
     *   }
     * })
    **/
    count<T extends ShoppingCartCountArgs>(
      args?: Subset<T, ShoppingCartCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShoppingCartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShoppingCart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingCartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShoppingCartAggregateArgs>(args: Subset<T, ShoppingCartAggregateArgs>): PrismaPromise<GetShoppingCartAggregateType<T>>

    /**
     * Group by ShoppingCart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingCartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShoppingCartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShoppingCartGroupByArgs['orderBy'] }
        : { orderBy?: ShoppingCartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShoppingCartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShoppingCartGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShoppingCart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ShoppingCartClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    member<T extends MemberArgs = {}>(args?: Subset<T, MemberArgs>): CheckSelect<T, Prisma__MemberClient<Member | null >, Prisma__MemberClient<MemberGetPayload<T> | null >>;

    bags<T extends ShoppingBagFindManyArgs = {}>(args?: Subset<T, ShoppingBagFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ShoppingBag>>, PrismaPromise<Array<ShoppingBagGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ShoppingCart findUnique
   */
  export type ShoppingCartFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ShoppingCart
     * 
    **/
    select?: ShoppingCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShoppingCartInclude | null
    /**
     * Throw an Error if a ShoppingCart can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ShoppingCart to fetch.
     * 
    **/
    where: ShoppingCartWhereUniqueInput
  }


  /**
   * ShoppingCart findFirst
   */
  export type ShoppingCartFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ShoppingCart
     * 
    **/
    select?: ShoppingCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShoppingCartInclude | null
    /**
     * Throw an Error if a ShoppingCart can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ShoppingCart to fetch.
     * 
    **/
    where?: ShoppingCartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShoppingCarts to fetch.
     * 
    **/
    orderBy?: Enumerable<ShoppingCartOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShoppingCarts.
     * 
    **/
    cursor?: ShoppingCartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShoppingCarts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShoppingCarts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShoppingCarts.
     * 
    **/
    distinct?: Enumerable<ShoppingCartScalarFieldEnum>
  }


  /**
   * ShoppingCart findMany
   */
  export type ShoppingCartFindManyArgs = {
    /**
     * Select specific fields to fetch from the ShoppingCart
     * 
    **/
    select?: ShoppingCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShoppingCartInclude | null
    /**
     * Filter, which ShoppingCarts to fetch.
     * 
    **/
    where?: ShoppingCartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShoppingCarts to fetch.
     * 
    **/
    orderBy?: Enumerable<ShoppingCartOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShoppingCarts.
     * 
    **/
    cursor?: ShoppingCartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShoppingCarts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShoppingCarts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ShoppingCartScalarFieldEnum>
  }


  /**
   * ShoppingCart create
   */
  export type ShoppingCartCreateArgs = {
    /**
     * Select specific fields to fetch from the ShoppingCart
     * 
    **/
    select?: ShoppingCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShoppingCartInclude | null
    /**
     * The data needed to create a ShoppingCart.
     * 
    **/
    data: XOR<ShoppingCartCreateInput, ShoppingCartUncheckedCreateInput>
  }


  /**
   * ShoppingCart createMany
   */
  export type ShoppingCartCreateManyArgs = {
    /**
     * The data used to create many ShoppingCarts.
     * 
    **/
    data: Enumerable<ShoppingCartCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ShoppingCart update
   */
  export type ShoppingCartUpdateArgs = {
    /**
     * Select specific fields to fetch from the ShoppingCart
     * 
    **/
    select?: ShoppingCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShoppingCartInclude | null
    /**
     * The data needed to update a ShoppingCart.
     * 
    **/
    data: XOR<ShoppingCartUpdateInput, ShoppingCartUncheckedUpdateInput>
    /**
     * Choose, which ShoppingCart to update.
     * 
    **/
    where: ShoppingCartWhereUniqueInput
  }


  /**
   * ShoppingCart updateMany
   */
  export type ShoppingCartUpdateManyArgs = {
    /**
     * The data used to update ShoppingCarts.
     * 
    **/
    data: XOR<ShoppingCartUpdateManyMutationInput, ShoppingCartUncheckedUpdateManyInput>
    /**
     * Filter which ShoppingCarts to update
     * 
    **/
    where?: ShoppingCartWhereInput
  }


  /**
   * ShoppingCart upsert
   */
  export type ShoppingCartUpsertArgs = {
    /**
     * Select specific fields to fetch from the ShoppingCart
     * 
    **/
    select?: ShoppingCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShoppingCartInclude | null
    /**
     * The filter to search for the ShoppingCart to update in case it exists.
     * 
    **/
    where: ShoppingCartWhereUniqueInput
    /**
     * In case the ShoppingCart found by the `where` argument doesn't exist, create a new ShoppingCart with this data.
     * 
    **/
    create: XOR<ShoppingCartCreateInput, ShoppingCartUncheckedCreateInput>
    /**
     * In case the ShoppingCart was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ShoppingCartUpdateInput, ShoppingCartUncheckedUpdateInput>
  }


  /**
   * ShoppingCart delete
   */
  export type ShoppingCartDeleteArgs = {
    /**
     * Select specific fields to fetch from the ShoppingCart
     * 
    **/
    select?: ShoppingCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShoppingCartInclude | null
    /**
     * Filter which ShoppingCart to delete.
     * 
    **/
    where: ShoppingCartWhereUniqueInput
  }


  /**
   * ShoppingCart deleteMany
   */
  export type ShoppingCartDeleteManyArgs = {
    /**
     * Filter which ShoppingCarts to delete
     * 
    **/
    where?: ShoppingCartWhereInput
  }


  /**
   * ShoppingCart without action
   */
  export type ShoppingCartArgs = {
    /**
     * Select specific fields to fetch from the ShoppingCart
     * 
    **/
    select?: ShoppingCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShoppingCartInclude | null
  }



  /**
   * Model ShoppingBag
   */


  export type AggregateShoppingBag = {
    _count: ShoppingBagCountAggregateOutputType | null
    _avg: ShoppingBagAvgAggregateOutputType | null
    _sum: ShoppingBagSumAggregateOutputType | null
    _min: ShoppingBagMinAggregateOutputType | null
    _max: ShoppingBagMaxAggregateOutputType | null
  }

  export type ShoppingBagAvgAggregateOutputType = {
    shopId: number | null
  }

  export type ShoppingBagSumAggregateOutputType = {
    shopId: number | null
  }

  export type ShoppingBagMinAggregateOutputType = {
    username: string | null
    shopId: number | null
  }

  export type ShoppingBagMaxAggregateOutputType = {
    username: string | null
    shopId: number | null
  }

  export type ShoppingBagCountAggregateOutputType = {
    username: number
    shopId: number
    _all: number
  }


  export type ShoppingBagAvgAggregateInputType = {
    shopId?: true
  }

  export type ShoppingBagSumAggregateInputType = {
    shopId?: true
  }

  export type ShoppingBagMinAggregateInputType = {
    username?: true
    shopId?: true
  }

  export type ShoppingBagMaxAggregateInputType = {
    username?: true
    shopId?: true
  }

  export type ShoppingBagCountAggregateInputType = {
    username?: true
    shopId?: true
    _all?: true
  }

  export type ShoppingBagAggregateArgs = {
    /**
     * Filter which ShoppingBag to aggregate.
     * 
    **/
    where?: ShoppingBagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShoppingBags to fetch.
     * 
    **/
    orderBy?: Enumerable<ShoppingBagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ShoppingBagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShoppingBags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShoppingBags.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShoppingBags
    **/
    _count?: true | ShoppingBagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShoppingBagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShoppingBagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShoppingBagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShoppingBagMaxAggregateInputType
  }

  export type GetShoppingBagAggregateType<T extends ShoppingBagAggregateArgs> = {
        [P in keyof T & keyof AggregateShoppingBag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShoppingBag[P]>
      : GetScalarType<T[P], AggregateShoppingBag[P]>
  }




  export type ShoppingBagGroupByArgs = {
    where?: ShoppingBagWhereInput
    orderBy?: Enumerable<ShoppingBagOrderByWithAggregationInput>
    by: Array<ShoppingBagScalarFieldEnum>
    having?: ShoppingBagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShoppingBagCountAggregateInputType | true
    _avg?: ShoppingBagAvgAggregateInputType
    _sum?: ShoppingBagSumAggregateInputType
    _min?: ShoppingBagMinAggregateInputType
    _max?: ShoppingBagMaxAggregateInputType
  }


  export type ShoppingBagGroupByOutputType = {
    username: string
    shopId: number
    _count: ShoppingBagCountAggregateOutputType | null
    _avg: ShoppingBagAvgAggregateOutputType | null
    _sum: ShoppingBagSumAggregateOutputType | null
    _min: ShoppingBagMinAggregateOutputType | null
    _max: ShoppingBagMaxAggregateOutputType | null
  }

  type GetShoppingBagGroupByPayload<T extends ShoppingBagGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ShoppingBagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShoppingBagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShoppingBagGroupByOutputType[P]>
            : GetScalarType<T[P], ShoppingBagGroupByOutputType[P]>
        }
      >
    >


  export type ShoppingBagSelect = {
    shoppingCart?: boolean | ShoppingCartArgs
    username?: boolean
    shop?: boolean | ShopArgs
    shopId?: boolean
    products_in_bag?: boolean | ProductInBagFindManyArgs
    _count?: boolean | ShoppingBagCountOutputTypeArgs
  }

  export type ShoppingBagInclude = {
    shoppingCart?: boolean | ShoppingCartArgs
    shop?: boolean | ShopArgs
    products_in_bag?: boolean | ProductInBagFindManyArgs
    _count?: boolean | ShoppingBagCountOutputTypeArgs
  }

  export type ShoppingBagGetPayload<
    S extends boolean | null | undefined | ShoppingBagArgs,
    U = keyof S
      > = S extends true
        ? ShoppingBag
    : S extends undefined
    ? never
    : S extends ShoppingBagArgs | ShoppingBagFindManyArgs
    ?'include' extends U
    ? ShoppingBag  & {
    [P in TrueKeys<S['include']>]:
        P extends 'shoppingCart' ? ShoppingCartGetPayload<S['include'][P]> :
        P extends 'shop' ? ShopGetPayload<S['include'][P]> :
        P extends 'products_in_bag' ? Array < ProductInBagGetPayload<S['include'][P]>>  :
        P extends '_count' ? ShoppingBagCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'shoppingCart' ? ShoppingCartGetPayload<S['select'][P]> :
        P extends 'shop' ? ShopGetPayload<S['select'][P]> :
        P extends 'products_in_bag' ? Array < ProductInBagGetPayload<S['select'][P]>>  :
        P extends '_count' ? ShoppingBagCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ShoppingBag ? ShoppingBag[P] : never
  } 
    : ShoppingBag
  : ShoppingBag


  type ShoppingBagCountArgs = Merge<
    Omit<ShoppingBagFindManyArgs, 'select' | 'include'> & {
      select?: ShoppingBagCountAggregateInputType | true
    }
  >

  export interface ShoppingBagDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ShoppingBag that matches the filter.
     * @param {ShoppingBagFindUniqueArgs} args - Arguments to find a ShoppingBag
     * @example
     * // Get one ShoppingBag
     * const shoppingBag = await prisma.shoppingBag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ShoppingBagFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ShoppingBagFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ShoppingBag'> extends True ? CheckSelect<T, Prisma__ShoppingBagClient<ShoppingBag>, Prisma__ShoppingBagClient<ShoppingBagGetPayload<T>>> : CheckSelect<T, Prisma__ShoppingBagClient<ShoppingBag | null >, Prisma__ShoppingBagClient<ShoppingBagGetPayload<T> | null >>

    /**
     * Find the first ShoppingBag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingBagFindFirstArgs} args - Arguments to find a ShoppingBag
     * @example
     * // Get one ShoppingBag
     * const shoppingBag = await prisma.shoppingBag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ShoppingBagFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ShoppingBagFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ShoppingBag'> extends True ? CheckSelect<T, Prisma__ShoppingBagClient<ShoppingBag>, Prisma__ShoppingBagClient<ShoppingBagGetPayload<T>>> : CheckSelect<T, Prisma__ShoppingBagClient<ShoppingBag | null >, Prisma__ShoppingBagClient<ShoppingBagGetPayload<T> | null >>

    /**
     * Find zero or more ShoppingBags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingBagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShoppingBags
     * const shoppingBags = await prisma.shoppingBag.findMany()
     * 
     * // Get first 10 ShoppingBags
     * const shoppingBags = await prisma.shoppingBag.findMany({ take: 10 })
     * 
     * // Only select the `username`
     * const shoppingBagWithUsernameOnly = await prisma.shoppingBag.findMany({ select: { username: true } })
     * 
    **/
    findMany<T extends ShoppingBagFindManyArgs>(
      args?: SelectSubset<T, ShoppingBagFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ShoppingBag>>, PrismaPromise<Array<ShoppingBagGetPayload<T>>>>

    /**
     * Create a ShoppingBag.
     * @param {ShoppingBagCreateArgs} args - Arguments to create a ShoppingBag.
     * @example
     * // Create one ShoppingBag
     * const ShoppingBag = await prisma.shoppingBag.create({
     *   data: {
     *     // ... data to create a ShoppingBag
     *   }
     * })
     * 
    **/
    create<T extends ShoppingBagCreateArgs>(
      args: SelectSubset<T, ShoppingBagCreateArgs>
    ): CheckSelect<T, Prisma__ShoppingBagClient<ShoppingBag>, Prisma__ShoppingBagClient<ShoppingBagGetPayload<T>>>

    /**
     * Create many ShoppingBags.
     *     @param {ShoppingBagCreateManyArgs} args - Arguments to create many ShoppingBags.
     *     @example
     *     // Create many ShoppingBags
     *     const shoppingBag = await prisma.shoppingBag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ShoppingBagCreateManyArgs>(
      args?: SelectSubset<T, ShoppingBagCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ShoppingBag.
     * @param {ShoppingBagDeleteArgs} args - Arguments to delete one ShoppingBag.
     * @example
     * // Delete one ShoppingBag
     * const ShoppingBag = await prisma.shoppingBag.delete({
     *   where: {
     *     // ... filter to delete one ShoppingBag
     *   }
     * })
     * 
    **/
    delete<T extends ShoppingBagDeleteArgs>(
      args: SelectSubset<T, ShoppingBagDeleteArgs>
    ): CheckSelect<T, Prisma__ShoppingBagClient<ShoppingBag>, Prisma__ShoppingBagClient<ShoppingBagGetPayload<T>>>

    /**
     * Update one ShoppingBag.
     * @param {ShoppingBagUpdateArgs} args - Arguments to update one ShoppingBag.
     * @example
     * // Update one ShoppingBag
     * const shoppingBag = await prisma.shoppingBag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ShoppingBagUpdateArgs>(
      args: SelectSubset<T, ShoppingBagUpdateArgs>
    ): CheckSelect<T, Prisma__ShoppingBagClient<ShoppingBag>, Prisma__ShoppingBagClient<ShoppingBagGetPayload<T>>>

    /**
     * Delete zero or more ShoppingBags.
     * @param {ShoppingBagDeleteManyArgs} args - Arguments to filter ShoppingBags to delete.
     * @example
     * // Delete a few ShoppingBags
     * const { count } = await prisma.shoppingBag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ShoppingBagDeleteManyArgs>(
      args?: SelectSubset<T, ShoppingBagDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShoppingBags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingBagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShoppingBags
     * const shoppingBag = await prisma.shoppingBag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ShoppingBagUpdateManyArgs>(
      args: SelectSubset<T, ShoppingBagUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ShoppingBag.
     * @param {ShoppingBagUpsertArgs} args - Arguments to update or create a ShoppingBag.
     * @example
     * // Update or create a ShoppingBag
     * const shoppingBag = await prisma.shoppingBag.upsert({
     *   create: {
     *     // ... data to create a ShoppingBag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShoppingBag we want to update
     *   }
     * })
    **/
    upsert<T extends ShoppingBagUpsertArgs>(
      args: SelectSubset<T, ShoppingBagUpsertArgs>
    ): CheckSelect<T, Prisma__ShoppingBagClient<ShoppingBag>, Prisma__ShoppingBagClient<ShoppingBagGetPayload<T>>>

    /**
     * Count the number of ShoppingBags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingBagCountArgs} args - Arguments to filter ShoppingBags to count.
     * @example
     * // Count the number of ShoppingBags
     * const count = await prisma.shoppingBag.count({
     *   where: {
     *     // ... the filter for the ShoppingBags we want to count
     *   }
     * })
    **/
    count<T extends ShoppingBagCountArgs>(
      args?: Subset<T, ShoppingBagCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShoppingBagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShoppingBag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingBagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShoppingBagAggregateArgs>(args: Subset<T, ShoppingBagAggregateArgs>): PrismaPromise<GetShoppingBagAggregateType<T>>

    /**
     * Group by ShoppingBag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingBagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShoppingBagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShoppingBagGroupByArgs['orderBy'] }
        : { orderBy?: ShoppingBagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShoppingBagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShoppingBagGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShoppingBag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ShoppingBagClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    shoppingCart<T extends ShoppingCartArgs = {}>(args?: Subset<T, ShoppingCartArgs>): CheckSelect<T, Prisma__ShoppingCartClient<ShoppingCart | null >, Prisma__ShoppingCartClient<ShoppingCartGetPayload<T> | null >>;

    shop<T extends ShopArgs = {}>(args?: Subset<T, ShopArgs>): CheckSelect<T, Prisma__ShopClient<Shop | null >, Prisma__ShopClient<ShopGetPayload<T> | null >>;

    products_in_bag<T extends ProductInBagFindManyArgs = {}>(args?: Subset<T, ProductInBagFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ProductInBag>>, PrismaPromise<Array<ProductInBagGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ShoppingBag findUnique
   */
  export type ShoppingBagFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ShoppingBag
     * 
    **/
    select?: ShoppingBagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShoppingBagInclude | null
    /**
     * Throw an Error if a ShoppingBag can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ShoppingBag to fetch.
     * 
    **/
    where: ShoppingBagWhereUniqueInput
  }


  /**
   * ShoppingBag findFirst
   */
  export type ShoppingBagFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ShoppingBag
     * 
    **/
    select?: ShoppingBagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShoppingBagInclude | null
    /**
     * Throw an Error if a ShoppingBag can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ShoppingBag to fetch.
     * 
    **/
    where?: ShoppingBagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShoppingBags to fetch.
     * 
    **/
    orderBy?: Enumerable<ShoppingBagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShoppingBags.
     * 
    **/
    cursor?: ShoppingBagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShoppingBags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShoppingBags.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShoppingBags.
     * 
    **/
    distinct?: Enumerable<ShoppingBagScalarFieldEnum>
  }


  /**
   * ShoppingBag findMany
   */
  export type ShoppingBagFindManyArgs = {
    /**
     * Select specific fields to fetch from the ShoppingBag
     * 
    **/
    select?: ShoppingBagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShoppingBagInclude | null
    /**
     * Filter, which ShoppingBags to fetch.
     * 
    **/
    where?: ShoppingBagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShoppingBags to fetch.
     * 
    **/
    orderBy?: Enumerable<ShoppingBagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShoppingBags.
     * 
    **/
    cursor?: ShoppingBagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShoppingBags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShoppingBags.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ShoppingBagScalarFieldEnum>
  }


  /**
   * ShoppingBag create
   */
  export type ShoppingBagCreateArgs = {
    /**
     * Select specific fields to fetch from the ShoppingBag
     * 
    **/
    select?: ShoppingBagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShoppingBagInclude | null
    /**
     * The data needed to create a ShoppingBag.
     * 
    **/
    data: XOR<ShoppingBagCreateInput, ShoppingBagUncheckedCreateInput>
  }


  /**
   * ShoppingBag createMany
   */
  export type ShoppingBagCreateManyArgs = {
    /**
     * The data used to create many ShoppingBags.
     * 
    **/
    data: Enumerable<ShoppingBagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ShoppingBag update
   */
  export type ShoppingBagUpdateArgs = {
    /**
     * Select specific fields to fetch from the ShoppingBag
     * 
    **/
    select?: ShoppingBagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShoppingBagInclude | null
    /**
     * The data needed to update a ShoppingBag.
     * 
    **/
    data: XOR<ShoppingBagUpdateInput, ShoppingBagUncheckedUpdateInput>
    /**
     * Choose, which ShoppingBag to update.
     * 
    **/
    where: ShoppingBagWhereUniqueInput
  }


  /**
   * ShoppingBag updateMany
   */
  export type ShoppingBagUpdateManyArgs = {
    /**
     * The data used to update ShoppingBags.
     * 
    **/
    data: XOR<ShoppingBagUpdateManyMutationInput, ShoppingBagUncheckedUpdateManyInput>
    /**
     * Filter which ShoppingBags to update
     * 
    **/
    where?: ShoppingBagWhereInput
  }


  /**
   * ShoppingBag upsert
   */
  export type ShoppingBagUpsertArgs = {
    /**
     * Select specific fields to fetch from the ShoppingBag
     * 
    **/
    select?: ShoppingBagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShoppingBagInclude | null
    /**
     * The filter to search for the ShoppingBag to update in case it exists.
     * 
    **/
    where: ShoppingBagWhereUniqueInput
    /**
     * In case the ShoppingBag found by the `where` argument doesn't exist, create a new ShoppingBag with this data.
     * 
    **/
    create: XOR<ShoppingBagCreateInput, ShoppingBagUncheckedCreateInput>
    /**
     * In case the ShoppingBag was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ShoppingBagUpdateInput, ShoppingBagUncheckedUpdateInput>
  }


  /**
   * ShoppingBag delete
   */
  export type ShoppingBagDeleteArgs = {
    /**
     * Select specific fields to fetch from the ShoppingBag
     * 
    **/
    select?: ShoppingBagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShoppingBagInclude | null
    /**
     * Filter which ShoppingBag to delete.
     * 
    **/
    where: ShoppingBagWhereUniqueInput
  }


  /**
   * ShoppingBag deleteMany
   */
  export type ShoppingBagDeleteManyArgs = {
    /**
     * Filter which ShoppingBags to delete
     * 
    **/
    where?: ShoppingBagWhereInput
  }


  /**
   * ShoppingBag without action
   */
  export type ShoppingBagArgs = {
    /**
     * Select specific fields to fetch from the ShoppingBag
     * 
    **/
    select?: ShoppingBagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShoppingBagInclude | null
  }



  /**
   * Model ProductInBag
   */


  export type AggregateProductInBag = {
    _count: ProductInBagCountAggregateOutputType | null
    _avg: ProductInBagAvgAggregateOutputType | null
    _sum: ProductInBagSumAggregateOutputType | null
    _min: ProductInBagMinAggregateOutputType | null
    _max: ProductInBagMaxAggregateOutputType | null
  }

  export type ProductInBagAvgAggregateOutputType = {
    shopId: number | null
    productId: number | null
    product_quantity: number | null
  }

  export type ProductInBagSumAggregateOutputType = {
    shopId: number | null
    productId: number | null
    product_quantity: number | null
  }

  export type ProductInBagMinAggregateOutputType = {
    username: string | null
    shopId: number | null
    productId: number | null
    product_quantity: number | null
  }

  export type ProductInBagMaxAggregateOutputType = {
    username: string | null
    shopId: number | null
    productId: number | null
    product_quantity: number | null
  }

  export type ProductInBagCountAggregateOutputType = {
    username: number
    shopId: number
    productId: number
    product_quantity: number
    _all: number
  }


  export type ProductInBagAvgAggregateInputType = {
    shopId?: true
    productId?: true
    product_quantity?: true
  }

  export type ProductInBagSumAggregateInputType = {
    shopId?: true
    productId?: true
    product_quantity?: true
  }

  export type ProductInBagMinAggregateInputType = {
    username?: true
    shopId?: true
    productId?: true
    product_quantity?: true
  }

  export type ProductInBagMaxAggregateInputType = {
    username?: true
    shopId?: true
    productId?: true
    product_quantity?: true
  }

  export type ProductInBagCountAggregateInputType = {
    username?: true
    shopId?: true
    productId?: true
    product_quantity?: true
    _all?: true
  }

  export type ProductInBagAggregateArgs = {
    /**
     * Filter which ProductInBag to aggregate.
     * 
    **/
    where?: ProductInBagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductInBags to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductInBagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductInBagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductInBags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductInBags.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductInBags
    **/
    _count?: true | ProductInBagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductInBagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductInBagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductInBagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductInBagMaxAggregateInputType
  }

  export type GetProductInBagAggregateType<T extends ProductInBagAggregateArgs> = {
        [P in keyof T & keyof AggregateProductInBag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductInBag[P]>
      : GetScalarType<T[P], AggregateProductInBag[P]>
  }




  export type ProductInBagGroupByArgs = {
    where?: ProductInBagWhereInput
    orderBy?: Enumerable<ProductInBagOrderByWithAggregationInput>
    by: Array<ProductInBagScalarFieldEnum>
    having?: ProductInBagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductInBagCountAggregateInputType | true
    _avg?: ProductInBagAvgAggregateInputType
    _sum?: ProductInBagSumAggregateInputType
    _min?: ProductInBagMinAggregateInputType
    _max?: ProductInBagMaxAggregateInputType
  }


  export type ProductInBagGroupByOutputType = {
    username: string
    shopId: number
    productId: number
    product_quantity: number
    _count: ProductInBagCountAggregateOutputType | null
    _avg: ProductInBagAvgAggregateOutputType | null
    _sum: ProductInBagSumAggregateOutputType | null
    _min: ProductInBagMinAggregateOutputType | null
    _max: ProductInBagMaxAggregateOutputType | null
  }

  type GetProductInBagGroupByPayload<T extends ProductInBagGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProductInBagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductInBagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductInBagGroupByOutputType[P]>
            : GetScalarType<T[P], ProductInBagGroupByOutputType[P]>
        }
      >
    >


  export type ProductInBagSelect = {
    shoppingBag?: boolean | ShoppingBagArgs
    username?: boolean
    shopId?: boolean
    product?: boolean | ProductArgs
    productId?: boolean
    product_quantity?: boolean
  }

  export type ProductInBagInclude = {
    shoppingBag?: boolean | ShoppingBagArgs
    product?: boolean | ProductArgs
  }

  export type ProductInBagGetPayload<
    S extends boolean | null | undefined | ProductInBagArgs,
    U = keyof S
      > = S extends true
        ? ProductInBag
    : S extends undefined
    ? never
    : S extends ProductInBagArgs | ProductInBagFindManyArgs
    ?'include' extends U
    ? ProductInBag  & {
    [P in TrueKeys<S['include']>]:
        P extends 'shoppingBag' ? ShoppingBagGetPayload<S['include'][P]> :
        P extends 'product' ? ProductGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'shoppingBag' ? ShoppingBagGetPayload<S['select'][P]> :
        P extends 'product' ? ProductGetPayload<S['select'][P]> :  P extends keyof ProductInBag ? ProductInBag[P] : never
  } 
    : ProductInBag
  : ProductInBag


  type ProductInBagCountArgs = Merge<
    Omit<ProductInBagFindManyArgs, 'select' | 'include'> & {
      select?: ProductInBagCountAggregateInputType | true
    }
  >

  export interface ProductInBagDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ProductInBag that matches the filter.
     * @param {ProductInBagFindUniqueArgs} args - Arguments to find a ProductInBag
     * @example
     * // Get one ProductInBag
     * const productInBag = await prisma.productInBag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductInBagFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductInBagFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductInBag'> extends True ? CheckSelect<T, Prisma__ProductInBagClient<ProductInBag>, Prisma__ProductInBagClient<ProductInBagGetPayload<T>>> : CheckSelect<T, Prisma__ProductInBagClient<ProductInBag | null >, Prisma__ProductInBagClient<ProductInBagGetPayload<T> | null >>

    /**
     * Find the first ProductInBag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductInBagFindFirstArgs} args - Arguments to find a ProductInBag
     * @example
     * // Get one ProductInBag
     * const productInBag = await prisma.productInBag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductInBagFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductInBagFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductInBag'> extends True ? CheckSelect<T, Prisma__ProductInBagClient<ProductInBag>, Prisma__ProductInBagClient<ProductInBagGetPayload<T>>> : CheckSelect<T, Prisma__ProductInBagClient<ProductInBag | null >, Prisma__ProductInBagClient<ProductInBagGetPayload<T> | null >>

    /**
     * Find zero or more ProductInBags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductInBagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductInBags
     * const productInBags = await prisma.productInBag.findMany()
     * 
     * // Get first 10 ProductInBags
     * const productInBags = await prisma.productInBag.findMany({ take: 10 })
     * 
     * // Only select the `username`
     * const productInBagWithUsernameOnly = await prisma.productInBag.findMany({ select: { username: true } })
     * 
    **/
    findMany<T extends ProductInBagFindManyArgs>(
      args?: SelectSubset<T, ProductInBagFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ProductInBag>>, PrismaPromise<Array<ProductInBagGetPayload<T>>>>

    /**
     * Create a ProductInBag.
     * @param {ProductInBagCreateArgs} args - Arguments to create a ProductInBag.
     * @example
     * // Create one ProductInBag
     * const ProductInBag = await prisma.productInBag.create({
     *   data: {
     *     // ... data to create a ProductInBag
     *   }
     * })
     * 
    **/
    create<T extends ProductInBagCreateArgs>(
      args: SelectSubset<T, ProductInBagCreateArgs>
    ): CheckSelect<T, Prisma__ProductInBagClient<ProductInBag>, Prisma__ProductInBagClient<ProductInBagGetPayload<T>>>

    /**
     * Create many ProductInBags.
     *     @param {ProductInBagCreateManyArgs} args - Arguments to create many ProductInBags.
     *     @example
     *     // Create many ProductInBags
     *     const productInBag = await prisma.productInBag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductInBagCreateManyArgs>(
      args?: SelectSubset<T, ProductInBagCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ProductInBag.
     * @param {ProductInBagDeleteArgs} args - Arguments to delete one ProductInBag.
     * @example
     * // Delete one ProductInBag
     * const ProductInBag = await prisma.productInBag.delete({
     *   where: {
     *     // ... filter to delete one ProductInBag
     *   }
     * })
     * 
    **/
    delete<T extends ProductInBagDeleteArgs>(
      args: SelectSubset<T, ProductInBagDeleteArgs>
    ): CheckSelect<T, Prisma__ProductInBagClient<ProductInBag>, Prisma__ProductInBagClient<ProductInBagGetPayload<T>>>

    /**
     * Update one ProductInBag.
     * @param {ProductInBagUpdateArgs} args - Arguments to update one ProductInBag.
     * @example
     * // Update one ProductInBag
     * const productInBag = await prisma.productInBag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductInBagUpdateArgs>(
      args: SelectSubset<T, ProductInBagUpdateArgs>
    ): CheckSelect<T, Prisma__ProductInBagClient<ProductInBag>, Prisma__ProductInBagClient<ProductInBagGetPayload<T>>>

    /**
     * Delete zero or more ProductInBags.
     * @param {ProductInBagDeleteManyArgs} args - Arguments to filter ProductInBags to delete.
     * @example
     * // Delete a few ProductInBags
     * const { count } = await prisma.productInBag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductInBagDeleteManyArgs>(
      args?: SelectSubset<T, ProductInBagDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductInBags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductInBagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductInBags
     * const productInBag = await prisma.productInBag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductInBagUpdateManyArgs>(
      args: SelectSubset<T, ProductInBagUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductInBag.
     * @param {ProductInBagUpsertArgs} args - Arguments to update or create a ProductInBag.
     * @example
     * // Update or create a ProductInBag
     * const productInBag = await prisma.productInBag.upsert({
     *   create: {
     *     // ... data to create a ProductInBag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductInBag we want to update
     *   }
     * })
    **/
    upsert<T extends ProductInBagUpsertArgs>(
      args: SelectSubset<T, ProductInBagUpsertArgs>
    ): CheckSelect<T, Prisma__ProductInBagClient<ProductInBag>, Prisma__ProductInBagClient<ProductInBagGetPayload<T>>>

    /**
     * Count the number of ProductInBags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductInBagCountArgs} args - Arguments to filter ProductInBags to count.
     * @example
     * // Count the number of ProductInBags
     * const count = await prisma.productInBag.count({
     *   where: {
     *     // ... the filter for the ProductInBags we want to count
     *   }
     * })
    **/
    count<T extends ProductInBagCountArgs>(
      args?: Subset<T, ProductInBagCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductInBagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductInBag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductInBagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductInBagAggregateArgs>(args: Subset<T, ProductInBagAggregateArgs>): PrismaPromise<GetProductInBagAggregateType<T>>

    /**
     * Group by ProductInBag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductInBagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductInBagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductInBagGroupByArgs['orderBy'] }
        : { orderBy?: ProductInBagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductInBagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductInBagGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductInBag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductInBagClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    shoppingBag<T extends ShoppingBagArgs = {}>(args?: Subset<T, ShoppingBagArgs>): CheckSelect<T, Prisma__ShoppingBagClient<ShoppingBag | null >, Prisma__ShoppingBagClient<ShoppingBagGetPayload<T> | null >>;

    product<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ProductInBag findUnique
   */
  export type ProductInBagFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ProductInBag
     * 
    **/
    select?: ProductInBagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInBagInclude | null
    /**
     * Throw an Error if a ProductInBag can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductInBag to fetch.
     * 
    **/
    where: ProductInBagWhereUniqueInput
  }


  /**
   * ProductInBag findFirst
   */
  export type ProductInBagFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ProductInBag
     * 
    **/
    select?: ProductInBagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInBagInclude | null
    /**
     * Throw an Error if a ProductInBag can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductInBag to fetch.
     * 
    **/
    where?: ProductInBagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductInBags to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductInBagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductInBags.
     * 
    **/
    cursor?: ProductInBagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductInBags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductInBags.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductInBags.
     * 
    **/
    distinct?: Enumerable<ProductInBagScalarFieldEnum>
  }


  /**
   * ProductInBag findMany
   */
  export type ProductInBagFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProductInBag
     * 
    **/
    select?: ProductInBagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInBagInclude | null
    /**
     * Filter, which ProductInBags to fetch.
     * 
    **/
    where?: ProductInBagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductInBags to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductInBagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductInBags.
     * 
    **/
    cursor?: ProductInBagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductInBags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductInBags.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductInBagScalarFieldEnum>
  }


  /**
   * ProductInBag create
   */
  export type ProductInBagCreateArgs = {
    /**
     * Select specific fields to fetch from the ProductInBag
     * 
    **/
    select?: ProductInBagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInBagInclude | null
    /**
     * The data needed to create a ProductInBag.
     * 
    **/
    data: XOR<ProductInBagCreateInput, ProductInBagUncheckedCreateInput>
  }


  /**
   * ProductInBag createMany
   */
  export type ProductInBagCreateManyArgs = {
    /**
     * The data used to create many ProductInBags.
     * 
    **/
    data: Enumerable<ProductInBagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductInBag update
   */
  export type ProductInBagUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProductInBag
     * 
    **/
    select?: ProductInBagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInBagInclude | null
    /**
     * The data needed to update a ProductInBag.
     * 
    **/
    data: XOR<ProductInBagUpdateInput, ProductInBagUncheckedUpdateInput>
    /**
     * Choose, which ProductInBag to update.
     * 
    **/
    where: ProductInBagWhereUniqueInput
  }


  /**
   * ProductInBag updateMany
   */
  export type ProductInBagUpdateManyArgs = {
    /**
     * The data used to update ProductInBags.
     * 
    **/
    data: XOR<ProductInBagUpdateManyMutationInput, ProductInBagUncheckedUpdateManyInput>
    /**
     * Filter which ProductInBags to update
     * 
    **/
    where?: ProductInBagWhereInput
  }


  /**
   * ProductInBag upsert
   */
  export type ProductInBagUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProductInBag
     * 
    **/
    select?: ProductInBagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInBagInclude | null
    /**
     * The filter to search for the ProductInBag to update in case it exists.
     * 
    **/
    where: ProductInBagWhereUniqueInput
    /**
     * In case the ProductInBag found by the `where` argument doesn't exist, create a new ProductInBag with this data.
     * 
    **/
    create: XOR<ProductInBagCreateInput, ProductInBagUncheckedCreateInput>
    /**
     * In case the ProductInBag was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductInBagUpdateInput, ProductInBagUncheckedUpdateInput>
  }


  /**
   * ProductInBag delete
   */
  export type ProductInBagDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProductInBag
     * 
    **/
    select?: ProductInBagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInBagInclude | null
    /**
     * Filter which ProductInBag to delete.
     * 
    **/
    where: ProductInBagWhereUniqueInput
  }


  /**
   * ProductInBag deleteMany
   */
  export type ProductInBagDeleteManyArgs = {
    /**
     * Filter which ProductInBags to delete
     * 
    **/
    where?: ProductInBagWhereInput
  }


  /**
   * ProductInBag without action
   */
  export type ProductInBagArgs = {
    /**
     * Select specific fields to fetch from the ProductInBag
     * 
    **/
    select?: ProductInBagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInBagInclude | null
  }



  /**
   * Model MemberCredentials
   */


  export type AggregateMemberCredentials = {
    _count: MemberCredentialsCountAggregateOutputType | null
    _min: MemberCredentialsMinAggregateOutputType | null
    _max: MemberCredentialsMaxAggregateOutputType | null
  }

  export type MemberCredentialsMinAggregateOutputType = {
    username: string | null
    password: string | null
  }

  export type MemberCredentialsMaxAggregateOutputType = {
    username: string | null
    password: string | null
  }

  export type MemberCredentialsCountAggregateOutputType = {
    username: number
    password: number
    _all: number
  }


  export type MemberCredentialsMinAggregateInputType = {
    username?: true
    password?: true
  }

  export type MemberCredentialsMaxAggregateInputType = {
    username?: true
    password?: true
  }

  export type MemberCredentialsCountAggregateInputType = {
    username?: true
    password?: true
    _all?: true
  }

  export type MemberCredentialsAggregateArgs = {
    /**
     * Filter which MemberCredentials to aggregate.
     * 
    **/
    where?: MemberCredentialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberCredentials to fetch.
     * 
    **/
    orderBy?: Enumerable<MemberCredentialsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MemberCredentialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberCredentials from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberCredentials.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MemberCredentials
    **/
    _count?: true | MemberCredentialsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberCredentialsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberCredentialsMaxAggregateInputType
  }

  export type GetMemberCredentialsAggregateType<T extends MemberCredentialsAggregateArgs> = {
        [P in keyof T & keyof AggregateMemberCredentials]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemberCredentials[P]>
      : GetScalarType<T[P], AggregateMemberCredentials[P]>
  }




  export type MemberCredentialsGroupByArgs = {
    where?: MemberCredentialsWhereInput
    orderBy?: Enumerable<MemberCredentialsOrderByWithAggregationInput>
    by: Array<MemberCredentialsScalarFieldEnum>
    having?: MemberCredentialsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberCredentialsCountAggregateInputType | true
    _min?: MemberCredentialsMinAggregateInputType
    _max?: MemberCredentialsMaxAggregateInputType
  }


  export type MemberCredentialsGroupByOutputType = {
    username: string
    password: string
    _count: MemberCredentialsCountAggregateOutputType | null
    _min: MemberCredentialsMinAggregateOutputType | null
    _max: MemberCredentialsMaxAggregateOutputType | null
  }

  type GetMemberCredentialsGroupByPayload<T extends MemberCredentialsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MemberCredentialsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberCredentialsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberCredentialsGroupByOutputType[P]>
            : GetScalarType<T[P], MemberCredentialsGroupByOutputType[P]>
        }
      >
    >


  export type MemberCredentialsSelect = {
    member?: boolean | MemberArgs
    username?: boolean
    password?: boolean
  }

  export type MemberCredentialsInclude = {
    member?: boolean | MemberArgs
  }

  export type MemberCredentialsGetPayload<
    S extends boolean | null | undefined | MemberCredentialsArgs,
    U = keyof S
      > = S extends true
        ? MemberCredentials
    : S extends undefined
    ? never
    : S extends MemberCredentialsArgs | MemberCredentialsFindManyArgs
    ?'include' extends U
    ? MemberCredentials  & {
    [P in TrueKeys<S['include']>]:
        P extends 'member' ? MemberGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'member' ? MemberGetPayload<S['select'][P]> | null :  P extends keyof MemberCredentials ? MemberCredentials[P] : never
  } 
    : MemberCredentials
  : MemberCredentials


  type MemberCredentialsCountArgs = Merge<
    Omit<MemberCredentialsFindManyArgs, 'select' | 'include'> & {
      select?: MemberCredentialsCountAggregateInputType | true
    }
  >

  export interface MemberCredentialsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one MemberCredentials that matches the filter.
     * @param {MemberCredentialsFindUniqueArgs} args - Arguments to find a MemberCredentials
     * @example
     * // Get one MemberCredentials
     * const memberCredentials = await prisma.memberCredentials.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MemberCredentialsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MemberCredentialsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MemberCredentials'> extends True ? CheckSelect<T, Prisma__MemberCredentialsClient<MemberCredentials>, Prisma__MemberCredentialsClient<MemberCredentialsGetPayload<T>>> : CheckSelect<T, Prisma__MemberCredentialsClient<MemberCredentials | null >, Prisma__MemberCredentialsClient<MemberCredentialsGetPayload<T> | null >>

    /**
     * Find the first MemberCredentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCredentialsFindFirstArgs} args - Arguments to find a MemberCredentials
     * @example
     * // Get one MemberCredentials
     * const memberCredentials = await prisma.memberCredentials.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MemberCredentialsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MemberCredentialsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MemberCredentials'> extends True ? CheckSelect<T, Prisma__MemberCredentialsClient<MemberCredentials>, Prisma__MemberCredentialsClient<MemberCredentialsGetPayload<T>>> : CheckSelect<T, Prisma__MemberCredentialsClient<MemberCredentials | null >, Prisma__MemberCredentialsClient<MemberCredentialsGetPayload<T> | null >>

    /**
     * Find zero or more MemberCredentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCredentialsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MemberCredentials
     * const memberCredentials = await prisma.memberCredentials.findMany()
     * 
     * // Get first 10 MemberCredentials
     * const memberCredentials = await prisma.memberCredentials.findMany({ take: 10 })
     * 
     * // Only select the `username`
     * const memberCredentialsWithUsernameOnly = await prisma.memberCredentials.findMany({ select: { username: true } })
     * 
    **/
    findMany<T extends MemberCredentialsFindManyArgs>(
      args?: SelectSubset<T, MemberCredentialsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<MemberCredentials>>, PrismaPromise<Array<MemberCredentialsGetPayload<T>>>>

    /**
     * Create a MemberCredentials.
     * @param {MemberCredentialsCreateArgs} args - Arguments to create a MemberCredentials.
     * @example
     * // Create one MemberCredentials
     * const MemberCredentials = await prisma.memberCredentials.create({
     *   data: {
     *     // ... data to create a MemberCredentials
     *   }
     * })
     * 
    **/
    create<T extends MemberCredentialsCreateArgs>(
      args: SelectSubset<T, MemberCredentialsCreateArgs>
    ): CheckSelect<T, Prisma__MemberCredentialsClient<MemberCredentials>, Prisma__MemberCredentialsClient<MemberCredentialsGetPayload<T>>>

    /**
     * Create many MemberCredentials.
     *     @param {MemberCredentialsCreateManyArgs} args - Arguments to create many MemberCredentials.
     *     @example
     *     // Create many MemberCredentials
     *     const memberCredentials = await prisma.memberCredentials.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MemberCredentialsCreateManyArgs>(
      args?: SelectSubset<T, MemberCredentialsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MemberCredentials.
     * @param {MemberCredentialsDeleteArgs} args - Arguments to delete one MemberCredentials.
     * @example
     * // Delete one MemberCredentials
     * const MemberCredentials = await prisma.memberCredentials.delete({
     *   where: {
     *     // ... filter to delete one MemberCredentials
     *   }
     * })
     * 
    **/
    delete<T extends MemberCredentialsDeleteArgs>(
      args: SelectSubset<T, MemberCredentialsDeleteArgs>
    ): CheckSelect<T, Prisma__MemberCredentialsClient<MemberCredentials>, Prisma__MemberCredentialsClient<MemberCredentialsGetPayload<T>>>

    /**
     * Update one MemberCredentials.
     * @param {MemberCredentialsUpdateArgs} args - Arguments to update one MemberCredentials.
     * @example
     * // Update one MemberCredentials
     * const memberCredentials = await prisma.memberCredentials.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MemberCredentialsUpdateArgs>(
      args: SelectSubset<T, MemberCredentialsUpdateArgs>
    ): CheckSelect<T, Prisma__MemberCredentialsClient<MemberCredentials>, Prisma__MemberCredentialsClient<MemberCredentialsGetPayload<T>>>

    /**
     * Delete zero or more MemberCredentials.
     * @param {MemberCredentialsDeleteManyArgs} args - Arguments to filter MemberCredentials to delete.
     * @example
     * // Delete a few MemberCredentials
     * const { count } = await prisma.memberCredentials.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MemberCredentialsDeleteManyArgs>(
      args?: SelectSubset<T, MemberCredentialsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCredentialsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MemberCredentials
     * const memberCredentials = await prisma.memberCredentials.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MemberCredentialsUpdateManyArgs>(
      args: SelectSubset<T, MemberCredentialsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MemberCredentials.
     * @param {MemberCredentialsUpsertArgs} args - Arguments to update or create a MemberCredentials.
     * @example
     * // Update or create a MemberCredentials
     * const memberCredentials = await prisma.memberCredentials.upsert({
     *   create: {
     *     // ... data to create a MemberCredentials
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MemberCredentials we want to update
     *   }
     * })
    **/
    upsert<T extends MemberCredentialsUpsertArgs>(
      args: SelectSubset<T, MemberCredentialsUpsertArgs>
    ): CheckSelect<T, Prisma__MemberCredentialsClient<MemberCredentials>, Prisma__MemberCredentialsClient<MemberCredentialsGetPayload<T>>>

    /**
     * Count the number of MemberCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCredentialsCountArgs} args - Arguments to filter MemberCredentials to count.
     * @example
     * // Count the number of MemberCredentials
     * const count = await prisma.memberCredentials.count({
     *   where: {
     *     // ... the filter for the MemberCredentials we want to count
     *   }
     * })
    **/
    count<T extends MemberCredentialsCountArgs>(
      args?: Subset<T, MemberCredentialsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberCredentialsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MemberCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCredentialsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberCredentialsAggregateArgs>(args: Subset<T, MemberCredentialsAggregateArgs>): PrismaPromise<GetMemberCredentialsAggregateType<T>>

    /**
     * Group by MemberCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCredentialsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberCredentialsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberCredentialsGroupByArgs['orderBy'] }
        : { orderBy?: MemberCredentialsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberCredentialsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberCredentialsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for MemberCredentials.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MemberCredentialsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    member<T extends MemberArgs = {}>(args?: Subset<T, MemberArgs>): CheckSelect<T, Prisma__MemberClient<Member | null >, Prisma__MemberClient<MemberGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * MemberCredentials findUnique
   */
  export type MemberCredentialsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the MemberCredentials
     * 
    **/
    select?: MemberCredentialsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MemberCredentialsInclude | null
    /**
     * Throw an Error if a MemberCredentials can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MemberCredentials to fetch.
     * 
    **/
    where: MemberCredentialsWhereUniqueInput
  }


  /**
   * MemberCredentials findFirst
   */
  export type MemberCredentialsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the MemberCredentials
     * 
    **/
    select?: MemberCredentialsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MemberCredentialsInclude | null
    /**
     * Throw an Error if a MemberCredentials can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MemberCredentials to fetch.
     * 
    **/
    where?: MemberCredentialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberCredentials to fetch.
     * 
    **/
    orderBy?: Enumerable<MemberCredentialsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberCredentials.
     * 
    **/
    cursor?: MemberCredentialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberCredentials from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberCredentials.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberCredentials.
     * 
    **/
    distinct?: Enumerable<MemberCredentialsScalarFieldEnum>
  }


  /**
   * MemberCredentials findMany
   */
  export type MemberCredentialsFindManyArgs = {
    /**
     * Select specific fields to fetch from the MemberCredentials
     * 
    **/
    select?: MemberCredentialsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MemberCredentialsInclude | null
    /**
     * Filter, which MemberCredentials to fetch.
     * 
    **/
    where?: MemberCredentialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberCredentials to fetch.
     * 
    **/
    orderBy?: Enumerable<MemberCredentialsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MemberCredentials.
     * 
    **/
    cursor?: MemberCredentialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberCredentials from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberCredentials.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MemberCredentialsScalarFieldEnum>
  }


  /**
   * MemberCredentials create
   */
  export type MemberCredentialsCreateArgs = {
    /**
     * Select specific fields to fetch from the MemberCredentials
     * 
    **/
    select?: MemberCredentialsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MemberCredentialsInclude | null
    /**
     * The data needed to create a MemberCredentials.
     * 
    **/
    data: XOR<MemberCredentialsCreateInput, MemberCredentialsUncheckedCreateInput>
  }


  /**
   * MemberCredentials createMany
   */
  export type MemberCredentialsCreateManyArgs = {
    /**
     * The data used to create many MemberCredentials.
     * 
    **/
    data: Enumerable<MemberCredentialsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MemberCredentials update
   */
  export type MemberCredentialsUpdateArgs = {
    /**
     * Select specific fields to fetch from the MemberCredentials
     * 
    **/
    select?: MemberCredentialsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MemberCredentialsInclude | null
    /**
     * The data needed to update a MemberCredentials.
     * 
    **/
    data: XOR<MemberCredentialsUpdateInput, MemberCredentialsUncheckedUpdateInput>
    /**
     * Choose, which MemberCredentials to update.
     * 
    **/
    where: MemberCredentialsWhereUniqueInput
  }


  /**
   * MemberCredentials updateMany
   */
  export type MemberCredentialsUpdateManyArgs = {
    /**
     * The data used to update MemberCredentials.
     * 
    **/
    data: XOR<MemberCredentialsUpdateManyMutationInput, MemberCredentialsUncheckedUpdateManyInput>
    /**
     * Filter which MemberCredentials to update
     * 
    **/
    where?: MemberCredentialsWhereInput
  }


  /**
   * MemberCredentials upsert
   */
  export type MemberCredentialsUpsertArgs = {
    /**
     * Select specific fields to fetch from the MemberCredentials
     * 
    **/
    select?: MemberCredentialsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MemberCredentialsInclude | null
    /**
     * The filter to search for the MemberCredentials to update in case it exists.
     * 
    **/
    where: MemberCredentialsWhereUniqueInput
    /**
     * In case the MemberCredentials found by the `where` argument doesn't exist, create a new MemberCredentials with this data.
     * 
    **/
    create: XOR<MemberCredentialsCreateInput, MemberCredentialsUncheckedCreateInput>
    /**
     * In case the MemberCredentials was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MemberCredentialsUpdateInput, MemberCredentialsUncheckedUpdateInput>
  }


  /**
   * MemberCredentials delete
   */
  export type MemberCredentialsDeleteArgs = {
    /**
     * Select specific fields to fetch from the MemberCredentials
     * 
    **/
    select?: MemberCredentialsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MemberCredentialsInclude | null
    /**
     * Filter which MemberCredentials to delete.
     * 
    **/
    where: MemberCredentialsWhereUniqueInput
  }


  /**
   * MemberCredentials deleteMany
   */
  export type MemberCredentialsDeleteManyArgs = {
    /**
     * Filter which MemberCredentials to delete
     * 
    **/
    where?: MemberCredentialsWhereInput
  }


  /**
   * MemberCredentials without action
   */
  export type MemberCredentialsArgs = {
    /**
     * Select specific fields to fetch from the MemberCredentials
     * 
    **/
    select?: MemberCredentialsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MemberCredentialsInclude | null
  }



  /**
   * Model Message
   */


  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageAvgAggregateOutputType = {
    id: number | null
    timestamp: number | null
  }

  export type MessageSumAggregateOutputType = {
    id: number | null
    timestamp: number | null
  }

  export type MessageMinAggregateOutputType = {
    id: number | null
    timestamp: number | null
    isRead: boolean | null
    messageType: MessageType | null
  }

  export type MessageMaxAggregateOutputType = {
    id: number | null
    timestamp: number | null
    isRead: boolean | null
    messageType: MessageType | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    timestamp: number
    isRead: number
    messageType: number
    _all: number
  }


  export type MessageAvgAggregateInputType = {
    id?: true
    timestamp?: true
  }

  export type MessageSumAggregateInputType = {
    id?: true
    timestamp?: true
  }

  export type MessageMinAggregateInputType = {
    id?: true
    timestamp?: true
    isRead?: true
    messageType?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    timestamp?: true
    isRead?: true
    messageType?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    timestamp?: true
    isRead?: true
    messageType?: true
    _all?: true
  }

  export type MessageAggregateArgs = {
    /**
     * Filter which Message to aggregate.
     * 
    **/
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     * 
    **/
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs = {
    where?: MessageWhereInput
    orderBy?: Enumerable<MessageOrderByWithAggregationInput>
    by: Array<MessageScalarFieldEnum>
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _avg?: MessageAvgAggregateInputType
    _sum?: MessageSumAggregateInputType
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }


  export type MessageGroupByOutputType = {
    id: number
    timestamp: number
    isRead: boolean
    messageType: MessageType
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect = {
    id?: boolean
    timestamp?: boolean
    isRead?: boolean
    messageType?: boolean
    recipients?: boolean | MessageRecipientsFindManyArgs
    _count?: boolean | MessageCountOutputTypeArgs
  }

  export type MessageInclude = {
    recipients?: boolean | MessageRecipientsFindManyArgs
    _count?: boolean | MessageCountOutputTypeArgs
  }

  export type MessageGetPayload<
    S extends boolean | null | undefined | MessageArgs,
    U = keyof S
      > = S extends true
        ? Message
    : S extends undefined
    ? never
    : S extends MessageArgs | MessageFindManyArgs
    ?'include' extends U
    ? Message  & {
    [P in TrueKeys<S['include']>]:
        P extends 'recipients' ? Array < MessageRecipientsGetPayload<S['include'][P]>>  :
        P extends '_count' ? MessageCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'recipients' ? Array < MessageRecipientsGetPayload<S['select'][P]>>  :
        P extends '_count' ? MessageCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Message ? Message[P] : never
  } 
    : Message
  : Message


  type MessageCountArgs = Merge<
    Omit<MessageFindManyArgs, 'select' | 'include'> & {
      select?: MessageCountAggregateInputType | true
    }
  >

  export interface MessageDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MessageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MessageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Message'> extends True ? CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>> : CheckSelect<T, Prisma__MessageClient<Message | null >, Prisma__MessageClient<MessageGetPayload<T> | null >>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MessageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MessageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Message'> extends True ? CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>> : CheckSelect<T, Prisma__MessageClient<Message | null >, Prisma__MessageClient<MessageGetPayload<T> | null >>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MessageFindManyArgs>(
      args?: SelectSubset<T, MessageFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Message>>, PrismaPromise<Array<MessageGetPayload<T>>>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
    **/
    create<T extends MessageCreateArgs>(
      args: SelectSubset<T, MessageCreateArgs>
    ): CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>>

    /**
     * Create many Messages.
     *     @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     *     @example
     *     // Create many Messages
     *     const message = await prisma.message.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MessageCreateManyArgs>(
      args?: SelectSubset<T, MessageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
    **/
    delete<T extends MessageDeleteArgs>(
      args: SelectSubset<T, MessageDeleteArgs>
    ): CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MessageUpdateArgs>(
      args: SelectSubset<T, MessageUpdateArgs>
    ): CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MessageDeleteManyArgs>(
      args?: SelectSubset<T, MessageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MessageUpdateManyArgs>(
      args: SelectSubset<T, MessageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
    **/
    upsert<T extends MessageUpsertArgs>(
      args: SelectSubset<T, MessageUpsertArgs>
    ): CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>>

    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MessageClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    recipients<T extends MessageRecipientsFindManyArgs = {}>(args?: Subset<T, MessageRecipientsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<MessageRecipients>>, PrismaPromise<Array<MessageRecipientsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * Throw an Error if a Message can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Message to fetch.
     * 
    **/
    where: MessageWhereUniqueInput
  }


  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * Throw an Error if a Message can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Message to fetch.
     * 
    **/
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     * 
    **/
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     * 
    **/
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     * 
    **/
    distinct?: Enumerable<MessageScalarFieldEnum>
  }


  /**
   * Message findMany
   */
  export type MessageFindManyArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * Filter, which Messages to fetch.
     * 
    **/
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     * 
    **/
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     * 
    **/
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MessageScalarFieldEnum>
  }


  /**
   * Message create
   */
  export type MessageCreateArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * The data needed to create a Message.
     * 
    **/
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }


  /**
   * Message createMany
   */
  export type MessageCreateManyArgs = {
    /**
     * The data used to create many Messages.
     * 
    **/
    data: Enumerable<MessageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Message update
   */
  export type MessageUpdateArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * The data needed to update a Message.
     * 
    **/
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     * 
    **/
    where: MessageWhereUniqueInput
  }


  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs = {
    /**
     * The data used to update Messages.
     * 
    **/
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     * 
    **/
    where?: MessageWhereInput
  }


  /**
   * Message upsert
   */
  export type MessageUpsertArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * The filter to search for the Message to update in case it exists.
     * 
    **/
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     * 
    **/
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }


  /**
   * Message delete
   */
  export type MessageDeleteArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * Filter which Message to delete.
     * 
    **/
    where: MessageWhereUniqueInput
  }


  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs = {
    /**
     * Filter which Messages to delete
     * 
    **/
    where?: MessageWhereInput
  }


  /**
   * Message without action
   */
  export type MessageArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
  }



  /**
   * Model MessageRecipients
   */


  export type AggregateMessageRecipients = {
    _count: MessageRecipientsCountAggregateOutputType | null
    _avg: MessageRecipientsAvgAggregateOutputType | null
    _sum: MessageRecipientsSumAggregateOutputType | null
    _min: MessageRecipientsMinAggregateOutputType | null
    _max: MessageRecipientsMaxAggregateOutputType | null
  }

  export type MessageRecipientsAvgAggregateOutputType = {
    messageId: number | null
  }

  export type MessageRecipientsSumAggregateOutputType = {
    messageId: number | null
  }

  export type MessageRecipientsMinAggregateOutputType = {
    messageId: number | null
    username: string | null
  }

  export type MessageRecipientsMaxAggregateOutputType = {
    messageId: number | null
    username: string | null
  }

  export type MessageRecipientsCountAggregateOutputType = {
    messageId: number
    username: number
    _all: number
  }


  export type MessageRecipientsAvgAggregateInputType = {
    messageId?: true
  }

  export type MessageRecipientsSumAggregateInputType = {
    messageId?: true
  }

  export type MessageRecipientsMinAggregateInputType = {
    messageId?: true
    username?: true
  }

  export type MessageRecipientsMaxAggregateInputType = {
    messageId?: true
    username?: true
  }

  export type MessageRecipientsCountAggregateInputType = {
    messageId?: true
    username?: true
    _all?: true
  }

  export type MessageRecipientsAggregateArgs = {
    /**
     * Filter which MessageRecipients to aggregate.
     * 
    **/
    where?: MessageRecipientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageRecipients to fetch.
     * 
    **/
    orderBy?: Enumerable<MessageRecipientsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MessageRecipientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageRecipients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageRecipients.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageRecipients
    **/
    _count?: true | MessageRecipientsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageRecipientsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageRecipientsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageRecipientsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageRecipientsMaxAggregateInputType
  }

  export type GetMessageRecipientsAggregateType<T extends MessageRecipientsAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageRecipients]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageRecipients[P]>
      : GetScalarType<T[P], AggregateMessageRecipients[P]>
  }




  export type MessageRecipientsGroupByArgs = {
    where?: MessageRecipientsWhereInput
    orderBy?: Enumerable<MessageRecipientsOrderByWithAggregationInput>
    by: Array<MessageRecipientsScalarFieldEnum>
    having?: MessageRecipientsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageRecipientsCountAggregateInputType | true
    _avg?: MessageRecipientsAvgAggregateInputType
    _sum?: MessageRecipientsSumAggregateInputType
    _min?: MessageRecipientsMinAggregateInputType
    _max?: MessageRecipientsMaxAggregateInputType
  }


  export type MessageRecipientsGroupByOutputType = {
    messageId: number
    username: string
    _count: MessageRecipientsCountAggregateOutputType | null
    _avg: MessageRecipientsAvgAggregateOutputType | null
    _sum: MessageRecipientsSumAggregateOutputType | null
    _min: MessageRecipientsMinAggregateOutputType | null
    _max: MessageRecipientsMaxAggregateOutputType | null
  }

  type GetMessageRecipientsGroupByPayload<T extends MessageRecipientsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MessageRecipientsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageRecipientsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageRecipientsGroupByOutputType[P]>
            : GetScalarType<T[P], MessageRecipientsGroupByOutputType[P]>
        }
      >
    >


  export type MessageRecipientsSelect = {
    message?: boolean | MessageArgs
    messageId?: boolean
    member?: boolean | MemberArgs
    username?: boolean
  }

  export type MessageRecipientsInclude = {
    message?: boolean | MessageArgs
    member?: boolean | MemberArgs
  }

  export type MessageRecipientsGetPayload<
    S extends boolean | null | undefined | MessageRecipientsArgs,
    U = keyof S
      > = S extends true
        ? MessageRecipients
    : S extends undefined
    ? never
    : S extends MessageRecipientsArgs | MessageRecipientsFindManyArgs
    ?'include' extends U
    ? MessageRecipients  & {
    [P in TrueKeys<S['include']>]:
        P extends 'message' ? MessageGetPayload<S['include'][P]> :
        P extends 'member' ? MemberGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'message' ? MessageGetPayload<S['select'][P]> :
        P extends 'member' ? MemberGetPayload<S['select'][P]> :  P extends keyof MessageRecipients ? MessageRecipients[P] : never
  } 
    : MessageRecipients
  : MessageRecipients


  type MessageRecipientsCountArgs = Merge<
    Omit<MessageRecipientsFindManyArgs, 'select' | 'include'> & {
      select?: MessageRecipientsCountAggregateInputType | true
    }
  >

  export interface MessageRecipientsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one MessageRecipients that matches the filter.
     * @param {MessageRecipientsFindUniqueArgs} args - Arguments to find a MessageRecipients
     * @example
     * // Get one MessageRecipients
     * const messageRecipients = await prisma.messageRecipients.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MessageRecipientsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MessageRecipientsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MessageRecipients'> extends True ? CheckSelect<T, Prisma__MessageRecipientsClient<MessageRecipients>, Prisma__MessageRecipientsClient<MessageRecipientsGetPayload<T>>> : CheckSelect<T, Prisma__MessageRecipientsClient<MessageRecipients | null >, Prisma__MessageRecipientsClient<MessageRecipientsGetPayload<T> | null >>

    /**
     * Find the first MessageRecipients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageRecipientsFindFirstArgs} args - Arguments to find a MessageRecipients
     * @example
     * // Get one MessageRecipients
     * const messageRecipients = await prisma.messageRecipients.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MessageRecipientsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MessageRecipientsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MessageRecipients'> extends True ? CheckSelect<T, Prisma__MessageRecipientsClient<MessageRecipients>, Prisma__MessageRecipientsClient<MessageRecipientsGetPayload<T>>> : CheckSelect<T, Prisma__MessageRecipientsClient<MessageRecipients | null >, Prisma__MessageRecipientsClient<MessageRecipientsGetPayload<T> | null >>

    /**
     * Find zero or more MessageRecipients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageRecipientsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageRecipients
     * const messageRecipients = await prisma.messageRecipients.findMany()
     * 
     * // Get first 10 MessageRecipients
     * const messageRecipients = await prisma.messageRecipients.findMany({ take: 10 })
     * 
     * // Only select the `messageId`
     * const messageRecipientsWithMessageIdOnly = await prisma.messageRecipients.findMany({ select: { messageId: true } })
     * 
    **/
    findMany<T extends MessageRecipientsFindManyArgs>(
      args?: SelectSubset<T, MessageRecipientsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<MessageRecipients>>, PrismaPromise<Array<MessageRecipientsGetPayload<T>>>>

    /**
     * Create a MessageRecipients.
     * @param {MessageRecipientsCreateArgs} args - Arguments to create a MessageRecipients.
     * @example
     * // Create one MessageRecipients
     * const MessageRecipients = await prisma.messageRecipients.create({
     *   data: {
     *     // ... data to create a MessageRecipients
     *   }
     * })
     * 
    **/
    create<T extends MessageRecipientsCreateArgs>(
      args: SelectSubset<T, MessageRecipientsCreateArgs>
    ): CheckSelect<T, Prisma__MessageRecipientsClient<MessageRecipients>, Prisma__MessageRecipientsClient<MessageRecipientsGetPayload<T>>>

    /**
     * Create many MessageRecipients.
     *     @param {MessageRecipientsCreateManyArgs} args - Arguments to create many MessageRecipients.
     *     @example
     *     // Create many MessageRecipients
     *     const messageRecipients = await prisma.messageRecipients.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MessageRecipientsCreateManyArgs>(
      args?: SelectSubset<T, MessageRecipientsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MessageRecipients.
     * @param {MessageRecipientsDeleteArgs} args - Arguments to delete one MessageRecipients.
     * @example
     * // Delete one MessageRecipients
     * const MessageRecipients = await prisma.messageRecipients.delete({
     *   where: {
     *     // ... filter to delete one MessageRecipients
     *   }
     * })
     * 
    **/
    delete<T extends MessageRecipientsDeleteArgs>(
      args: SelectSubset<T, MessageRecipientsDeleteArgs>
    ): CheckSelect<T, Prisma__MessageRecipientsClient<MessageRecipients>, Prisma__MessageRecipientsClient<MessageRecipientsGetPayload<T>>>

    /**
     * Update one MessageRecipients.
     * @param {MessageRecipientsUpdateArgs} args - Arguments to update one MessageRecipients.
     * @example
     * // Update one MessageRecipients
     * const messageRecipients = await prisma.messageRecipients.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MessageRecipientsUpdateArgs>(
      args: SelectSubset<T, MessageRecipientsUpdateArgs>
    ): CheckSelect<T, Prisma__MessageRecipientsClient<MessageRecipients>, Prisma__MessageRecipientsClient<MessageRecipientsGetPayload<T>>>

    /**
     * Delete zero or more MessageRecipients.
     * @param {MessageRecipientsDeleteManyArgs} args - Arguments to filter MessageRecipients to delete.
     * @example
     * // Delete a few MessageRecipients
     * const { count } = await prisma.messageRecipients.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MessageRecipientsDeleteManyArgs>(
      args?: SelectSubset<T, MessageRecipientsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageRecipients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageRecipientsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageRecipients
     * const messageRecipients = await prisma.messageRecipients.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MessageRecipientsUpdateManyArgs>(
      args: SelectSubset<T, MessageRecipientsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MessageRecipients.
     * @param {MessageRecipientsUpsertArgs} args - Arguments to update or create a MessageRecipients.
     * @example
     * // Update or create a MessageRecipients
     * const messageRecipients = await prisma.messageRecipients.upsert({
     *   create: {
     *     // ... data to create a MessageRecipients
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageRecipients we want to update
     *   }
     * })
    **/
    upsert<T extends MessageRecipientsUpsertArgs>(
      args: SelectSubset<T, MessageRecipientsUpsertArgs>
    ): CheckSelect<T, Prisma__MessageRecipientsClient<MessageRecipients>, Prisma__MessageRecipientsClient<MessageRecipientsGetPayload<T>>>

    /**
     * Count the number of MessageRecipients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageRecipientsCountArgs} args - Arguments to filter MessageRecipients to count.
     * @example
     * // Count the number of MessageRecipients
     * const count = await prisma.messageRecipients.count({
     *   where: {
     *     // ... the filter for the MessageRecipients we want to count
     *   }
     * })
    **/
    count<T extends MessageRecipientsCountArgs>(
      args?: Subset<T, MessageRecipientsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageRecipientsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageRecipients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageRecipientsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageRecipientsAggregateArgs>(args: Subset<T, MessageRecipientsAggregateArgs>): PrismaPromise<GetMessageRecipientsAggregateType<T>>

    /**
     * Group by MessageRecipients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageRecipientsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageRecipientsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageRecipientsGroupByArgs['orderBy'] }
        : { orderBy?: MessageRecipientsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageRecipientsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageRecipientsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageRecipients.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MessageRecipientsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    message<T extends MessageArgs = {}>(args?: Subset<T, MessageArgs>): CheckSelect<T, Prisma__MessageClient<Message | null >, Prisma__MessageClient<MessageGetPayload<T> | null >>;

    member<T extends MemberArgs = {}>(args?: Subset<T, MemberArgs>): CheckSelect<T, Prisma__MemberClient<Member | null >, Prisma__MemberClient<MemberGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * MessageRecipients findUnique
   */
  export type MessageRecipientsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the MessageRecipients
     * 
    **/
    select?: MessageRecipientsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageRecipientsInclude | null
    /**
     * Throw an Error if a MessageRecipients can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MessageRecipients to fetch.
     * 
    **/
    where: MessageRecipientsWhereUniqueInput
  }


  /**
   * MessageRecipients findFirst
   */
  export type MessageRecipientsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the MessageRecipients
     * 
    **/
    select?: MessageRecipientsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageRecipientsInclude | null
    /**
     * Throw an Error if a MessageRecipients can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MessageRecipients to fetch.
     * 
    **/
    where?: MessageRecipientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageRecipients to fetch.
     * 
    **/
    orderBy?: Enumerable<MessageRecipientsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageRecipients.
     * 
    **/
    cursor?: MessageRecipientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageRecipients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageRecipients.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageRecipients.
     * 
    **/
    distinct?: Enumerable<MessageRecipientsScalarFieldEnum>
  }


  /**
   * MessageRecipients findMany
   */
  export type MessageRecipientsFindManyArgs = {
    /**
     * Select specific fields to fetch from the MessageRecipients
     * 
    **/
    select?: MessageRecipientsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageRecipientsInclude | null
    /**
     * Filter, which MessageRecipients to fetch.
     * 
    **/
    where?: MessageRecipientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageRecipients to fetch.
     * 
    **/
    orderBy?: Enumerable<MessageRecipientsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageRecipients.
     * 
    **/
    cursor?: MessageRecipientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageRecipients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageRecipients.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MessageRecipientsScalarFieldEnum>
  }


  /**
   * MessageRecipients create
   */
  export type MessageRecipientsCreateArgs = {
    /**
     * Select specific fields to fetch from the MessageRecipients
     * 
    **/
    select?: MessageRecipientsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageRecipientsInclude | null
    /**
     * The data needed to create a MessageRecipients.
     * 
    **/
    data: XOR<MessageRecipientsCreateInput, MessageRecipientsUncheckedCreateInput>
  }


  /**
   * MessageRecipients createMany
   */
  export type MessageRecipientsCreateManyArgs = {
    /**
     * The data used to create many MessageRecipients.
     * 
    **/
    data: Enumerable<MessageRecipientsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MessageRecipients update
   */
  export type MessageRecipientsUpdateArgs = {
    /**
     * Select specific fields to fetch from the MessageRecipients
     * 
    **/
    select?: MessageRecipientsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageRecipientsInclude | null
    /**
     * The data needed to update a MessageRecipients.
     * 
    **/
    data: XOR<MessageRecipientsUpdateInput, MessageRecipientsUncheckedUpdateInput>
    /**
     * Choose, which MessageRecipients to update.
     * 
    **/
    where: MessageRecipientsWhereUniqueInput
  }


  /**
   * MessageRecipients updateMany
   */
  export type MessageRecipientsUpdateManyArgs = {
    /**
     * The data used to update MessageRecipients.
     * 
    **/
    data: XOR<MessageRecipientsUpdateManyMutationInput, MessageRecipientsUncheckedUpdateManyInput>
    /**
     * Filter which MessageRecipients to update
     * 
    **/
    where?: MessageRecipientsWhereInput
  }


  /**
   * MessageRecipients upsert
   */
  export type MessageRecipientsUpsertArgs = {
    /**
     * Select specific fields to fetch from the MessageRecipients
     * 
    **/
    select?: MessageRecipientsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageRecipientsInclude | null
    /**
     * The filter to search for the MessageRecipients to update in case it exists.
     * 
    **/
    where: MessageRecipientsWhereUniqueInput
    /**
     * In case the MessageRecipients found by the `where` argument doesn't exist, create a new MessageRecipients with this data.
     * 
    **/
    create: XOR<MessageRecipientsCreateInput, MessageRecipientsUncheckedCreateInput>
    /**
     * In case the MessageRecipients was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MessageRecipientsUpdateInput, MessageRecipientsUncheckedUpdateInput>
  }


  /**
   * MessageRecipients delete
   */
  export type MessageRecipientsDeleteArgs = {
    /**
     * Select specific fields to fetch from the MessageRecipients
     * 
    **/
    select?: MessageRecipientsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageRecipientsInclude | null
    /**
     * Filter which MessageRecipients to delete.
     * 
    **/
    where: MessageRecipientsWhereUniqueInput
  }


  /**
   * MessageRecipients deleteMany
   */
  export type MessageRecipientsDeleteManyArgs = {
    /**
     * Filter which MessageRecipients to delete
     * 
    **/
    where?: MessageRecipientsWhereInput
  }


  /**
   * MessageRecipients without action
   */
  export type MessageRecipientsArgs = {
    /**
     * Select specific fields to fetch from the MessageRecipients
     * 
    **/
    select?: MessageRecipientsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageRecipientsInclude | null
  }



  /**
   * Model Discount
   */


  export type AggregateDiscount = {
    _count: DiscountCountAggregateOutputType | null
    _avg: DiscountAvgAggregateOutputType | null
    _sum: DiscountSumAggregateOutputType | null
    _min: DiscountMinAggregateOutputType | null
    _max: DiscountMaxAggregateOutputType | null
  }

  export type DiscountAvgAggregateOutputType = {
    id: number | null
    shopId: number | null
  }

  export type DiscountSumAggregateOutputType = {
    id: number | null
    shopId: number | null
  }

  export type DiscountMinAggregateOutputType = {
    id: number | null
    shopId: number | null
    kind: DiscountKinds | null
  }

  export type DiscountMaxAggregateOutputType = {
    id: number | null
    shopId: number | null
    kind: DiscountKinds | null
  }

  export type DiscountCountAggregateOutputType = {
    id: number
    shopId: number
    kind: number
    _all: number
  }


  export type DiscountAvgAggregateInputType = {
    id?: true
    shopId?: true
  }

  export type DiscountSumAggregateInputType = {
    id?: true
    shopId?: true
  }

  export type DiscountMinAggregateInputType = {
    id?: true
    shopId?: true
    kind?: true
  }

  export type DiscountMaxAggregateInputType = {
    id?: true
    shopId?: true
    kind?: true
  }

  export type DiscountCountAggregateInputType = {
    id?: true
    shopId?: true
    kind?: true
    _all?: true
  }

  export type DiscountAggregateArgs = {
    /**
     * Filter which Discount to aggregate.
     * 
    **/
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     * 
    **/
    orderBy?: Enumerable<DiscountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Discounts
    **/
    _count?: true | DiscountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiscountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiscountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiscountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiscountMaxAggregateInputType
  }

  export type GetDiscountAggregateType<T extends DiscountAggregateArgs> = {
        [P in keyof T & keyof AggregateDiscount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiscount[P]>
      : GetScalarType<T[P], AggregateDiscount[P]>
  }




  export type DiscountGroupByArgs = {
    where?: DiscountWhereInput
    orderBy?: Enumerable<DiscountOrderByWithAggregationInput>
    by: Array<DiscountScalarFieldEnum>
    having?: DiscountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiscountCountAggregateInputType | true
    _avg?: DiscountAvgAggregateInputType
    _sum?: DiscountSumAggregateInputType
    _min?: DiscountMinAggregateInputType
    _max?: DiscountMaxAggregateInputType
  }


  export type DiscountGroupByOutputType = {
    id: number
    shopId: number
    kind: DiscountKinds
    _count: DiscountCountAggregateOutputType | null
    _avg: DiscountAvgAggregateOutputType | null
    _sum: DiscountSumAggregateOutputType | null
    _min: DiscountMinAggregateOutputType | null
    _max: DiscountMaxAggregateOutputType | null
  }

  type GetDiscountGroupByPayload<T extends DiscountGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DiscountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiscountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiscountGroupByOutputType[P]>
            : GetScalarType<T[P], DiscountGroupByOutputType[P]>
        }
      >
    >


  export type DiscountSelect = {
    id?: boolean
    shop?: boolean | ShopArgs
    shopId?: boolean
    kind?: boolean
    simpleDiscount?: boolean | SimpleDiscountArgs
    conditionalDiscount?: boolean | ConditionalDiscountArgs
    discountContainer?: boolean | DiscountContainerArgs
    discountInContainer?: boolean | DiscountInContainerArgs
  }

  export type DiscountInclude = {
    shop?: boolean | ShopArgs
    simpleDiscount?: boolean | SimpleDiscountArgs
    conditionalDiscount?: boolean | ConditionalDiscountArgs
    discountContainer?: boolean | DiscountContainerArgs
    discountInContainer?: boolean | DiscountInContainerArgs
  }

  export type DiscountGetPayload<
    S extends boolean | null | undefined | DiscountArgs,
    U = keyof S
      > = S extends true
        ? Discount
    : S extends undefined
    ? never
    : S extends DiscountArgs | DiscountFindManyArgs
    ?'include' extends U
    ? Discount  & {
    [P in TrueKeys<S['include']>]:
        P extends 'shop' ? ShopGetPayload<S['include'][P]> :
        P extends 'simpleDiscount' ? SimpleDiscountGetPayload<S['include'][P]> | null :
        P extends 'conditionalDiscount' ? ConditionalDiscountGetPayload<S['include'][P]> | null :
        P extends 'discountContainer' ? DiscountContainerGetPayload<S['include'][P]> | null :
        P extends 'discountInContainer' ? DiscountInContainerGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'shop' ? ShopGetPayload<S['select'][P]> :
        P extends 'simpleDiscount' ? SimpleDiscountGetPayload<S['select'][P]> | null :
        P extends 'conditionalDiscount' ? ConditionalDiscountGetPayload<S['select'][P]> | null :
        P extends 'discountContainer' ? DiscountContainerGetPayload<S['select'][P]> | null :
        P extends 'discountInContainer' ? DiscountInContainerGetPayload<S['select'][P]> | null :  P extends keyof Discount ? Discount[P] : never
  } 
    : Discount
  : Discount


  type DiscountCountArgs = Merge<
    Omit<DiscountFindManyArgs, 'select' | 'include'> & {
      select?: DiscountCountAggregateInputType | true
    }
  >

  export interface DiscountDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Discount that matches the filter.
     * @param {DiscountFindUniqueArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DiscountFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DiscountFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Discount'> extends True ? CheckSelect<T, Prisma__DiscountClient<Discount>, Prisma__DiscountClient<DiscountGetPayload<T>>> : CheckSelect<T, Prisma__DiscountClient<Discount | null >, Prisma__DiscountClient<DiscountGetPayload<T> | null >>

    /**
     * Find the first Discount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountFindFirstArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DiscountFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DiscountFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Discount'> extends True ? CheckSelect<T, Prisma__DiscountClient<Discount>, Prisma__DiscountClient<DiscountGetPayload<T>>> : CheckSelect<T, Prisma__DiscountClient<Discount | null >, Prisma__DiscountClient<DiscountGetPayload<T> | null >>

    /**
     * Find zero or more Discounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Discounts
     * const discounts = await prisma.discount.findMany()
     * 
     * // Get first 10 Discounts
     * const discounts = await prisma.discount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const discountWithIdOnly = await prisma.discount.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DiscountFindManyArgs>(
      args?: SelectSubset<T, DiscountFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Discount>>, PrismaPromise<Array<DiscountGetPayload<T>>>>

    /**
     * Create a Discount.
     * @param {DiscountCreateArgs} args - Arguments to create a Discount.
     * @example
     * // Create one Discount
     * const Discount = await prisma.discount.create({
     *   data: {
     *     // ... data to create a Discount
     *   }
     * })
     * 
    **/
    create<T extends DiscountCreateArgs>(
      args: SelectSubset<T, DiscountCreateArgs>
    ): CheckSelect<T, Prisma__DiscountClient<Discount>, Prisma__DiscountClient<DiscountGetPayload<T>>>

    /**
     * Create many Discounts.
     *     @param {DiscountCreateManyArgs} args - Arguments to create many Discounts.
     *     @example
     *     // Create many Discounts
     *     const discount = await prisma.discount.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DiscountCreateManyArgs>(
      args?: SelectSubset<T, DiscountCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Discount.
     * @param {DiscountDeleteArgs} args - Arguments to delete one Discount.
     * @example
     * // Delete one Discount
     * const Discount = await prisma.discount.delete({
     *   where: {
     *     // ... filter to delete one Discount
     *   }
     * })
     * 
    **/
    delete<T extends DiscountDeleteArgs>(
      args: SelectSubset<T, DiscountDeleteArgs>
    ): CheckSelect<T, Prisma__DiscountClient<Discount>, Prisma__DiscountClient<DiscountGetPayload<T>>>

    /**
     * Update one Discount.
     * @param {DiscountUpdateArgs} args - Arguments to update one Discount.
     * @example
     * // Update one Discount
     * const discount = await prisma.discount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DiscountUpdateArgs>(
      args: SelectSubset<T, DiscountUpdateArgs>
    ): CheckSelect<T, Prisma__DiscountClient<Discount>, Prisma__DiscountClient<DiscountGetPayload<T>>>

    /**
     * Delete zero or more Discounts.
     * @param {DiscountDeleteManyArgs} args - Arguments to filter Discounts to delete.
     * @example
     * // Delete a few Discounts
     * const { count } = await prisma.discount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DiscountDeleteManyArgs>(
      args?: SelectSubset<T, DiscountDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Discounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Discounts
     * const discount = await prisma.discount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DiscountUpdateManyArgs>(
      args: SelectSubset<T, DiscountUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Discount.
     * @param {DiscountUpsertArgs} args - Arguments to update or create a Discount.
     * @example
     * // Update or create a Discount
     * const discount = await prisma.discount.upsert({
     *   create: {
     *     // ... data to create a Discount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Discount we want to update
     *   }
     * })
    **/
    upsert<T extends DiscountUpsertArgs>(
      args: SelectSubset<T, DiscountUpsertArgs>
    ): CheckSelect<T, Prisma__DiscountClient<Discount>, Prisma__DiscountClient<DiscountGetPayload<T>>>

    /**
     * Count the number of Discounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountCountArgs} args - Arguments to filter Discounts to count.
     * @example
     * // Count the number of Discounts
     * const count = await prisma.discount.count({
     *   where: {
     *     // ... the filter for the Discounts we want to count
     *   }
     * })
    **/
    count<T extends DiscountCountArgs>(
      args?: Subset<T, DiscountCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiscountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Discount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiscountAggregateArgs>(args: Subset<T, DiscountAggregateArgs>): PrismaPromise<GetDiscountAggregateType<T>>

    /**
     * Group by Discount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiscountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiscountGroupByArgs['orderBy'] }
        : { orderBy?: DiscountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiscountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiscountGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Discount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DiscountClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    shop<T extends ShopArgs = {}>(args?: Subset<T, ShopArgs>): CheckSelect<T, Prisma__ShopClient<Shop | null >, Prisma__ShopClient<ShopGetPayload<T> | null >>;

    simpleDiscount<T extends SimpleDiscountArgs = {}>(args?: Subset<T, SimpleDiscountArgs>): CheckSelect<T, Prisma__SimpleDiscountClient<SimpleDiscount | null >, Prisma__SimpleDiscountClient<SimpleDiscountGetPayload<T> | null >>;

    conditionalDiscount<T extends ConditionalDiscountArgs = {}>(args?: Subset<T, ConditionalDiscountArgs>): CheckSelect<T, Prisma__ConditionalDiscountClient<ConditionalDiscount | null >, Prisma__ConditionalDiscountClient<ConditionalDiscountGetPayload<T> | null >>;

    discountContainer<T extends DiscountContainerArgs = {}>(args?: Subset<T, DiscountContainerArgs>): CheckSelect<T, Prisma__DiscountContainerClient<DiscountContainer | null >, Prisma__DiscountContainerClient<DiscountContainerGetPayload<T> | null >>;

    discountInContainer<T extends DiscountInContainerArgs = {}>(args?: Subset<T, DiscountInContainerArgs>): CheckSelect<T, Prisma__DiscountInContainerClient<DiscountInContainer | null >, Prisma__DiscountInContainerClient<DiscountInContainerGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Discount findUnique
   */
  export type DiscountFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Discount
     * 
    **/
    select?: DiscountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountInclude | null
    /**
     * Throw an Error if a Discount can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Discount to fetch.
     * 
    **/
    where: DiscountWhereUniqueInput
  }


  /**
   * Discount findFirst
   */
  export type DiscountFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Discount
     * 
    **/
    select?: DiscountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountInclude | null
    /**
     * Throw an Error if a Discount can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Discount to fetch.
     * 
    **/
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     * 
    **/
    orderBy?: Enumerable<DiscountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Discounts.
     * 
    **/
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Discounts.
     * 
    **/
    distinct?: Enumerable<DiscountScalarFieldEnum>
  }


  /**
   * Discount findMany
   */
  export type DiscountFindManyArgs = {
    /**
     * Select specific fields to fetch from the Discount
     * 
    **/
    select?: DiscountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountInclude | null
    /**
     * Filter, which Discounts to fetch.
     * 
    **/
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     * 
    **/
    orderBy?: Enumerable<DiscountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Discounts.
     * 
    **/
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DiscountScalarFieldEnum>
  }


  /**
   * Discount create
   */
  export type DiscountCreateArgs = {
    /**
     * Select specific fields to fetch from the Discount
     * 
    **/
    select?: DiscountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountInclude | null
    /**
     * The data needed to create a Discount.
     * 
    **/
    data: XOR<DiscountCreateInput, DiscountUncheckedCreateInput>
  }


  /**
   * Discount createMany
   */
  export type DiscountCreateManyArgs = {
    /**
     * The data used to create many Discounts.
     * 
    **/
    data: Enumerable<DiscountCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Discount update
   */
  export type DiscountUpdateArgs = {
    /**
     * Select specific fields to fetch from the Discount
     * 
    **/
    select?: DiscountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountInclude | null
    /**
     * The data needed to update a Discount.
     * 
    **/
    data: XOR<DiscountUpdateInput, DiscountUncheckedUpdateInput>
    /**
     * Choose, which Discount to update.
     * 
    **/
    where: DiscountWhereUniqueInput
  }


  /**
   * Discount updateMany
   */
  export type DiscountUpdateManyArgs = {
    /**
     * The data used to update Discounts.
     * 
    **/
    data: XOR<DiscountUpdateManyMutationInput, DiscountUncheckedUpdateManyInput>
    /**
     * Filter which Discounts to update
     * 
    **/
    where?: DiscountWhereInput
  }


  /**
   * Discount upsert
   */
  export type DiscountUpsertArgs = {
    /**
     * Select specific fields to fetch from the Discount
     * 
    **/
    select?: DiscountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountInclude | null
    /**
     * The filter to search for the Discount to update in case it exists.
     * 
    **/
    where: DiscountWhereUniqueInput
    /**
     * In case the Discount found by the `where` argument doesn't exist, create a new Discount with this data.
     * 
    **/
    create: XOR<DiscountCreateInput, DiscountUncheckedCreateInput>
    /**
     * In case the Discount was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DiscountUpdateInput, DiscountUncheckedUpdateInput>
  }


  /**
   * Discount delete
   */
  export type DiscountDeleteArgs = {
    /**
     * Select specific fields to fetch from the Discount
     * 
    **/
    select?: DiscountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountInclude | null
    /**
     * Filter which Discount to delete.
     * 
    **/
    where: DiscountWhereUniqueInput
  }


  /**
   * Discount deleteMany
   */
  export type DiscountDeleteManyArgs = {
    /**
     * Filter which Discounts to delete
     * 
    **/
    where?: DiscountWhereInput
  }


  /**
   * Discount without action
   */
  export type DiscountArgs = {
    /**
     * Select specific fields to fetch from the Discount
     * 
    **/
    select?: DiscountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountInclude | null
  }



  /**
   * Model SimpleDiscount
   */


  export type AggregateSimpleDiscount = {
    _count: SimpleDiscountCountAggregateOutputType | null
    _avg: SimpleDiscountAvgAggregateOutputType | null
    _sum: SimpleDiscountSumAggregateOutputType | null
    _min: SimpleDiscountMinAggregateOutputType | null
    _max: SimpleDiscountMaxAggregateOutputType | null
  }

  export type SimpleDiscountAvgAggregateOutputType = {
    id: number | null
    shopId: number | null
    discountPercent: number | null
    productId: number | null
  }

  export type SimpleDiscountSumAggregateOutputType = {
    id: number | null
    shopId: number | null
    discountPercent: number | null
    productId: number | null
  }

  export type SimpleDiscountMinAggregateOutputType = {
    id: number | null
    shopId: number | null
    discountType: DiscountType | null
    discountPercent: number | null
    description: string | null
    productId: number | null
    category: ProductCategory | null
  }

  export type SimpleDiscountMaxAggregateOutputType = {
    id: number | null
    shopId: number | null
    discountType: DiscountType | null
    discountPercent: number | null
    description: string | null
    productId: number | null
    category: ProductCategory | null
  }

  export type SimpleDiscountCountAggregateOutputType = {
    id: number
    shopId: number
    discountType: number
    discountPercent: number
    description: number
    productId: number
    category: number
    _all: number
  }


  export type SimpleDiscountAvgAggregateInputType = {
    id?: true
    shopId?: true
    discountPercent?: true
    productId?: true
  }

  export type SimpleDiscountSumAggregateInputType = {
    id?: true
    shopId?: true
    discountPercent?: true
    productId?: true
  }

  export type SimpleDiscountMinAggregateInputType = {
    id?: true
    shopId?: true
    discountType?: true
    discountPercent?: true
    description?: true
    productId?: true
    category?: true
  }

  export type SimpleDiscountMaxAggregateInputType = {
    id?: true
    shopId?: true
    discountType?: true
    discountPercent?: true
    description?: true
    productId?: true
    category?: true
  }

  export type SimpleDiscountCountAggregateInputType = {
    id?: true
    shopId?: true
    discountType?: true
    discountPercent?: true
    description?: true
    productId?: true
    category?: true
    _all?: true
  }

  export type SimpleDiscountAggregateArgs = {
    /**
     * Filter which SimpleDiscount to aggregate.
     * 
    **/
    where?: SimpleDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimpleDiscounts to fetch.
     * 
    **/
    orderBy?: Enumerable<SimpleDiscountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SimpleDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimpleDiscounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimpleDiscounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SimpleDiscounts
    **/
    _count?: true | SimpleDiscountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SimpleDiscountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SimpleDiscountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SimpleDiscountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SimpleDiscountMaxAggregateInputType
  }

  export type GetSimpleDiscountAggregateType<T extends SimpleDiscountAggregateArgs> = {
        [P in keyof T & keyof AggregateSimpleDiscount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSimpleDiscount[P]>
      : GetScalarType<T[P], AggregateSimpleDiscount[P]>
  }




  export type SimpleDiscountGroupByArgs = {
    where?: SimpleDiscountWhereInput
    orderBy?: Enumerable<SimpleDiscountOrderByWithAggregationInput>
    by: Array<SimpleDiscountScalarFieldEnum>
    having?: SimpleDiscountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SimpleDiscountCountAggregateInputType | true
    _avg?: SimpleDiscountAvgAggregateInputType
    _sum?: SimpleDiscountSumAggregateInputType
    _min?: SimpleDiscountMinAggregateInputType
    _max?: SimpleDiscountMaxAggregateInputType
  }


  export type SimpleDiscountGroupByOutputType = {
    id: number
    shopId: number
    discountType: DiscountType
    discountPercent: number
    description: string
    productId: number | null
    category: ProductCategory | null
    _count: SimpleDiscountCountAggregateOutputType | null
    _avg: SimpleDiscountAvgAggregateOutputType | null
    _sum: SimpleDiscountSumAggregateOutputType | null
    _min: SimpleDiscountMinAggregateOutputType | null
    _max: SimpleDiscountMaxAggregateOutputType | null
  }

  type GetSimpleDiscountGroupByPayload<T extends SimpleDiscountGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SimpleDiscountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SimpleDiscountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SimpleDiscountGroupByOutputType[P]>
            : GetScalarType<T[P], SimpleDiscountGroupByOutputType[P]>
        }
      >
    >


  export type SimpleDiscountSelect = {
    discount?: boolean | DiscountArgs
    id?: boolean
    shopId?: boolean
    discountType?: boolean
    discountPercent?: boolean
    description?: boolean
    productId?: boolean
    category?: boolean
    conditionalDiscount?: boolean | ConditionalDiscountArgs
  }

  export type SimpleDiscountInclude = {
    discount?: boolean | DiscountArgs
    conditionalDiscount?: boolean | ConditionalDiscountArgs
  }

  export type SimpleDiscountGetPayload<
    S extends boolean | null | undefined | SimpleDiscountArgs,
    U = keyof S
      > = S extends true
        ? SimpleDiscount
    : S extends undefined
    ? never
    : S extends SimpleDiscountArgs | SimpleDiscountFindManyArgs
    ?'include' extends U
    ? SimpleDiscount  & {
    [P in TrueKeys<S['include']>]:
        P extends 'discount' ? DiscountGetPayload<S['include'][P]> :
        P extends 'conditionalDiscount' ? ConditionalDiscountGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'discount' ? DiscountGetPayload<S['select'][P]> :
        P extends 'conditionalDiscount' ? ConditionalDiscountGetPayload<S['select'][P]> | null :  P extends keyof SimpleDiscount ? SimpleDiscount[P] : never
  } 
    : SimpleDiscount
  : SimpleDiscount


  type SimpleDiscountCountArgs = Merge<
    Omit<SimpleDiscountFindManyArgs, 'select' | 'include'> & {
      select?: SimpleDiscountCountAggregateInputType | true
    }
  >

  export interface SimpleDiscountDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one SimpleDiscount that matches the filter.
     * @param {SimpleDiscountFindUniqueArgs} args - Arguments to find a SimpleDiscount
     * @example
     * // Get one SimpleDiscount
     * const simpleDiscount = await prisma.simpleDiscount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SimpleDiscountFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SimpleDiscountFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SimpleDiscount'> extends True ? CheckSelect<T, Prisma__SimpleDiscountClient<SimpleDiscount>, Prisma__SimpleDiscountClient<SimpleDiscountGetPayload<T>>> : CheckSelect<T, Prisma__SimpleDiscountClient<SimpleDiscount | null >, Prisma__SimpleDiscountClient<SimpleDiscountGetPayload<T> | null >>

    /**
     * Find the first SimpleDiscount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimpleDiscountFindFirstArgs} args - Arguments to find a SimpleDiscount
     * @example
     * // Get one SimpleDiscount
     * const simpleDiscount = await prisma.simpleDiscount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SimpleDiscountFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SimpleDiscountFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SimpleDiscount'> extends True ? CheckSelect<T, Prisma__SimpleDiscountClient<SimpleDiscount>, Prisma__SimpleDiscountClient<SimpleDiscountGetPayload<T>>> : CheckSelect<T, Prisma__SimpleDiscountClient<SimpleDiscount | null >, Prisma__SimpleDiscountClient<SimpleDiscountGetPayload<T> | null >>

    /**
     * Find zero or more SimpleDiscounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimpleDiscountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SimpleDiscounts
     * const simpleDiscounts = await prisma.simpleDiscount.findMany()
     * 
     * // Get first 10 SimpleDiscounts
     * const simpleDiscounts = await prisma.simpleDiscount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const simpleDiscountWithIdOnly = await prisma.simpleDiscount.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SimpleDiscountFindManyArgs>(
      args?: SelectSubset<T, SimpleDiscountFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SimpleDiscount>>, PrismaPromise<Array<SimpleDiscountGetPayload<T>>>>

    /**
     * Create a SimpleDiscount.
     * @param {SimpleDiscountCreateArgs} args - Arguments to create a SimpleDiscount.
     * @example
     * // Create one SimpleDiscount
     * const SimpleDiscount = await prisma.simpleDiscount.create({
     *   data: {
     *     // ... data to create a SimpleDiscount
     *   }
     * })
     * 
    **/
    create<T extends SimpleDiscountCreateArgs>(
      args: SelectSubset<T, SimpleDiscountCreateArgs>
    ): CheckSelect<T, Prisma__SimpleDiscountClient<SimpleDiscount>, Prisma__SimpleDiscountClient<SimpleDiscountGetPayload<T>>>

    /**
     * Create many SimpleDiscounts.
     *     @param {SimpleDiscountCreateManyArgs} args - Arguments to create many SimpleDiscounts.
     *     @example
     *     // Create many SimpleDiscounts
     *     const simpleDiscount = await prisma.simpleDiscount.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SimpleDiscountCreateManyArgs>(
      args?: SelectSubset<T, SimpleDiscountCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SimpleDiscount.
     * @param {SimpleDiscountDeleteArgs} args - Arguments to delete one SimpleDiscount.
     * @example
     * // Delete one SimpleDiscount
     * const SimpleDiscount = await prisma.simpleDiscount.delete({
     *   where: {
     *     // ... filter to delete one SimpleDiscount
     *   }
     * })
     * 
    **/
    delete<T extends SimpleDiscountDeleteArgs>(
      args: SelectSubset<T, SimpleDiscountDeleteArgs>
    ): CheckSelect<T, Prisma__SimpleDiscountClient<SimpleDiscount>, Prisma__SimpleDiscountClient<SimpleDiscountGetPayload<T>>>

    /**
     * Update one SimpleDiscount.
     * @param {SimpleDiscountUpdateArgs} args - Arguments to update one SimpleDiscount.
     * @example
     * // Update one SimpleDiscount
     * const simpleDiscount = await prisma.simpleDiscount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SimpleDiscountUpdateArgs>(
      args: SelectSubset<T, SimpleDiscountUpdateArgs>
    ): CheckSelect<T, Prisma__SimpleDiscountClient<SimpleDiscount>, Prisma__SimpleDiscountClient<SimpleDiscountGetPayload<T>>>

    /**
     * Delete zero or more SimpleDiscounts.
     * @param {SimpleDiscountDeleteManyArgs} args - Arguments to filter SimpleDiscounts to delete.
     * @example
     * // Delete a few SimpleDiscounts
     * const { count } = await prisma.simpleDiscount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SimpleDiscountDeleteManyArgs>(
      args?: SelectSubset<T, SimpleDiscountDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SimpleDiscounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimpleDiscountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SimpleDiscounts
     * const simpleDiscount = await prisma.simpleDiscount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SimpleDiscountUpdateManyArgs>(
      args: SelectSubset<T, SimpleDiscountUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SimpleDiscount.
     * @param {SimpleDiscountUpsertArgs} args - Arguments to update or create a SimpleDiscount.
     * @example
     * // Update or create a SimpleDiscount
     * const simpleDiscount = await prisma.simpleDiscount.upsert({
     *   create: {
     *     // ... data to create a SimpleDiscount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SimpleDiscount we want to update
     *   }
     * })
    **/
    upsert<T extends SimpleDiscountUpsertArgs>(
      args: SelectSubset<T, SimpleDiscountUpsertArgs>
    ): CheckSelect<T, Prisma__SimpleDiscountClient<SimpleDiscount>, Prisma__SimpleDiscountClient<SimpleDiscountGetPayload<T>>>

    /**
     * Count the number of SimpleDiscounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimpleDiscountCountArgs} args - Arguments to filter SimpleDiscounts to count.
     * @example
     * // Count the number of SimpleDiscounts
     * const count = await prisma.simpleDiscount.count({
     *   where: {
     *     // ... the filter for the SimpleDiscounts we want to count
     *   }
     * })
    **/
    count<T extends SimpleDiscountCountArgs>(
      args?: Subset<T, SimpleDiscountCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SimpleDiscountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SimpleDiscount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimpleDiscountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SimpleDiscountAggregateArgs>(args: Subset<T, SimpleDiscountAggregateArgs>): PrismaPromise<GetSimpleDiscountAggregateType<T>>

    /**
     * Group by SimpleDiscount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimpleDiscountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SimpleDiscountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SimpleDiscountGroupByArgs['orderBy'] }
        : { orderBy?: SimpleDiscountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SimpleDiscountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSimpleDiscountGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for SimpleDiscount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SimpleDiscountClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    discount<T extends DiscountArgs = {}>(args?: Subset<T, DiscountArgs>): CheckSelect<T, Prisma__DiscountClient<Discount | null >, Prisma__DiscountClient<DiscountGetPayload<T> | null >>;

    conditionalDiscount<T extends ConditionalDiscountArgs = {}>(args?: Subset<T, ConditionalDiscountArgs>): CheckSelect<T, Prisma__ConditionalDiscountClient<ConditionalDiscount | null >, Prisma__ConditionalDiscountClient<ConditionalDiscountGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * SimpleDiscount findUnique
   */
  export type SimpleDiscountFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the SimpleDiscount
     * 
    **/
    select?: SimpleDiscountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SimpleDiscountInclude | null
    /**
     * Throw an Error if a SimpleDiscount can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SimpleDiscount to fetch.
     * 
    **/
    where: SimpleDiscountWhereUniqueInput
  }


  /**
   * SimpleDiscount findFirst
   */
  export type SimpleDiscountFindFirstArgs = {
    /**
     * Select specific fields to fetch from the SimpleDiscount
     * 
    **/
    select?: SimpleDiscountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SimpleDiscountInclude | null
    /**
     * Throw an Error if a SimpleDiscount can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SimpleDiscount to fetch.
     * 
    **/
    where?: SimpleDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimpleDiscounts to fetch.
     * 
    **/
    orderBy?: Enumerable<SimpleDiscountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SimpleDiscounts.
     * 
    **/
    cursor?: SimpleDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimpleDiscounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimpleDiscounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SimpleDiscounts.
     * 
    **/
    distinct?: Enumerable<SimpleDiscountScalarFieldEnum>
  }


  /**
   * SimpleDiscount findMany
   */
  export type SimpleDiscountFindManyArgs = {
    /**
     * Select specific fields to fetch from the SimpleDiscount
     * 
    **/
    select?: SimpleDiscountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SimpleDiscountInclude | null
    /**
     * Filter, which SimpleDiscounts to fetch.
     * 
    **/
    where?: SimpleDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimpleDiscounts to fetch.
     * 
    **/
    orderBy?: Enumerable<SimpleDiscountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SimpleDiscounts.
     * 
    **/
    cursor?: SimpleDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimpleDiscounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimpleDiscounts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SimpleDiscountScalarFieldEnum>
  }


  /**
   * SimpleDiscount create
   */
  export type SimpleDiscountCreateArgs = {
    /**
     * Select specific fields to fetch from the SimpleDiscount
     * 
    **/
    select?: SimpleDiscountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SimpleDiscountInclude | null
    /**
     * The data needed to create a SimpleDiscount.
     * 
    **/
    data: XOR<SimpleDiscountCreateInput, SimpleDiscountUncheckedCreateInput>
  }


  /**
   * SimpleDiscount createMany
   */
  export type SimpleDiscountCreateManyArgs = {
    /**
     * The data used to create many SimpleDiscounts.
     * 
    **/
    data: Enumerable<SimpleDiscountCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SimpleDiscount update
   */
  export type SimpleDiscountUpdateArgs = {
    /**
     * Select specific fields to fetch from the SimpleDiscount
     * 
    **/
    select?: SimpleDiscountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SimpleDiscountInclude | null
    /**
     * The data needed to update a SimpleDiscount.
     * 
    **/
    data: XOR<SimpleDiscountUpdateInput, SimpleDiscountUncheckedUpdateInput>
    /**
     * Choose, which SimpleDiscount to update.
     * 
    **/
    where: SimpleDiscountWhereUniqueInput
  }


  /**
   * SimpleDiscount updateMany
   */
  export type SimpleDiscountUpdateManyArgs = {
    /**
     * The data used to update SimpleDiscounts.
     * 
    **/
    data: XOR<SimpleDiscountUpdateManyMutationInput, SimpleDiscountUncheckedUpdateManyInput>
    /**
     * Filter which SimpleDiscounts to update
     * 
    **/
    where?: SimpleDiscountWhereInput
  }


  /**
   * SimpleDiscount upsert
   */
  export type SimpleDiscountUpsertArgs = {
    /**
     * Select specific fields to fetch from the SimpleDiscount
     * 
    **/
    select?: SimpleDiscountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SimpleDiscountInclude | null
    /**
     * The filter to search for the SimpleDiscount to update in case it exists.
     * 
    **/
    where: SimpleDiscountWhereUniqueInput
    /**
     * In case the SimpleDiscount found by the `where` argument doesn't exist, create a new SimpleDiscount with this data.
     * 
    **/
    create: XOR<SimpleDiscountCreateInput, SimpleDiscountUncheckedCreateInput>
    /**
     * In case the SimpleDiscount was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SimpleDiscountUpdateInput, SimpleDiscountUncheckedUpdateInput>
  }


  /**
   * SimpleDiscount delete
   */
  export type SimpleDiscountDeleteArgs = {
    /**
     * Select specific fields to fetch from the SimpleDiscount
     * 
    **/
    select?: SimpleDiscountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SimpleDiscountInclude | null
    /**
     * Filter which SimpleDiscount to delete.
     * 
    **/
    where: SimpleDiscountWhereUniqueInput
  }


  /**
   * SimpleDiscount deleteMany
   */
  export type SimpleDiscountDeleteManyArgs = {
    /**
     * Filter which SimpleDiscounts to delete
     * 
    **/
    where?: SimpleDiscountWhereInput
  }


  /**
   * SimpleDiscount without action
   */
  export type SimpleDiscountArgs = {
    /**
     * Select specific fields to fetch from the SimpleDiscount
     * 
    **/
    select?: SimpleDiscountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SimpleDiscountInclude | null
  }



  /**
   * Model ConditionalDiscount
   */


  export type AggregateConditionalDiscount = {
    _count: ConditionalDiscountCountAggregateOutputType | null
    _avg: ConditionalDiscountAvgAggregateOutputType | null
    _sum: ConditionalDiscountSumAggregateOutputType | null
    _min: ConditionalDiscountMinAggregateOutputType | null
    _max: ConditionalDiscountMaxAggregateOutputType | null
  }

  export type ConditionalDiscountAvgAggregateOutputType = {
    id: number | null
    shopId: number | null
    simpleId: number | null
    simpleShopId: number | null
  }

  export type ConditionalDiscountSumAggregateOutputType = {
    id: number | null
    shopId: number | null
    simpleId: number | null
    simpleShopId: number | null
  }

  export type ConditionalDiscountMinAggregateOutputType = {
    id: number | null
    shopId: number | null
    simpleId: number | null
    simpleShopId: number | null
  }

  export type ConditionalDiscountMaxAggregateOutputType = {
    id: number | null
    shopId: number | null
    simpleId: number | null
    simpleShopId: number | null
  }

  export type ConditionalDiscountCountAggregateOutputType = {
    id: number
    shopId: number
    simpleId: number
    simpleShopId: number
    _all: number
  }


  export type ConditionalDiscountAvgAggregateInputType = {
    id?: true
    shopId?: true
    simpleId?: true
    simpleShopId?: true
  }

  export type ConditionalDiscountSumAggregateInputType = {
    id?: true
    shopId?: true
    simpleId?: true
    simpleShopId?: true
  }

  export type ConditionalDiscountMinAggregateInputType = {
    id?: true
    shopId?: true
    simpleId?: true
    simpleShopId?: true
  }

  export type ConditionalDiscountMaxAggregateInputType = {
    id?: true
    shopId?: true
    simpleId?: true
    simpleShopId?: true
  }

  export type ConditionalDiscountCountAggregateInputType = {
    id?: true
    shopId?: true
    simpleId?: true
    simpleShopId?: true
    _all?: true
  }

  export type ConditionalDiscountAggregateArgs = {
    /**
     * Filter which ConditionalDiscount to aggregate.
     * 
    **/
    where?: ConditionalDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConditionalDiscounts to fetch.
     * 
    **/
    orderBy?: Enumerable<ConditionalDiscountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ConditionalDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConditionalDiscounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConditionalDiscounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConditionalDiscounts
    **/
    _count?: true | ConditionalDiscountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConditionalDiscountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConditionalDiscountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConditionalDiscountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConditionalDiscountMaxAggregateInputType
  }

  export type GetConditionalDiscountAggregateType<T extends ConditionalDiscountAggregateArgs> = {
        [P in keyof T & keyof AggregateConditionalDiscount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConditionalDiscount[P]>
      : GetScalarType<T[P], AggregateConditionalDiscount[P]>
  }




  export type ConditionalDiscountGroupByArgs = {
    where?: ConditionalDiscountWhereInput
    orderBy?: Enumerable<ConditionalDiscountOrderByWithAggregationInput>
    by: Array<ConditionalDiscountScalarFieldEnum>
    having?: ConditionalDiscountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConditionalDiscountCountAggregateInputType | true
    _avg?: ConditionalDiscountAvgAggregateInputType
    _sum?: ConditionalDiscountSumAggregateInputType
    _min?: ConditionalDiscountMinAggregateInputType
    _max?: ConditionalDiscountMaxAggregateInputType
  }


  export type ConditionalDiscountGroupByOutputType = {
    id: number
    shopId: number
    simpleId: number
    simpleShopId: number
    _count: ConditionalDiscountCountAggregateOutputType | null
    _avg: ConditionalDiscountAvgAggregateOutputType | null
    _sum: ConditionalDiscountSumAggregateOutputType | null
    _min: ConditionalDiscountMinAggregateOutputType | null
    _max: ConditionalDiscountMaxAggregateOutputType | null
  }

  type GetConditionalDiscountGroupByPayload<T extends ConditionalDiscountGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ConditionalDiscountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConditionalDiscountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConditionalDiscountGroupByOutputType[P]>
            : GetScalarType<T[P], ConditionalDiscountGroupByOutputType[P]>
        }
      >
    >


  export type ConditionalDiscountSelect = {
    discount?: boolean | DiscountArgs
    id?: boolean
    shopId?: boolean
    simpleDiscount?: boolean | SimpleDiscountArgs
    simpleId?: boolean
    simpleShopId?: boolean
    discountPredicate?: boolean | DiscountPredicateArgs
  }

  export type ConditionalDiscountInclude = {
    discount?: boolean | DiscountArgs
    simpleDiscount?: boolean | SimpleDiscountArgs
    discountPredicate?: boolean | DiscountPredicateArgs
  }

  export type ConditionalDiscountGetPayload<
    S extends boolean | null | undefined | ConditionalDiscountArgs,
    U = keyof S
      > = S extends true
        ? ConditionalDiscount
    : S extends undefined
    ? never
    : S extends ConditionalDiscountArgs | ConditionalDiscountFindManyArgs
    ?'include' extends U
    ? ConditionalDiscount  & {
    [P in TrueKeys<S['include']>]:
        P extends 'discount' ? DiscountGetPayload<S['include'][P]> :
        P extends 'simpleDiscount' ? SimpleDiscountGetPayload<S['include'][P]> :
        P extends 'discountPredicate' ? DiscountPredicateGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'discount' ? DiscountGetPayload<S['select'][P]> :
        P extends 'simpleDiscount' ? SimpleDiscountGetPayload<S['select'][P]> :
        P extends 'discountPredicate' ? DiscountPredicateGetPayload<S['select'][P]> | null :  P extends keyof ConditionalDiscount ? ConditionalDiscount[P] : never
  } 
    : ConditionalDiscount
  : ConditionalDiscount


  type ConditionalDiscountCountArgs = Merge<
    Omit<ConditionalDiscountFindManyArgs, 'select' | 'include'> & {
      select?: ConditionalDiscountCountAggregateInputType | true
    }
  >

  export interface ConditionalDiscountDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ConditionalDiscount that matches the filter.
     * @param {ConditionalDiscountFindUniqueArgs} args - Arguments to find a ConditionalDiscount
     * @example
     * // Get one ConditionalDiscount
     * const conditionalDiscount = await prisma.conditionalDiscount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConditionalDiscountFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ConditionalDiscountFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ConditionalDiscount'> extends True ? CheckSelect<T, Prisma__ConditionalDiscountClient<ConditionalDiscount>, Prisma__ConditionalDiscountClient<ConditionalDiscountGetPayload<T>>> : CheckSelect<T, Prisma__ConditionalDiscountClient<ConditionalDiscount | null >, Prisma__ConditionalDiscountClient<ConditionalDiscountGetPayload<T> | null >>

    /**
     * Find the first ConditionalDiscount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionalDiscountFindFirstArgs} args - Arguments to find a ConditionalDiscount
     * @example
     * // Get one ConditionalDiscount
     * const conditionalDiscount = await prisma.conditionalDiscount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConditionalDiscountFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ConditionalDiscountFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ConditionalDiscount'> extends True ? CheckSelect<T, Prisma__ConditionalDiscountClient<ConditionalDiscount>, Prisma__ConditionalDiscountClient<ConditionalDiscountGetPayload<T>>> : CheckSelect<T, Prisma__ConditionalDiscountClient<ConditionalDiscount | null >, Prisma__ConditionalDiscountClient<ConditionalDiscountGetPayload<T> | null >>

    /**
     * Find zero or more ConditionalDiscounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionalDiscountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConditionalDiscounts
     * const conditionalDiscounts = await prisma.conditionalDiscount.findMany()
     * 
     * // Get first 10 ConditionalDiscounts
     * const conditionalDiscounts = await prisma.conditionalDiscount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conditionalDiscountWithIdOnly = await prisma.conditionalDiscount.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConditionalDiscountFindManyArgs>(
      args?: SelectSubset<T, ConditionalDiscountFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ConditionalDiscount>>, PrismaPromise<Array<ConditionalDiscountGetPayload<T>>>>

    /**
     * Create a ConditionalDiscount.
     * @param {ConditionalDiscountCreateArgs} args - Arguments to create a ConditionalDiscount.
     * @example
     * // Create one ConditionalDiscount
     * const ConditionalDiscount = await prisma.conditionalDiscount.create({
     *   data: {
     *     // ... data to create a ConditionalDiscount
     *   }
     * })
     * 
    **/
    create<T extends ConditionalDiscountCreateArgs>(
      args: SelectSubset<T, ConditionalDiscountCreateArgs>
    ): CheckSelect<T, Prisma__ConditionalDiscountClient<ConditionalDiscount>, Prisma__ConditionalDiscountClient<ConditionalDiscountGetPayload<T>>>

    /**
     * Create many ConditionalDiscounts.
     *     @param {ConditionalDiscountCreateManyArgs} args - Arguments to create many ConditionalDiscounts.
     *     @example
     *     // Create many ConditionalDiscounts
     *     const conditionalDiscount = await prisma.conditionalDiscount.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConditionalDiscountCreateManyArgs>(
      args?: SelectSubset<T, ConditionalDiscountCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ConditionalDiscount.
     * @param {ConditionalDiscountDeleteArgs} args - Arguments to delete one ConditionalDiscount.
     * @example
     * // Delete one ConditionalDiscount
     * const ConditionalDiscount = await prisma.conditionalDiscount.delete({
     *   where: {
     *     // ... filter to delete one ConditionalDiscount
     *   }
     * })
     * 
    **/
    delete<T extends ConditionalDiscountDeleteArgs>(
      args: SelectSubset<T, ConditionalDiscountDeleteArgs>
    ): CheckSelect<T, Prisma__ConditionalDiscountClient<ConditionalDiscount>, Prisma__ConditionalDiscountClient<ConditionalDiscountGetPayload<T>>>

    /**
     * Update one ConditionalDiscount.
     * @param {ConditionalDiscountUpdateArgs} args - Arguments to update one ConditionalDiscount.
     * @example
     * // Update one ConditionalDiscount
     * const conditionalDiscount = await prisma.conditionalDiscount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConditionalDiscountUpdateArgs>(
      args: SelectSubset<T, ConditionalDiscountUpdateArgs>
    ): CheckSelect<T, Prisma__ConditionalDiscountClient<ConditionalDiscount>, Prisma__ConditionalDiscountClient<ConditionalDiscountGetPayload<T>>>

    /**
     * Delete zero or more ConditionalDiscounts.
     * @param {ConditionalDiscountDeleteManyArgs} args - Arguments to filter ConditionalDiscounts to delete.
     * @example
     * // Delete a few ConditionalDiscounts
     * const { count } = await prisma.conditionalDiscount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConditionalDiscountDeleteManyArgs>(
      args?: SelectSubset<T, ConditionalDiscountDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConditionalDiscounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionalDiscountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConditionalDiscounts
     * const conditionalDiscount = await prisma.conditionalDiscount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConditionalDiscountUpdateManyArgs>(
      args: SelectSubset<T, ConditionalDiscountUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ConditionalDiscount.
     * @param {ConditionalDiscountUpsertArgs} args - Arguments to update or create a ConditionalDiscount.
     * @example
     * // Update or create a ConditionalDiscount
     * const conditionalDiscount = await prisma.conditionalDiscount.upsert({
     *   create: {
     *     // ... data to create a ConditionalDiscount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConditionalDiscount we want to update
     *   }
     * })
    **/
    upsert<T extends ConditionalDiscountUpsertArgs>(
      args: SelectSubset<T, ConditionalDiscountUpsertArgs>
    ): CheckSelect<T, Prisma__ConditionalDiscountClient<ConditionalDiscount>, Prisma__ConditionalDiscountClient<ConditionalDiscountGetPayload<T>>>

    /**
     * Count the number of ConditionalDiscounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionalDiscountCountArgs} args - Arguments to filter ConditionalDiscounts to count.
     * @example
     * // Count the number of ConditionalDiscounts
     * const count = await prisma.conditionalDiscount.count({
     *   where: {
     *     // ... the filter for the ConditionalDiscounts we want to count
     *   }
     * })
    **/
    count<T extends ConditionalDiscountCountArgs>(
      args?: Subset<T, ConditionalDiscountCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConditionalDiscountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConditionalDiscount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionalDiscountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConditionalDiscountAggregateArgs>(args: Subset<T, ConditionalDiscountAggregateArgs>): PrismaPromise<GetConditionalDiscountAggregateType<T>>

    /**
     * Group by ConditionalDiscount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionalDiscountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConditionalDiscountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConditionalDiscountGroupByArgs['orderBy'] }
        : { orderBy?: ConditionalDiscountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConditionalDiscountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConditionalDiscountGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConditionalDiscount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ConditionalDiscountClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    discount<T extends DiscountArgs = {}>(args?: Subset<T, DiscountArgs>): CheckSelect<T, Prisma__DiscountClient<Discount | null >, Prisma__DiscountClient<DiscountGetPayload<T> | null >>;

    simpleDiscount<T extends SimpleDiscountArgs = {}>(args?: Subset<T, SimpleDiscountArgs>): CheckSelect<T, Prisma__SimpleDiscountClient<SimpleDiscount | null >, Prisma__SimpleDiscountClient<SimpleDiscountGetPayload<T> | null >>;

    discountPredicate<T extends DiscountPredicateArgs = {}>(args?: Subset<T, DiscountPredicateArgs>): CheckSelect<T, Prisma__DiscountPredicateClient<DiscountPredicate | null >, Prisma__DiscountPredicateClient<DiscountPredicateGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ConditionalDiscount findUnique
   */
  export type ConditionalDiscountFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ConditionalDiscount
     * 
    **/
    select?: ConditionalDiscountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConditionalDiscountInclude | null
    /**
     * Throw an Error if a ConditionalDiscount can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ConditionalDiscount to fetch.
     * 
    **/
    where: ConditionalDiscountWhereUniqueInput
  }


  /**
   * ConditionalDiscount findFirst
   */
  export type ConditionalDiscountFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ConditionalDiscount
     * 
    **/
    select?: ConditionalDiscountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConditionalDiscountInclude | null
    /**
     * Throw an Error if a ConditionalDiscount can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ConditionalDiscount to fetch.
     * 
    **/
    where?: ConditionalDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConditionalDiscounts to fetch.
     * 
    **/
    orderBy?: Enumerable<ConditionalDiscountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConditionalDiscounts.
     * 
    **/
    cursor?: ConditionalDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConditionalDiscounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConditionalDiscounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConditionalDiscounts.
     * 
    **/
    distinct?: Enumerable<ConditionalDiscountScalarFieldEnum>
  }


  /**
   * ConditionalDiscount findMany
   */
  export type ConditionalDiscountFindManyArgs = {
    /**
     * Select specific fields to fetch from the ConditionalDiscount
     * 
    **/
    select?: ConditionalDiscountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConditionalDiscountInclude | null
    /**
     * Filter, which ConditionalDiscounts to fetch.
     * 
    **/
    where?: ConditionalDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConditionalDiscounts to fetch.
     * 
    **/
    orderBy?: Enumerable<ConditionalDiscountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConditionalDiscounts.
     * 
    **/
    cursor?: ConditionalDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConditionalDiscounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConditionalDiscounts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ConditionalDiscountScalarFieldEnum>
  }


  /**
   * ConditionalDiscount create
   */
  export type ConditionalDiscountCreateArgs = {
    /**
     * Select specific fields to fetch from the ConditionalDiscount
     * 
    **/
    select?: ConditionalDiscountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConditionalDiscountInclude | null
    /**
     * The data needed to create a ConditionalDiscount.
     * 
    **/
    data: XOR<ConditionalDiscountCreateInput, ConditionalDiscountUncheckedCreateInput>
  }


  /**
   * ConditionalDiscount createMany
   */
  export type ConditionalDiscountCreateManyArgs = {
    /**
     * The data used to create many ConditionalDiscounts.
     * 
    **/
    data: Enumerable<ConditionalDiscountCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ConditionalDiscount update
   */
  export type ConditionalDiscountUpdateArgs = {
    /**
     * Select specific fields to fetch from the ConditionalDiscount
     * 
    **/
    select?: ConditionalDiscountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConditionalDiscountInclude | null
    /**
     * The data needed to update a ConditionalDiscount.
     * 
    **/
    data: XOR<ConditionalDiscountUpdateInput, ConditionalDiscountUncheckedUpdateInput>
    /**
     * Choose, which ConditionalDiscount to update.
     * 
    **/
    where: ConditionalDiscountWhereUniqueInput
  }


  /**
   * ConditionalDiscount updateMany
   */
  export type ConditionalDiscountUpdateManyArgs = {
    /**
     * The data used to update ConditionalDiscounts.
     * 
    **/
    data: XOR<ConditionalDiscountUpdateManyMutationInput, ConditionalDiscountUncheckedUpdateManyInput>
    /**
     * Filter which ConditionalDiscounts to update
     * 
    **/
    where?: ConditionalDiscountWhereInput
  }


  /**
   * ConditionalDiscount upsert
   */
  export type ConditionalDiscountUpsertArgs = {
    /**
     * Select specific fields to fetch from the ConditionalDiscount
     * 
    **/
    select?: ConditionalDiscountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConditionalDiscountInclude | null
    /**
     * The filter to search for the ConditionalDiscount to update in case it exists.
     * 
    **/
    where: ConditionalDiscountWhereUniqueInput
    /**
     * In case the ConditionalDiscount found by the `where` argument doesn't exist, create a new ConditionalDiscount with this data.
     * 
    **/
    create: XOR<ConditionalDiscountCreateInput, ConditionalDiscountUncheckedCreateInput>
    /**
     * In case the ConditionalDiscount was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ConditionalDiscountUpdateInput, ConditionalDiscountUncheckedUpdateInput>
  }


  /**
   * ConditionalDiscount delete
   */
  export type ConditionalDiscountDeleteArgs = {
    /**
     * Select specific fields to fetch from the ConditionalDiscount
     * 
    **/
    select?: ConditionalDiscountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConditionalDiscountInclude | null
    /**
     * Filter which ConditionalDiscount to delete.
     * 
    **/
    where: ConditionalDiscountWhereUniqueInput
  }


  /**
   * ConditionalDiscount deleteMany
   */
  export type ConditionalDiscountDeleteManyArgs = {
    /**
     * Filter which ConditionalDiscounts to delete
     * 
    **/
    where?: ConditionalDiscountWhereInput
  }


  /**
   * ConditionalDiscount without action
   */
  export type ConditionalDiscountArgs = {
    /**
     * Select specific fields to fetch from the ConditionalDiscount
     * 
    **/
    select?: ConditionalDiscountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConditionalDiscountInclude | null
  }



  /**
   * Model DiscountPredicate
   */


  export type AggregateDiscountPredicate = {
    _count: DiscountPredicateCountAggregateOutputType | null
    _avg: DiscountPredicateAvgAggregateOutputType | null
    _sum: DiscountPredicateSumAggregateOutputType | null
    _min: DiscountPredicateMinAggregateOutputType | null
    _max: DiscountPredicateMaxAggregateOutputType | null
  }

  export type DiscountPredicateAvgAggregateOutputType = {
    discountId: number | null
    shopId: number | null
    value: number | null
    productId: number | null
  }

  export type DiscountPredicateSumAggregateOutputType = {
    discountId: number | null
    shopId: number | null
    value: number | null
    productId: number | null
  }

  export type DiscountPredicateMinAggregateOutputType = {
    discountId: number | null
    shopId: number | null
    discountType: DiscountType | null
    relation: RelationType | null
    value: number | null
    description: string | null
    productId: number | null
    category: ProductCategory | null
  }

  export type DiscountPredicateMaxAggregateOutputType = {
    discountId: number | null
    shopId: number | null
    discountType: DiscountType | null
    relation: RelationType | null
    value: number | null
    description: string | null
    productId: number | null
    category: ProductCategory | null
  }

  export type DiscountPredicateCountAggregateOutputType = {
    discountId: number
    shopId: number
    discountType: number
    relation: number
    value: number
    description: number
    productId: number
    category: number
    _all: number
  }


  export type DiscountPredicateAvgAggregateInputType = {
    discountId?: true
    shopId?: true
    value?: true
    productId?: true
  }

  export type DiscountPredicateSumAggregateInputType = {
    discountId?: true
    shopId?: true
    value?: true
    productId?: true
  }

  export type DiscountPredicateMinAggregateInputType = {
    discountId?: true
    shopId?: true
    discountType?: true
    relation?: true
    value?: true
    description?: true
    productId?: true
    category?: true
  }

  export type DiscountPredicateMaxAggregateInputType = {
    discountId?: true
    shopId?: true
    discountType?: true
    relation?: true
    value?: true
    description?: true
    productId?: true
    category?: true
  }

  export type DiscountPredicateCountAggregateInputType = {
    discountId?: true
    shopId?: true
    discountType?: true
    relation?: true
    value?: true
    description?: true
    productId?: true
    category?: true
    _all?: true
  }

  export type DiscountPredicateAggregateArgs = {
    /**
     * Filter which DiscountPredicate to aggregate.
     * 
    **/
    where?: DiscountPredicateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscountPredicates to fetch.
     * 
    **/
    orderBy?: Enumerable<DiscountPredicateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DiscountPredicateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscountPredicates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscountPredicates.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DiscountPredicates
    **/
    _count?: true | DiscountPredicateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiscountPredicateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiscountPredicateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiscountPredicateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiscountPredicateMaxAggregateInputType
  }

  export type GetDiscountPredicateAggregateType<T extends DiscountPredicateAggregateArgs> = {
        [P in keyof T & keyof AggregateDiscountPredicate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiscountPredicate[P]>
      : GetScalarType<T[P], AggregateDiscountPredicate[P]>
  }




  export type DiscountPredicateGroupByArgs = {
    where?: DiscountPredicateWhereInput
    orderBy?: Enumerable<DiscountPredicateOrderByWithAggregationInput>
    by: Array<DiscountPredicateScalarFieldEnum>
    having?: DiscountPredicateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiscountPredicateCountAggregateInputType | true
    _avg?: DiscountPredicateAvgAggregateInputType
    _sum?: DiscountPredicateSumAggregateInputType
    _min?: DiscountPredicateMinAggregateInputType
    _max?: DiscountPredicateMaxAggregateInputType
  }


  export type DiscountPredicateGroupByOutputType = {
    discountId: number
    shopId: number
    discountType: DiscountType
    relation: RelationType
    value: number
    description: string
    productId: number | null
    category: ProductCategory | null
    _count: DiscountPredicateCountAggregateOutputType | null
    _avg: DiscountPredicateAvgAggregateOutputType | null
    _sum: DiscountPredicateSumAggregateOutputType | null
    _min: DiscountPredicateMinAggregateOutputType | null
    _max: DiscountPredicateMaxAggregateOutputType | null
  }

  type GetDiscountPredicateGroupByPayload<T extends DiscountPredicateGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DiscountPredicateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiscountPredicateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiscountPredicateGroupByOutputType[P]>
            : GetScalarType<T[P], DiscountPredicateGroupByOutputType[P]>
        }
      >
    >


  export type DiscountPredicateSelect = {
    discount?: boolean | ConditionalDiscountArgs
    discountId?: boolean
    shopId?: boolean
    discountType?: boolean
    relation?: boolean
    value?: boolean
    description?: boolean
    productId?: boolean
    category?: boolean
  }

  export type DiscountPredicateInclude = {
    discount?: boolean | ConditionalDiscountArgs
  }

  export type DiscountPredicateGetPayload<
    S extends boolean | null | undefined | DiscountPredicateArgs,
    U = keyof S
      > = S extends true
        ? DiscountPredicate
    : S extends undefined
    ? never
    : S extends DiscountPredicateArgs | DiscountPredicateFindManyArgs
    ?'include' extends U
    ? DiscountPredicate  & {
    [P in TrueKeys<S['include']>]:
        P extends 'discount' ? ConditionalDiscountGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'discount' ? ConditionalDiscountGetPayload<S['select'][P]> :  P extends keyof DiscountPredicate ? DiscountPredicate[P] : never
  } 
    : DiscountPredicate
  : DiscountPredicate


  type DiscountPredicateCountArgs = Merge<
    Omit<DiscountPredicateFindManyArgs, 'select' | 'include'> & {
      select?: DiscountPredicateCountAggregateInputType | true
    }
  >

  export interface DiscountPredicateDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one DiscountPredicate that matches the filter.
     * @param {DiscountPredicateFindUniqueArgs} args - Arguments to find a DiscountPredicate
     * @example
     * // Get one DiscountPredicate
     * const discountPredicate = await prisma.discountPredicate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DiscountPredicateFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DiscountPredicateFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DiscountPredicate'> extends True ? CheckSelect<T, Prisma__DiscountPredicateClient<DiscountPredicate>, Prisma__DiscountPredicateClient<DiscountPredicateGetPayload<T>>> : CheckSelect<T, Prisma__DiscountPredicateClient<DiscountPredicate | null >, Prisma__DiscountPredicateClient<DiscountPredicateGetPayload<T> | null >>

    /**
     * Find the first DiscountPredicate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountPredicateFindFirstArgs} args - Arguments to find a DiscountPredicate
     * @example
     * // Get one DiscountPredicate
     * const discountPredicate = await prisma.discountPredicate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DiscountPredicateFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DiscountPredicateFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DiscountPredicate'> extends True ? CheckSelect<T, Prisma__DiscountPredicateClient<DiscountPredicate>, Prisma__DiscountPredicateClient<DiscountPredicateGetPayload<T>>> : CheckSelect<T, Prisma__DiscountPredicateClient<DiscountPredicate | null >, Prisma__DiscountPredicateClient<DiscountPredicateGetPayload<T> | null >>

    /**
     * Find zero or more DiscountPredicates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountPredicateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DiscountPredicates
     * const discountPredicates = await prisma.discountPredicate.findMany()
     * 
     * // Get first 10 DiscountPredicates
     * const discountPredicates = await prisma.discountPredicate.findMany({ take: 10 })
     * 
     * // Only select the `discountId`
     * const discountPredicateWithDiscountIdOnly = await prisma.discountPredicate.findMany({ select: { discountId: true } })
     * 
    **/
    findMany<T extends DiscountPredicateFindManyArgs>(
      args?: SelectSubset<T, DiscountPredicateFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<DiscountPredicate>>, PrismaPromise<Array<DiscountPredicateGetPayload<T>>>>

    /**
     * Create a DiscountPredicate.
     * @param {DiscountPredicateCreateArgs} args - Arguments to create a DiscountPredicate.
     * @example
     * // Create one DiscountPredicate
     * const DiscountPredicate = await prisma.discountPredicate.create({
     *   data: {
     *     // ... data to create a DiscountPredicate
     *   }
     * })
     * 
    **/
    create<T extends DiscountPredicateCreateArgs>(
      args: SelectSubset<T, DiscountPredicateCreateArgs>
    ): CheckSelect<T, Prisma__DiscountPredicateClient<DiscountPredicate>, Prisma__DiscountPredicateClient<DiscountPredicateGetPayload<T>>>

    /**
     * Create many DiscountPredicates.
     *     @param {DiscountPredicateCreateManyArgs} args - Arguments to create many DiscountPredicates.
     *     @example
     *     // Create many DiscountPredicates
     *     const discountPredicate = await prisma.discountPredicate.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DiscountPredicateCreateManyArgs>(
      args?: SelectSubset<T, DiscountPredicateCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DiscountPredicate.
     * @param {DiscountPredicateDeleteArgs} args - Arguments to delete one DiscountPredicate.
     * @example
     * // Delete one DiscountPredicate
     * const DiscountPredicate = await prisma.discountPredicate.delete({
     *   where: {
     *     // ... filter to delete one DiscountPredicate
     *   }
     * })
     * 
    **/
    delete<T extends DiscountPredicateDeleteArgs>(
      args: SelectSubset<T, DiscountPredicateDeleteArgs>
    ): CheckSelect<T, Prisma__DiscountPredicateClient<DiscountPredicate>, Prisma__DiscountPredicateClient<DiscountPredicateGetPayload<T>>>

    /**
     * Update one DiscountPredicate.
     * @param {DiscountPredicateUpdateArgs} args - Arguments to update one DiscountPredicate.
     * @example
     * // Update one DiscountPredicate
     * const discountPredicate = await prisma.discountPredicate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DiscountPredicateUpdateArgs>(
      args: SelectSubset<T, DiscountPredicateUpdateArgs>
    ): CheckSelect<T, Prisma__DiscountPredicateClient<DiscountPredicate>, Prisma__DiscountPredicateClient<DiscountPredicateGetPayload<T>>>

    /**
     * Delete zero or more DiscountPredicates.
     * @param {DiscountPredicateDeleteManyArgs} args - Arguments to filter DiscountPredicates to delete.
     * @example
     * // Delete a few DiscountPredicates
     * const { count } = await prisma.discountPredicate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DiscountPredicateDeleteManyArgs>(
      args?: SelectSubset<T, DiscountPredicateDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DiscountPredicates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountPredicateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DiscountPredicates
     * const discountPredicate = await prisma.discountPredicate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DiscountPredicateUpdateManyArgs>(
      args: SelectSubset<T, DiscountPredicateUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DiscountPredicate.
     * @param {DiscountPredicateUpsertArgs} args - Arguments to update or create a DiscountPredicate.
     * @example
     * // Update or create a DiscountPredicate
     * const discountPredicate = await prisma.discountPredicate.upsert({
     *   create: {
     *     // ... data to create a DiscountPredicate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DiscountPredicate we want to update
     *   }
     * })
    **/
    upsert<T extends DiscountPredicateUpsertArgs>(
      args: SelectSubset<T, DiscountPredicateUpsertArgs>
    ): CheckSelect<T, Prisma__DiscountPredicateClient<DiscountPredicate>, Prisma__DiscountPredicateClient<DiscountPredicateGetPayload<T>>>

    /**
     * Count the number of DiscountPredicates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountPredicateCountArgs} args - Arguments to filter DiscountPredicates to count.
     * @example
     * // Count the number of DiscountPredicates
     * const count = await prisma.discountPredicate.count({
     *   where: {
     *     // ... the filter for the DiscountPredicates we want to count
     *   }
     * })
    **/
    count<T extends DiscountPredicateCountArgs>(
      args?: Subset<T, DiscountPredicateCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiscountPredicateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DiscountPredicate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountPredicateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiscountPredicateAggregateArgs>(args: Subset<T, DiscountPredicateAggregateArgs>): PrismaPromise<GetDiscountPredicateAggregateType<T>>

    /**
     * Group by DiscountPredicate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountPredicateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiscountPredicateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiscountPredicateGroupByArgs['orderBy'] }
        : { orderBy?: DiscountPredicateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiscountPredicateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiscountPredicateGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for DiscountPredicate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DiscountPredicateClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    discount<T extends ConditionalDiscountArgs = {}>(args?: Subset<T, ConditionalDiscountArgs>): CheckSelect<T, Prisma__ConditionalDiscountClient<ConditionalDiscount | null >, Prisma__ConditionalDiscountClient<ConditionalDiscountGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * DiscountPredicate findUnique
   */
  export type DiscountPredicateFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the DiscountPredicate
     * 
    **/
    select?: DiscountPredicateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountPredicateInclude | null
    /**
     * Throw an Error if a DiscountPredicate can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DiscountPredicate to fetch.
     * 
    **/
    where: DiscountPredicateWhereUniqueInput
  }


  /**
   * DiscountPredicate findFirst
   */
  export type DiscountPredicateFindFirstArgs = {
    /**
     * Select specific fields to fetch from the DiscountPredicate
     * 
    **/
    select?: DiscountPredicateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountPredicateInclude | null
    /**
     * Throw an Error if a DiscountPredicate can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DiscountPredicate to fetch.
     * 
    **/
    where?: DiscountPredicateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscountPredicates to fetch.
     * 
    **/
    orderBy?: Enumerable<DiscountPredicateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiscountPredicates.
     * 
    **/
    cursor?: DiscountPredicateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscountPredicates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscountPredicates.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiscountPredicates.
     * 
    **/
    distinct?: Enumerable<DiscountPredicateScalarFieldEnum>
  }


  /**
   * DiscountPredicate findMany
   */
  export type DiscountPredicateFindManyArgs = {
    /**
     * Select specific fields to fetch from the DiscountPredicate
     * 
    **/
    select?: DiscountPredicateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountPredicateInclude | null
    /**
     * Filter, which DiscountPredicates to fetch.
     * 
    **/
    where?: DiscountPredicateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscountPredicates to fetch.
     * 
    **/
    orderBy?: Enumerable<DiscountPredicateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DiscountPredicates.
     * 
    **/
    cursor?: DiscountPredicateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscountPredicates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscountPredicates.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DiscountPredicateScalarFieldEnum>
  }


  /**
   * DiscountPredicate create
   */
  export type DiscountPredicateCreateArgs = {
    /**
     * Select specific fields to fetch from the DiscountPredicate
     * 
    **/
    select?: DiscountPredicateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountPredicateInclude | null
    /**
     * The data needed to create a DiscountPredicate.
     * 
    **/
    data: XOR<DiscountPredicateCreateInput, DiscountPredicateUncheckedCreateInput>
  }


  /**
   * DiscountPredicate createMany
   */
  export type DiscountPredicateCreateManyArgs = {
    /**
     * The data used to create many DiscountPredicates.
     * 
    **/
    data: Enumerable<DiscountPredicateCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DiscountPredicate update
   */
  export type DiscountPredicateUpdateArgs = {
    /**
     * Select specific fields to fetch from the DiscountPredicate
     * 
    **/
    select?: DiscountPredicateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountPredicateInclude | null
    /**
     * The data needed to update a DiscountPredicate.
     * 
    **/
    data: XOR<DiscountPredicateUpdateInput, DiscountPredicateUncheckedUpdateInput>
    /**
     * Choose, which DiscountPredicate to update.
     * 
    **/
    where: DiscountPredicateWhereUniqueInput
  }


  /**
   * DiscountPredicate updateMany
   */
  export type DiscountPredicateUpdateManyArgs = {
    /**
     * The data used to update DiscountPredicates.
     * 
    **/
    data: XOR<DiscountPredicateUpdateManyMutationInput, DiscountPredicateUncheckedUpdateManyInput>
    /**
     * Filter which DiscountPredicates to update
     * 
    **/
    where?: DiscountPredicateWhereInput
  }


  /**
   * DiscountPredicate upsert
   */
  export type DiscountPredicateUpsertArgs = {
    /**
     * Select specific fields to fetch from the DiscountPredicate
     * 
    **/
    select?: DiscountPredicateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountPredicateInclude | null
    /**
     * The filter to search for the DiscountPredicate to update in case it exists.
     * 
    **/
    where: DiscountPredicateWhereUniqueInput
    /**
     * In case the DiscountPredicate found by the `where` argument doesn't exist, create a new DiscountPredicate with this data.
     * 
    **/
    create: XOR<DiscountPredicateCreateInput, DiscountPredicateUncheckedCreateInput>
    /**
     * In case the DiscountPredicate was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DiscountPredicateUpdateInput, DiscountPredicateUncheckedUpdateInput>
  }


  /**
   * DiscountPredicate delete
   */
  export type DiscountPredicateDeleteArgs = {
    /**
     * Select specific fields to fetch from the DiscountPredicate
     * 
    **/
    select?: DiscountPredicateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountPredicateInclude | null
    /**
     * Filter which DiscountPredicate to delete.
     * 
    **/
    where: DiscountPredicateWhereUniqueInput
  }


  /**
   * DiscountPredicate deleteMany
   */
  export type DiscountPredicateDeleteManyArgs = {
    /**
     * Filter which DiscountPredicates to delete
     * 
    **/
    where?: DiscountPredicateWhereInput
  }


  /**
   * DiscountPredicate without action
   */
  export type DiscountPredicateArgs = {
    /**
     * Select specific fields to fetch from the DiscountPredicate
     * 
    **/
    select?: DiscountPredicateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountPredicateInclude | null
  }



  /**
   * Model DiscountContainer
   */


  export type AggregateDiscountContainer = {
    _count: DiscountContainerCountAggregateOutputType | null
    _avg: DiscountContainerAvgAggregateOutputType | null
    _sum: DiscountContainerSumAggregateOutputType | null
    _min: DiscountContainerMinAggregateOutputType | null
    _max: DiscountContainerMaxAggregateOutputType | null
  }

  export type DiscountContainerAvgAggregateOutputType = {
    id: number | null
    shopId: number | null
  }

  export type DiscountContainerSumAggregateOutputType = {
    id: number | null
    shopId: number | null
  }

  export type DiscountContainerMinAggregateOutputType = {
    id: number | null
    shopId: number | null
    description: string | null
    type: DiscountRelation | null
  }

  export type DiscountContainerMaxAggregateOutputType = {
    id: number | null
    shopId: number | null
    description: string | null
    type: DiscountRelation | null
  }

  export type DiscountContainerCountAggregateOutputType = {
    id: number
    shopId: number
    description: number
    type: number
    _all: number
  }


  export type DiscountContainerAvgAggregateInputType = {
    id?: true
    shopId?: true
  }

  export type DiscountContainerSumAggregateInputType = {
    id?: true
    shopId?: true
  }

  export type DiscountContainerMinAggregateInputType = {
    id?: true
    shopId?: true
    description?: true
    type?: true
  }

  export type DiscountContainerMaxAggregateInputType = {
    id?: true
    shopId?: true
    description?: true
    type?: true
  }

  export type DiscountContainerCountAggregateInputType = {
    id?: true
    shopId?: true
    description?: true
    type?: true
    _all?: true
  }

  export type DiscountContainerAggregateArgs = {
    /**
     * Filter which DiscountContainer to aggregate.
     * 
    **/
    where?: DiscountContainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscountContainers to fetch.
     * 
    **/
    orderBy?: Enumerable<DiscountContainerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DiscountContainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscountContainers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscountContainers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DiscountContainers
    **/
    _count?: true | DiscountContainerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiscountContainerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiscountContainerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiscountContainerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiscountContainerMaxAggregateInputType
  }

  export type GetDiscountContainerAggregateType<T extends DiscountContainerAggregateArgs> = {
        [P in keyof T & keyof AggregateDiscountContainer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiscountContainer[P]>
      : GetScalarType<T[P], AggregateDiscountContainer[P]>
  }




  export type DiscountContainerGroupByArgs = {
    where?: DiscountContainerWhereInput
    orderBy?: Enumerable<DiscountContainerOrderByWithAggregationInput>
    by: Array<DiscountContainerScalarFieldEnum>
    having?: DiscountContainerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiscountContainerCountAggregateInputType | true
    _avg?: DiscountContainerAvgAggregateInputType
    _sum?: DiscountContainerSumAggregateInputType
    _min?: DiscountContainerMinAggregateInputType
    _max?: DiscountContainerMaxAggregateInputType
  }


  export type DiscountContainerGroupByOutputType = {
    id: number
    shopId: number
    description: string
    type: DiscountRelation
    _count: DiscountContainerCountAggregateOutputType | null
    _avg: DiscountContainerAvgAggregateOutputType | null
    _sum: DiscountContainerSumAggregateOutputType | null
    _min: DiscountContainerMinAggregateOutputType | null
    _max: DiscountContainerMaxAggregateOutputType | null
  }

  type GetDiscountContainerGroupByPayload<T extends DiscountContainerGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DiscountContainerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiscountContainerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiscountContainerGroupByOutputType[P]>
            : GetScalarType<T[P], DiscountContainerGroupByOutputType[P]>
        }
      >
    >


  export type DiscountContainerSelect = {
    discount?: boolean | DiscountArgs
    id?: boolean
    shopId?: boolean
    description?: boolean
    type?: boolean
    discounts?: boolean | DiscountInContainerFindManyArgs
    _count?: boolean | DiscountContainerCountOutputTypeArgs
  }

  export type DiscountContainerInclude = {
    discount?: boolean | DiscountArgs
    discounts?: boolean | DiscountInContainerFindManyArgs
    _count?: boolean | DiscountContainerCountOutputTypeArgs
  }

  export type DiscountContainerGetPayload<
    S extends boolean | null | undefined | DiscountContainerArgs,
    U = keyof S
      > = S extends true
        ? DiscountContainer
    : S extends undefined
    ? never
    : S extends DiscountContainerArgs | DiscountContainerFindManyArgs
    ?'include' extends U
    ? DiscountContainer  & {
    [P in TrueKeys<S['include']>]:
        P extends 'discount' ? DiscountGetPayload<S['include'][P]> :
        P extends 'discounts' ? Array < DiscountInContainerGetPayload<S['include'][P]>>  :
        P extends '_count' ? DiscountContainerCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'discount' ? DiscountGetPayload<S['select'][P]> :
        P extends 'discounts' ? Array < DiscountInContainerGetPayload<S['select'][P]>>  :
        P extends '_count' ? DiscountContainerCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof DiscountContainer ? DiscountContainer[P] : never
  } 
    : DiscountContainer
  : DiscountContainer


  type DiscountContainerCountArgs = Merge<
    Omit<DiscountContainerFindManyArgs, 'select' | 'include'> & {
      select?: DiscountContainerCountAggregateInputType | true
    }
  >

  export interface DiscountContainerDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one DiscountContainer that matches the filter.
     * @param {DiscountContainerFindUniqueArgs} args - Arguments to find a DiscountContainer
     * @example
     * // Get one DiscountContainer
     * const discountContainer = await prisma.discountContainer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DiscountContainerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DiscountContainerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DiscountContainer'> extends True ? CheckSelect<T, Prisma__DiscountContainerClient<DiscountContainer>, Prisma__DiscountContainerClient<DiscountContainerGetPayload<T>>> : CheckSelect<T, Prisma__DiscountContainerClient<DiscountContainer | null >, Prisma__DiscountContainerClient<DiscountContainerGetPayload<T> | null >>

    /**
     * Find the first DiscountContainer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountContainerFindFirstArgs} args - Arguments to find a DiscountContainer
     * @example
     * // Get one DiscountContainer
     * const discountContainer = await prisma.discountContainer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DiscountContainerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DiscountContainerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DiscountContainer'> extends True ? CheckSelect<T, Prisma__DiscountContainerClient<DiscountContainer>, Prisma__DiscountContainerClient<DiscountContainerGetPayload<T>>> : CheckSelect<T, Prisma__DiscountContainerClient<DiscountContainer | null >, Prisma__DiscountContainerClient<DiscountContainerGetPayload<T> | null >>

    /**
     * Find zero or more DiscountContainers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountContainerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DiscountContainers
     * const discountContainers = await prisma.discountContainer.findMany()
     * 
     * // Get first 10 DiscountContainers
     * const discountContainers = await prisma.discountContainer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const discountContainerWithIdOnly = await prisma.discountContainer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DiscountContainerFindManyArgs>(
      args?: SelectSubset<T, DiscountContainerFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<DiscountContainer>>, PrismaPromise<Array<DiscountContainerGetPayload<T>>>>

    /**
     * Create a DiscountContainer.
     * @param {DiscountContainerCreateArgs} args - Arguments to create a DiscountContainer.
     * @example
     * // Create one DiscountContainer
     * const DiscountContainer = await prisma.discountContainer.create({
     *   data: {
     *     // ... data to create a DiscountContainer
     *   }
     * })
     * 
    **/
    create<T extends DiscountContainerCreateArgs>(
      args: SelectSubset<T, DiscountContainerCreateArgs>
    ): CheckSelect<T, Prisma__DiscountContainerClient<DiscountContainer>, Prisma__DiscountContainerClient<DiscountContainerGetPayload<T>>>

    /**
     * Create many DiscountContainers.
     *     @param {DiscountContainerCreateManyArgs} args - Arguments to create many DiscountContainers.
     *     @example
     *     // Create many DiscountContainers
     *     const discountContainer = await prisma.discountContainer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DiscountContainerCreateManyArgs>(
      args?: SelectSubset<T, DiscountContainerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DiscountContainer.
     * @param {DiscountContainerDeleteArgs} args - Arguments to delete one DiscountContainer.
     * @example
     * // Delete one DiscountContainer
     * const DiscountContainer = await prisma.discountContainer.delete({
     *   where: {
     *     // ... filter to delete one DiscountContainer
     *   }
     * })
     * 
    **/
    delete<T extends DiscountContainerDeleteArgs>(
      args: SelectSubset<T, DiscountContainerDeleteArgs>
    ): CheckSelect<T, Prisma__DiscountContainerClient<DiscountContainer>, Prisma__DiscountContainerClient<DiscountContainerGetPayload<T>>>

    /**
     * Update one DiscountContainer.
     * @param {DiscountContainerUpdateArgs} args - Arguments to update one DiscountContainer.
     * @example
     * // Update one DiscountContainer
     * const discountContainer = await prisma.discountContainer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DiscountContainerUpdateArgs>(
      args: SelectSubset<T, DiscountContainerUpdateArgs>
    ): CheckSelect<T, Prisma__DiscountContainerClient<DiscountContainer>, Prisma__DiscountContainerClient<DiscountContainerGetPayload<T>>>

    /**
     * Delete zero or more DiscountContainers.
     * @param {DiscountContainerDeleteManyArgs} args - Arguments to filter DiscountContainers to delete.
     * @example
     * // Delete a few DiscountContainers
     * const { count } = await prisma.discountContainer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DiscountContainerDeleteManyArgs>(
      args?: SelectSubset<T, DiscountContainerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DiscountContainers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountContainerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DiscountContainers
     * const discountContainer = await prisma.discountContainer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DiscountContainerUpdateManyArgs>(
      args: SelectSubset<T, DiscountContainerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DiscountContainer.
     * @param {DiscountContainerUpsertArgs} args - Arguments to update or create a DiscountContainer.
     * @example
     * // Update or create a DiscountContainer
     * const discountContainer = await prisma.discountContainer.upsert({
     *   create: {
     *     // ... data to create a DiscountContainer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DiscountContainer we want to update
     *   }
     * })
    **/
    upsert<T extends DiscountContainerUpsertArgs>(
      args: SelectSubset<T, DiscountContainerUpsertArgs>
    ): CheckSelect<T, Prisma__DiscountContainerClient<DiscountContainer>, Prisma__DiscountContainerClient<DiscountContainerGetPayload<T>>>

    /**
     * Count the number of DiscountContainers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountContainerCountArgs} args - Arguments to filter DiscountContainers to count.
     * @example
     * // Count the number of DiscountContainers
     * const count = await prisma.discountContainer.count({
     *   where: {
     *     // ... the filter for the DiscountContainers we want to count
     *   }
     * })
    **/
    count<T extends DiscountContainerCountArgs>(
      args?: Subset<T, DiscountContainerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiscountContainerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DiscountContainer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountContainerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiscountContainerAggregateArgs>(args: Subset<T, DiscountContainerAggregateArgs>): PrismaPromise<GetDiscountContainerAggregateType<T>>

    /**
     * Group by DiscountContainer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountContainerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiscountContainerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiscountContainerGroupByArgs['orderBy'] }
        : { orderBy?: DiscountContainerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiscountContainerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiscountContainerGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for DiscountContainer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DiscountContainerClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    discount<T extends DiscountArgs = {}>(args?: Subset<T, DiscountArgs>): CheckSelect<T, Prisma__DiscountClient<Discount | null >, Prisma__DiscountClient<DiscountGetPayload<T> | null >>;

    discounts<T extends DiscountInContainerFindManyArgs = {}>(args?: Subset<T, DiscountInContainerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<DiscountInContainer>>, PrismaPromise<Array<DiscountInContainerGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * DiscountContainer findUnique
   */
  export type DiscountContainerFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the DiscountContainer
     * 
    **/
    select?: DiscountContainerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountContainerInclude | null
    /**
     * Throw an Error if a DiscountContainer can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DiscountContainer to fetch.
     * 
    **/
    where: DiscountContainerWhereUniqueInput
  }


  /**
   * DiscountContainer findFirst
   */
  export type DiscountContainerFindFirstArgs = {
    /**
     * Select specific fields to fetch from the DiscountContainer
     * 
    **/
    select?: DiscountContainerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountContainerInclude | null
    /**
     * Throw an Error if a DiscountContainer can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DiscountContainer to fetch.
     * 
    **/
    where?: DiscountContainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscountContainers to fetch.
     * 
    **/
    orderBy?: Enumerable<DiscountContainerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiscountContainers.
     * 
    **/
    cursor?: DiscountContainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscountContainers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscountContainers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiscountContainers.
     * 
    **/
    distinct?: Enumerable<DiscountContainerScalarFieldEnum>
  }


  /**
   * DiscountContainer findMany
   */
  export type DiscountContainerFindManyArgs = {
    /**
     * Select specific fields to fetch from the DiscountContainer
     * 
    **/
    select?: DiscountContainerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountContainerInclude | null
    /**
     * Filter, which DiscountContainers to fetch.
     * 
    **/
    where?: DiscountContainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscountContainers to fetch.
     * 
    **/
    orderBy?: Enumerable<DiscountContainerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DiscountContainers.
     * 
    **/
    cursor?: DiscountContainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscountContainers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscountContainers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DiscountContainerScalarFieldEnum>
  }


  /**
   * DiscountContainer create
   */
  export type DiscountContainerCreateArgs = {
    /**
     * Select specific fields to fetch from the DiscountContainer
     * 
    **/
    select?: DiscountContainerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountContainerInclude | null
    /**
     * The data needed to create a DiscountContainer.
     * 
    **/
    data: XOR<DiscountContainerCreateInput, DiscountContainerUncheckedCreateInput>
  }


  /**
   * DiscountContainer createMany
   */
  export type DiscountContainerCreateManyArgs = {
    /**
     * The data used to create many DiscountContainers.
     * 
    **/
    data: Enumerable<DiscountContainerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DiscountContainer update
   */
  export type DiscountContainerUpdateArgs = {
    /**
     * Select specific fields to fetch from the DiscountContainer
     * 
    **/
    select?: DiscountContainerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountContainerInclude | null
    /**
     * The data needed to update a DiscountContainer.
     * 
    **/
    data: XOR<DiscountContainerUpdateInput, DiscountContainerUncheckedUpdateInput>
    /**
     * Choose, which DiscountContainer to update.
     * 
    **/
    where: DiscountContainerWhereUniqueInput
  }


  /**
   * DiscountContainer updateMany
   */
  export type DiscountContainerUpdateManyArgs = {
    /**
     * The data used to update DiscountContainers.
     * 
    **/
    data: XOR<DiscountContainerUpdateManyMutationInput, DiscountContainerUncheckedUpdateManyInput>
    /**
     * Filter which DiscountContainers to update
     * 
    **/
    where?: DiscountContainerWhereInput
  }


  /**
   * DiscountContainer upsert
   */
  export type DiscountContainerUpsertArgs = {
    /**
     * Select specific fields to fetch from the DiscountContainer
     * 
    **/
    select?: DiscountContainerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountContainerInclude | null
    /**
     * The filter to search for the DiscountContainer to update in case it exists.
     * 
    **/
    where: DiscountContainerWhereUniqueInput
    /**
     * In case the DiscountContainer found by the `where` argument doesn't exist, create a new DiscountContainer with this data.
     * 
    **/
    create: XOR<DiscountContainerCreateInput, DiscountContainerUncheckedCreateInput>
    /**
     * In case the DiscountContainer was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DiscountContainerUpdateInput, DiscountContainerUncheckedUpdateInput>
  }


  /**
   * DiscountContainer delete
   */
  export type DiscountContainerDeleteArgs = {
    /**
     * Select specific fields to fetch from the DiscountContainer
     * 
    **/
    select?: DiscountContainerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountContainerInclude | null
    /**
     * Filter which DiscountContainer to delete.
     * 
    **/
    where: DiscountContainerWhereUniqueInput
  }


  /**
   * DiscountContainer deleteMany
   */
  export type DiscountContainerDeleteManyArgs = {
    /**
     * Filter which DiscountContainers to delete
     * 
    **/
    where?: DiscountContainerWhereInput
  }


  /**
   * DiscountContainer without action
   */
  export type DiscountContainerArgs = {
    /**
     * Select specific fields to fetch from the DiscountContainer
     * 
    **/
    select?: DiscountContainerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountContainerInclude | null
  }



  /**
   * Model DiscountInContainer
   */


  export type AggregateDiscountInContainer = {
    _count: DiscountInContainerCountAggregateOutputType | null
    _avg: DiscountInContainerAvgAggregateOutputType | null
    _sum: DiscountInContainerSumAggregateOutputType | null
    _min: DiscountInContainerMinAggregateOutputType | null
    _max: DiscountInContainerMaxAggregateOutputType | null
  }

  export type DiscountInContainerAvgAggregateOutputType = {
    containedDiscount: number | null
    shopId: number | null
    containingDiscount: number | null
  }

  export type DiscountInContainerSumAggregateOutputType = {
    containedDiscount: number | null
    shopId: number | null
    containingDiscount: number | null
  }

  export type DiscountInContainerMinAggregateOutputType = {
    containedDiscount: number | null
    shopId: number | null
    containingDiscount: number | null
  }

  export type DiscountInContainerMaxAggregateOutputType = {
    containedDiscount: number | null
    shopId: number | null
    containingDiscount: number | null
  }

  export type DiscountInContainerCountAggregateOutputType = {
    containedDiscount: number
    shopId: number
    containingDiscount: number
    _all: number
  }


  export type DiscountInContainerAvgAggregateInputType = {
    containedDiscount?: true
    shopId?: true
    containingDiscount?: true
  }

  export type DiscountInContainerSumAggregateInputType = {
    containedDiscount?: true
    shopId?: true
    containingDiscount?: true
  }

  export type DiscountInContainerMinAggregateInputType = {
    containedDiscount?: true
    shopId?: true
    containingDiscount?: true
  }

  export type DiscountInContainerMaxAggregateInputType = {
    containedDiscount?: true
    shopId?: true
    containingDiscount?: true
  }

  export type DiscountInContainerCountAggregateInputType = {
    containedDiscount?: true
    shopId?: true
    containingDiscount?: true
    _all?: true
  }

  export type DiscountInContainerAggregateArgs = {
    /**
     * Filter which DiscountInContainer to aggregate.
     * 
    **/
    where?: DiscountInContainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscountInContainers to fetch.
     * 
    **/
    orderBy?: Enumerable<DiscountInContainerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DiscountInContainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscountInContainers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscountInContainers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DiscountInContainers
    **/
    _count?: true | DiscountInContainerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiscountInContainerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiscountInContainerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiscountInContainerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiscountInContainerMaxAggregateInputType
  }

  export type GetDiscountInContainerAggregateType<T extends DiscountInContainerAggregateArgs> = {
        [P in keyof T & keyof AggregateDiscountInContainer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiscountInContainer[P]>
      : GetScalarType<T[P], AggregateDiscountInContainer[P]>
  }




  export type DiscountInContainerGroupByArgs = {
    where?: DiscountInContainerWhereInput
    orderBy?: Enumerable<DiscountInContainerOrderByWithAggregationInput>
    by: Array<DiscountInContainerScalarFieldEnum>
    having?: DiscountInContainerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiscountInContainerCountAggregateInputType | true
    _avg?: DiscountInContainerAvgAggregateInputType
    _sum?: DiscountInContainerSumAggregateInputType
    _min?: DiscountInContainerMinAggregateInputType
    _max?: DiscountInContainerMaxAggregateInputType
  }


  export type DiscountInContainerGroupByOutputType = {
    containedDiscount: number
    shopId: number
    containingDiscount: number
    _count: DiscountInContainerCountAggregateOutputType | null
    _avg: DiscountInContainerAvgAggregateOutputType | null
    _sum: DiscountInContainerSumAggregateOutputType | null
    _min: DiscountInContainerMinAggregateOutputType | null
    _max: DiscountInContainerMaxAggregateOutputType | null
  }

  type GetDiscountInContainerGroupByPayload<T extends DiscountInContainerGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DiscountInContainerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiscountInContainerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiscountInContainerGroupByOutputType[P]>
            : GetScalarType<T[P], DiscountInContainerGroupByOutputType[P]>
        }
      >
    >


  export type DiscountInContainerSelect = {
    discount?: boolean | DiscountArgs
    containedDiscount?: boolean
    shopId?: boolean
    discountContainer?: boolean | DiscountContainerArgs
    containingDiscount?: boolean
  }

  export type DiscountInContainerInclude = {
    discount?: boolean | DiscountArgs
    discountContainer?: boolean | DiscountContainerArgs
  }

  export type DiscountInContainerGetPayload<
    S extends boolean | null | undefined | DiscountInContainerArgs,
    U = keyof S
      > = S extends true
        ? DiscountInContainer
    : S extends undefined
    ? never
    : S extends DiscountInContainerArgs | DiscountInContainerFindManyArgs
    ?'include' extends U
    ? DiscountInContainer  & {
    [P in TrueKeys<S['include']>]:
        P extends 'discount' ? DiscountGetPayload<S['include'][P]> :
        P extends 'discountContainer' ? DiscountContainerGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'discount' ? DiscountGetPayload<S['select'][P]> :
        P extends 'discountContainer' ? DiscountContainerGetPayload<S['select'][P]> :  P extends keyof DiscountInContainer ? DiscountInContainer[P] : never
  } 
    : DiscountInContainer
  : DiscountInContainer


  type DiscountInContainerCountArgs = Merge<
    Omit<DiscountInContainerFindManyArgs, 'select' | 'include'> & {
      select?: DiscountInContainerCountAggregateInputType | true
    }
  >

  export interface DiscountInContainerDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one DiscountInContainer that matches the filter.
     * @param {DiscountInContainerFindUniqueArgs} args - Arguments to find a DiscountInContainer
     * @example
     * // Get one DiscountInContainer
     * const discountInContainer = await prisma.discountInContainer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DiscountInContainerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DiscountInContainerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DiscountInContainer'> extends True ? CheckSelect<T, Prisma__DiscountInContainerClient<DiscountInContainer>, Prisma__DiscountInContainerClient<DiscountInContainerGetPayload<T>>> : CheckSelect<T, Prisma__DiscountInContainerClient<DiscountInContainer | null >, Prisma__DiscountInContainerClient<DiscountInContainerGetPayload<T> | null >>

    /**
     * Find the first DiscountInContainer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountInContainerFindFirstArgs} args - Arguments to find a DiscountInContainer
     * @example
     * // Get one DiscountInContainer
     * const discountInContainer = await prisma.discountInContainer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DiscountInContainerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DiscountInContainerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DiscountInContainer'> extends True ? CheckSelect<T, Prisma__DiscountInContainerClient<DiscountInContainer>, Prisma__DiscountInContainerClient<DiscountInContainerGetPayload<T>>> : CheckSelect<T, Prisma__DiscountInContainerClient<DiscountInContainer | null >, Prisma__DiscountInContainerClient<DiscountInContainerGetPayload<T> | null >>

    /**
     * Find zero or more DiscountInContainers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountInContainerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DiscountInContainers
     * const discountInContainers = await prisma.discountInContainer.findMany()
     * 
     * // Get first 10 DiscountInContainers
     * const discountInContainers = await prisma.discountInContainer.findMany({ take: 10 })
     * 
     * // Only select the `containedDiscount`
     * const discountInContainerWithContainedDiscountOnly = await prisma.discountInContainer.findMany({ select: { containedDiscount: true } })
     * 
    **/
    findMany<T extends DiscountInContainerFindManyArgs>(
      args?: SelectSubset<T, DiscountInContainerFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<DiscountInContainer>>, PrismaPromise<Array<DiscountInContainerGetPayload<T>>>>

    /**
     * Create a DiscountInContainer.
     * @param {DiscountInContainerCreateArgs} args - Arguments to create a DiscountInContainer.
     * @example
     * // Create one DiscountInContainer
     * const DiscountInContainer = await prisma.discountInContainer.create({
     *   data: {
     *     // ... data to create a DiscountInContainer
     *   }
     * })
     * 
    **/
    create<T extends DiscountInContainerCreateArgs>(
      args: SelectSubset<T, DiscountInContainerCreateArgs>
    ): CheckSelect<T, Prisma__DiscountInContainerClient<DiscountInContainer>, Prisma__DiscountInContainerClient<DiscountInContainerGetPayload<T>>>

    /**
     * Create many DiscountInContainers.
     *     @param {DiscountInContainerCreateManyArgs} args - Arguments to create many DiscountInContainers.
     *     @example
     *     // Create many DiscountInContainers
     *     const discountInContainer = await prisma.discountInContainer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DiscountInContainerCreateManyArgs>(
      args?: SelectSubset<T, DiscountInContainerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DiscountInContainer.
     * @param {DiscountInContainerDeleteArgs} args - Arguments to delete one DiscountInContainer.
     * @example
     * // Delete one DiscountInContainer
     * const DiscountInContainer = await prisma.discountInContainer.delete({
     *   where: {
     *     // ... filter to delete one DiscountInContainer
     *   }
     * })
     * 
    **/
    delete<T extends DiscountInContainerDeleteArgs>(
      args: SelectSubset<T, DiscountInContainerDeleteArgs>
    ): CheckSelect<T, Prisma__DiscountInContainerClient<DiscountInContainer>, Prisma__DiscountInContainerClient<DiscountInContainerGetPayload<T>>>

    /**
     * Update one DiscountInContainer.
     * @param {DiscountInContainerUpdateArgs} args - Arguments to update one DiscountInContainer.
     * @example
     * // Update one DiscountInContainer
     * const discountInContainer = await prisma.discountInContainer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DiscountInContainerUpdateArgs>(
      args: SelectSubset<T, DiscountInContainerUpdateArgs>
    ): CheckSelect<T, Prisma__DiscountInContainerClient<DiscountInContainer>, Prisma__DiscountInContainerClient<DiscountInContainerGetPayload<T>>>

    /**
     * Delete zero or more DiscountInContainers.
     * @param {DiscountInContainerDeleteManyArgs} args - Arguments to filter DiscountInContainers to delete.
     * @example
     * // Delete a few DiscountInContainers
     * const { count } = await prisma.discountInContainer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DiscountInContainerDeleteManyArgs>(
      args?: SelectSubset<T, DiscountInContainerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DiscountInContainers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountInContainerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DiscountInContainers
     * const discountInContainer = await prisma.discountInContainer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DiscountInContainerUpdateManyArgs>(
      args: SelectSubset<T, DiscountInContainerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DiscountInContainer.
     * @param {DiscountInContainerUpsertArgs} args - Arguments to update or create a DiscountInContainer.
     * @example
     * // Update or create a DiscountInContainer
     * const discountInContainer = await prisma.discountInContainer.upsert({
     *   create: {
     *     // ... data to create a DiscountInContainer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DiscountInContainer we want to update
     *   }
     * })
    **/
    upsert<T extends DiscountInContainerUpsertArgs>(
      args: SelectSubset<T, DiscountInContainerUpsertArgs>
    ): CheckSelect<T, Prisma__DiscountInContainerClient<DiscountInContainer>, Prisma__DiscountInContainerClient<DiscountInContainerGetPayload<T>>>

    /**
     * Count the number of DiscountInContainers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountInContainerCountArgs} args - Arguments to filter DiscountInContainers to count.
     * @example
     * // Count the number of DiscountInContainers
     * const count = await prisma.discountInContainer.count({
     *   where: {
     *     // ... the filter for the DiscountInContainers we want to count
     *   }
     * })
    **/
    count<T extends DiscountInContainerCountArgs>(
      args?: Subset<T, DiscountInContainerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiscountInContainerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DiscountInContainer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountInContainerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiscountInContainerAggregateArgs>(args: Subset<T, DiscountInContainerAggregateArgs>): PrismaPromise<GetDiscountInContainerAggregateType<T>>

    /**
     * Group by DiscountInContainer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountInContainerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiscountInContainerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiscountInContainerGroupByArgs['orderBy'] }
        : { orderBy?: DiscountInContainerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiscountInContainerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiscountInContainerGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for DiscountInContainer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DiscountInContainerClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    discount<T extends DiscountArgs = {}>(args?: Subset<T, DiscountArgs>): CheckSelect<T, Prisma__DiscountClient<Discount | null >, Prisma__DiscountClient<DiscountGetPayload<T> | null >>;

    discountContainer<T extends DiscountContainerArgs = {}>(args?: Subset<T, DiscountContainerArgs>): CheckSelect<T, Prisma__DiscountContainerClient<DiscountContainer | null >, Prisma__DiscountContainerClient<DiscountContainerGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * DiscountInContainer findUnique
   */
  export type DiscountInContainerFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the DiscountInContainer
     * 
    **/
    select?: DiscountInContainerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountInContainerInclude | null
    /**
     * Throw an Error if a DiscountInContainer can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DiscountInContainer to fetch.
     * 
    **/
    where: DiscountInContainerWhereUniqueInput
  }


  /**
   * DiscountInContainer findFirst
   */
  export type DiscountInContainerFindFirstArgs = {
    /**
     * Select specific fields to fetch from the DiscountInContainer
     * 
    **/
    select?: DiscountInContainerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountInContainerInclude | null
    /**
     * Throw an Error if a DiscountInContainer can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DiscountInContainer to fetch.
     * 
    **/
    where?: DiscountInContainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscountInContainers to fetch.
     * 
    **/
    orderBy?: Enumerable<DiscountInContainerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiscountInContainers.
     * 
    **/
    cursor?: DiscountInContainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscountInContainers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscountInContainers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiscountInContainers.
     * 
    **/
    distinct?: Enumerable<DiscountInContainerScalarFieldEnum>
  }


  /**
   * DiscountInContainer findMany
   */
  export type DiscountInContainerFindManyArgs = {
    /**
     * Select specific fields to fetch from the DiscountInContainer
     * 
    **/
    select?: DiscountInContainerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountInContainerInclude | null
    /**
     * Filter, which DiscountInContainers to fetch.
     * 
    **/
    where?: DiscountInContainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscountInContainers to fetch.
     * 
    **/
    orderBy?: Enumerable<DiscountInContainerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DiscountInContainers.
     * 
    **/
    cursor?: DiscountInContainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscountInContainers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscountInContainers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DiscountInContainerScalarFieldEnum>
  }


  /**
   * DiscountInContainer create
   */
  export type DiscountInContainerCreateArgs = {
    /**
     * Select specific fields to fetch from the DiscountInContainer
     * 
    **/
    select?: DiscountInContainerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountInContainerInclude | null
    /**
     * The data needed to create a DiscountInContainer.
     * 
    **/
    data: XOR<DiscountInContainerCreateInput, DiscountInContainerUncheckedCreateInput>
  }


  /**
   * DiscountInContainer createMany
   */
  export type DiscountInContainerCreateManyArgs = {
    /**
     * The data used to create many DiscountInContainers.
     * 
    **/
    data: Enumerable<DiscountInContainerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DiscountInContainer update
   */
  export type DiscountInContainerUpdateArgs = {
    /**
     * Select specific fields to fetch from the DiscountInContainer
     * 
    **/
    select?: DiscountInContainerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountInContainerInclude | null
    /**
     * The data needed to update a DiscountInContainer.
     * 
    **/
    data: XOR<DiscountInContainerUpdateInput, DiscountInContainerUncheckedUpdateInput>
    /**
     * Choose, which DiscountInContainer to update.
     * 
    **/
    where: DiscountInContainerWhereUniqueInput
  }


  /**
   * DiscountInContainer updateMany
   */
  export type DiscountInContainerUpdateManyArgs = {
    /**
     * The data used to update DiscountInContainers.
     * 
    **/
    data: XOR<DiscountInContainerUpdateManyMutationInput, DiscountInContainerUncheckedUpdateManyInput>
    /**
     * Filter which DiscountInContainers to update
     * 
    **/
    where?: DiscountInContainerWhereInput
  }


  /**
   * DiscountInContainer upsert
   */
  export type DiscountInContainerUpsertArgs = {
    /**
     * Select specific fields to fetch from the DiscountInContainer
     * 
    **/
    select?: DiscountInContainerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountInContainerInclude | null
    /**
     * The filter to search for the DiscountInContainer to update in case it exists.
     * 
    **/
    where: DiscountInContainerWhereUniqueInput
    /**
     * In case the DiscountInContainer found by the `where` argument doesn't exist, create a new DiscountInContainer with this data.
     * 
    **/
    create: XOR<DiscountInContainerCreateInput, DiscountInContainerUncheckedCreateInput>
    /**
     * In case the DiscountInContainer was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DiscountInContainerUpdateInput, DiscountInContainerUncheckedUpdateInput>
  }


  /**
   * DiscountInContainer delete
   */
  export type DiscountInContainerDeleteArgs = {
    /**
     * Select specific fields to fetch from the DiscountInContainer
     * 
    **/
    select?: DiscountInContainerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountInContainerInclude | null
    /**
     * Filter which DiscountInContainer to delete.
     * 
    **/
    where: DiscountInContainerWhereUniqueInput
  }


  /**
   * DiscountInContainer deleteMany
   */
  export type DiscountInContainerDeleteManyArgs = {
    /**
     * Filter which DiscountInContainers to delete
     * 
    **/
    where?: DiscountInContainerWhereInput
  }


  /**
   * DiscountInContainer without action
   */
  export type DiscountInContainerArgs = {
    /**
     * Select specific fields to fetch from the DiscountInContainer
     * 
    **/
    select?: DiscountInContainerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountInContainerInclude | null
  }



  /**
   * Model Policy
   */


  export type AggregatePolicy = {
    _count: PolicyCountAggregateOutputType | null
    _avg: PolicyAvgAggregateOutputType | null
    _sum: PolicySumAggregateOutputType | null
    _min: PolicyMinAggregateOutputType | null
    _max: PolicyMaxAggregateOutputType | null
  }

  export type PolicyAvgAggregateOutputType = {
    id: number | null
    shopId: number | null
  }

  export type PolicySumAggregateOutputType = {
    id: number | null
    shopId: number | null
  }

  export type PolicyMinAggregateOutputType = {
    id: number | null
    shopId: number | null
  }

  export type PolicyMaxAggregateOutputType = {
    id: number | null
    shopId: number | null
  }

  export type PolicyCountAggregateOutputType = {
    id: number
    shopId: number
    _all: number
  }


  export type PolicyAvgAggregateInputType = {
    id?: true
    shopId?: true
  }

  export type PolicySumAggregateInputType = {
    id?: true
    shopId?: true
  }

  export type PolicyMinAggregateInputType = {
    id?: true
    shopId?: true
  }

  export type PolicyMaxAggregateInputType = {
    id?: true
    shopId?: true
  }

  export type PolicyCountAggregateInputType = {
    id?: true
    shopId?: true
    _all?: true
  }

  export type PolicyAggregateArgs = {
    /**
     * Filter which Policy to aggregate.
     * 
    **/
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     * 
    **/
    orderBy?: Enumerable<PolicyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Policies
    **/
    _count?: true | PolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PolicyMaxAggregateInputType
  }

  export type GetPolicyAggregateType<T extends PolicyAggregateArgs> = {
        [P in keyof T & keyof AggregatePolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePolicy[P]>
      : GetScalarType<T[P], AggregatePolicy[P]>
  }




  export type PolicyGroupByArgs = {
    where?: PolicyWhereInput
    orderBy?: Enumerable<PolicyOrderByWithAggregationInput>
    by: Array<PolicyScalarFieldEnum>
    having?: PolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PolicyCountAggregateInputType | true
    _avg?: PolicyAvgAggregateInputType
    _sum?: PolicySumAggregateInputType
    _min?: PolicyMinAggregateInputType
    _max?: PolicyMaxAggregateInputType
  }


  export type PolicyGroupByOutputType = {
    id: number
    shopId: number
    _count: PolicyCountAggregateOutputType | null
    _avg: PolicyAvgAggregateOutputType | null
    _sum: PolicySumAggregateOutputType | null
    _min: PolicyMinAggregateOutputType | null
    _max: PolicyMaxAggregateOutputType | null
  }

  type GetPolicyGroupByPayload<T extends PolicyGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PolicyGroupByOutputType[P]>
            : GetScalarType<T[P], PolicyGroupByOutputType[P]>
        }
      >
    >


  export type PolicySelect = {
    id?: boolean
    shop?: boolean | ShopArgs
    shopId?: boolean
    simplePolicy?: boolean | SimplePolicyArgs
    conditionalPolicy?: boolean | ConditionalPolicyArgs
    logicalPolicy?: boolean | LogicalPolicyArgs
    policyInContainer?: boolean | PolicyInContainerArgs
  }

  export type PolicyInclude = {
    shop?: boolean | ShopArgs
    simplePolicy?: boolean | SimplePolicyArgs
    conditionalPolicy?: boolean | ConditionalPolicyArgs
    logicalPolicy?: boolean | LogicalPolicyArgs
    policyInContainer?: boolean | PolicyInContainerArgs
  }

  export type PolicyGetPayload<
    S extends boolean | null | undefined | PolicyArgs,
    U = keyof S
      > = S extends true
        ? Policy
    : S extends undefined
    ? never
    : S extends PolicyArgs | PolicyFindManyArgs
    ?'include' extends U
    ? Policy  & {
    [P in TrueKeys<S['include']>]:
        P extends 'shop' ? ShopGetPayload<S['include'][P]> :
        P extends 'simplePolicy' ? SimplePolicyGetPayload<S['include'][P]> | null :
        P extends 'conditionalPolicy' ? ConditionalPolicyGetPayload<S['include'][P]> | null :
        P extends 'logicalPolicy' ? LogicalPolicyGetPayload<S['include'][P]> | null :
        P extends 'policyInContainer' ? PolicyInContainerGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'shop' ? ShopGetPayload<S['select'][P]> :
        P extends 'simplePolicy' ? SimplePolicyGetPayload<S['select'][P]> | null :
        P extends 'conditionalPolicy' ? ConditionalPolicyGetPayload<S['select'][P]> | null :
        P extends 'logicalPolicy' ? LogicalPolicyGetPayload<S['select'][P]> | null :
        P extends 'policyInContainer' ? PolicyInContainerGetPayload<S['select'][P]> | null :  P extends keyof Policy ? Policy[P] : never
  } 
    : Policy
  : Policy


  type PolicyCountArgs = Merge<
    Omit<PolicyFindManyArgs, 'select' | 'include'> & {
      select?: PolicyCountAggregateInputType | true
    }
  >

  export interface PolicyDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Policy that matches the filter.
     * @param {PolicyFindUniqueArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PolicyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PolicyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Policy'> extends True ? CheckSelect<T, Prisma__PolicyClient<Policy>, Prisma__PolicyClient<PolicyGetPayload<T>>> : CheckSelect<T, Prisma__PolicyClient<Policy | null >, Prisma__PolicyClient<PolicyGetPayload<T> | null >>

    /**
     * Find the first Policy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyFindFirstArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PolicyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PolicyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Policy'> extends True ? CheckSelect<T, Prisma__PolicyClient<Policy>, Prisma__PolicyClient<PolicyGetPayload<T>>> : CheckSelect<T, Prisma__PolicyClient<Policy | null >, Prisma__PolicyClient<PolicyGetPayload<T> | null >>

    /**
     * Find zero or more Policies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Policies
     * const policies = await prisma.policy.findMany()
     * 
     * // Get first 10 Policies
     * const policies = await prisma.policy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const policyWithIdOnly = await prisma.policy.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PolicyFindManyArgs>(
      args?: SelectSubset<T, PolicyFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Policy>>, PrismaPromise<Array<PolicyGetPayload<T>>>>

    /**
     * Create a Policy.
     * @param {PolicyCreateArgs} args - Arguments to create a Policy.
     * @example
     * // Create one Policy
     * const Policy = await prisma.policy.create({
     *   data: {
     *     // ... data to create a Policy
     *   }
     * })
     * 
    **/
    create<T extends PolicyCreateArgs>(
      args: SelectSubset<T, PolicyCreateArgs>
    ): CheckSelect<T, Prisma__PolicyClient<Policy>, Prisma__PolicyClient<PolicyGetPayload<T>>>

    /**
     * Create many Policies.
     *     @param {PolicyCreateManyArgs} args - Arguments to create many Policies.
     *     @example
     *     // Create many Policies
     *     const policy = await prisma.policy.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PolicyCreateManyArgs>(
      args?: SelectSubset<T, PolicyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Policy.
     * @param {PolicyDeleteArgs} args - Arguments to delete one Policy.
     * @example
     * // Delete one Policy
     * const Policy = await prisma.policy.delete({
     *   where: {
     *     // ... filter to delete one Policy
     *   }
     * })
     * 
    **/
    delete<T extends PolicyDeleteArgs>(
      args: SelectSubset<T, PolicyDeleteArgs>
    ): CheckSelect<T, Prisma__PolicyClient<Policy>, Prisma__PolicyClient<PolicyGetPayload<T>>>

    /**
     * Update one Policy.
     * @param {PolicyUpdateArgs} args - Arguments to update one Policy.
     * @example
     * // Update one Policy
     * const policy = await prisma.policy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PolicyUpdateArgs>(
      args: SelectSubset<T, PolicyUpdateArgs>
    ): CheckSelect<T, Prisma__PolicyClient<Policy>, Prisma__PolicyClient<PolicyGetPayload<T>>>

    /**
     * Delete zero or more Policies.
     * @param {PolicyDeleteManyArgs} args - Arguments to filter Policies to delete.
     * @example
     * // Delete a few Policies
     * const { count } = await prisma.policy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PolicyDeleteManyArgs>(
      args?: SelectSubset<T, PolicyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Policies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Policies
     * const policy = await prisma.policy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PolicyUpdateManyArgs>(
      args: SelectSubset<T, PolicyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Policy.
     * @param {PolicyUpsertArgs} args - Arguments to update or create a Policy.
     * @example
     * // Update or create a Policy
     * const policy = await prisma.policy.upsert({
     *   create: {
     *     // ... data to create a Policy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Policy we want to update
     *   }
     * })
    **/
    upsert<T extends PolicyUpsertArgs>(
      args: SelectSubset<T, PolicyUpsertArgs>
    ): CheckSelect<T, Prisma__PolicyClient<Policy>, Prisma__PolicyClient<PolicyGetPayload<T>>>

    /**
     * Count the number of Policies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyCountArgs} args - Arguments to filter Policies to count.
     * @example
     * // Count the number of Policies
     * const count = await prisma.policy.count({
     *   where: {
     *     // ... the filter for the Policies we want to count
     *   }
     * })
    **/
    count<T extends PolicyCountArgs>(
      args?: Subset<T, PolicyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Policy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PolicyAggregateArgs>(args: Subset<T, PolicyAggregateArgs>): PrismaPromise<GetPolicyAggregateType<T>>

    /**
     * Group by Policy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PolicyGroupByArgs['orderBy'] }
        : { orderBy?: PolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPolicyGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Policy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PolicyClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    shop<T extends ShopArgs = {}>(args?: Subset<T, ShopArgs>): CheckSelect<T, Prisma__ShopClient<Shop | null >, Prisma__ShopClient<ShopGetPayload<T> | null >>;

    simplePolicy<T extends SimplePolicyArgs = {}>(args?: Subset<T, SimplePolicyArgs>): CheckSelect<T, Prisma__SimplePolicyClient<SimplePolicy | null >, Prisma__SimplePolicyClient<SimplePolicyGetPayload<T> | null >>;

    conditionalPolicy<T extends ConditionalPolicyArgs = {}>(args?: Subset<T, ConditionalPolicyArgs>): CheckSelect<T, Prisma__ConditionalPolicyClient<ConditionalPolicy | null >, Prisma__ConditionalPolicyClient<ConditionalPolicyGetPayload<T> | null >>;

    logicalPolicy<T extends LogicalPolicyArgs = {}>(args?: Subset<T, LogicalPolicyArgs>): CheckSelect<T, Prisma__LogicalPolicyClient<LogicalPolicy | null >, Prisma__LogicalPolicyClient<LogicalPolicyGetPayload<T> | null >>;

    policyInContainer<T extends PolicyInContainerArgs = {}>(args?: Subset<T, PolicyInContainerArgs>): CheckSelect<T, Prisma__PolicyInContainerClient<PolicyInContainer | null >, Prisma__PolicyInContainerClient<PolicyInContainerGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Policy findUnique
   */
  export type PolicyFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Policy
     * 
    **/
    select?: PolicySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PolicyInclude | null
    /**
     * Throw an Error if a Policy can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Policy to fetch.
     * 
    **/
    where: PolicyWhereUniqueInput
  }


  /**
   * Policy findFirst
   */
  export type PolicyFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Policy
     * 
    **/
    select?: PolicySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PolicyInclude | null
    /**
     * Throw an Error if a Policy can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Policy to fetch.
     * 
    **/
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     * 
    **/
    orderBy?: Enumerable<PolicyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Policies.
     * 
    **/
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Policies.
     * 
    **/
    distinct?: Enumerable<PolicyScalarFieldEnum>
  }


  /**
   * Policy findMany
   */
  export type PolicyFindManyArgs = {
    /**
     * Select specific fields to fetch from the Policy
     * 
    **/
    select?: PolicySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PolicyInclude | null
    /**
     * Filter, which Policies to fetch.
     * 
    **/
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     * 
    **/
    orderBy?: Enumerable<PolicyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Policies.
     * 
    **/
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PolicyScalarFieldEnum>
  }


  /**
   * Policy create
   */
  export type PolicyCreateArgs = {
    /**
     * Select specific fields to fetch from the Policy
     * 
    **/
    select?: PolicySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PolicyInclude | null
    /**
     * The data needed to create a Policy.
     * 
    **/
    data: XOR<PolicyCreateInput, PolicyUncheckedCreateInput>
  }


  /**
   * Policy createMany
   */
  export type PolicyCreateManyArgs = {
    /**
     * The data used to create many Policies.
     * 
    **/
    data: Enumerable<PolicyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Policy update
   */
  export type PolicyUpdateArgs = {
    /**
     * Select specific fields to fetch from the Policy
     * 
    **/
    select?: PolicySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PolicyInclude | null
    /**
     * The data needed to update a Policy.
     * 
    **/
    data: XOR<PolicyUpdateInput, PolicyUncheckedUpdateInput>
    /**
     * Choose, which Policy to update.
     * 
    **/
    where: PolicyWhereUniqueInput
  }


  /**
   * Policy updateMany
   */
  export type PolicyUpdateManyArgs = {
    /**
     * The data used to update Policies.
     * 
    **/
    data: XOR<PolicyUpdateManyMutationInput, PolicyUncheckedUpdateManyInput>
    /**
     * Filter which Policies to update
     * 
    **/
    where?: PolicyWhereInput
  }


  /**
   * Policy upsert
   */
  export type PolicyUpsertArgs = {
    /**
     * Select specific fields to fetch from the Policy
     * 
    **/
    select?: PolicySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PolicyInclude | null
    /**
     * The filter to search for the Policy to update in case it exists.
     * 
    **/
    where: PolicyWhereUniqueInput
    /**
     * In case the Policy found by the `where` argument doesn't exist, create a new Policy with this data.
     * 
    **/
    create: XOR<PolicyCreateInput, PolicyUncheckedCreateInput>
    /**
     * In case the Policy was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PolicyUpdateInput, PolicyUncheckedUpdateInput>
  }


  /**
   * Policy delete
   */
  export type PolicyDeleteArgs = {
    /**
     * Select specific fields to fetch from the Policy
     * 
    **/
    select?: PolicySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PolicyInclude | null
    /**
     * Filter which Policy to delete.
     * 
    **/
    where: PolicyWhereUniqueInput
  }


  /**
   * Policy deleteMany
   */
  export type PolicyDeleteManyArgs = {
    /**
     * Filter which Policies to delete
     * 
    **/
    where?: PolicyWhereInput
  }


  /**
   * Policy without action
   */
  export type PolicyArgs = {
    /**
     * Select specific fields to fetch from the Policy
     * 
    **/
    select?: PolicySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PolicyInclude | null
  }



  /**
   * Model SimplePolicy
   */


  export type AggregateSimplePolicy = {
    _count: SimplePolicyCountAggregateOutputType | null
    _avg: SimplePolicyAvgAggregateOutputType | null
    _sum: SimplePolicySumAggregateOutputType | null
    _min: SimplePolicyMinAggregateOutputType | null
    _max: SimplePolicyMaxAggregateOutputType | null
  }

  export type SimplePolicyAvgAggregateOutputType = {
    id: number | null
    shopId: number | null
  }

  export type SimplePolicySumAggregateOutputType = {
    id: number | null
    shopId: number | null
  }

  export type SimplePolicyMinAggregateOutputType = {
    id: number | null
    shopId: number | null
    okay: boolean | null
    message: string | null
  }

  export type SimplePolicyMaxAggregateOutputType = {
    id: number | null
    shopId: number | null
    okay: boolean | null
    message: string | null
  }

  export type SimplePolicyCountAggregateOutputType = {
    id: number
    shopId: number
    okay: number
    message: number
    _all: number
  }


  export type SimplePolicyAvgAggregateInputType = {
    id?: true
    shopId?: true
  }

  export type SimplePolicySumAggregateInputType = {
    id?: true
    shopId?: true
  }

  export type SimplePolicyMinAggregateInputType = {
    id?: true
    shopId?: true
    okay?: true
    message?: true
  }

  export type SimplePolicyMaxAggregateInputType = {
    id?: true
    shopId?: true
    okay?: true
    message?: true
  }

  export type SimplePolicyCountAggregateInputType = {
    id?: true
    shopId?: true
    okay?: true
    message?: true
    _all?: true
  }

  export type SimplePolicyAggregateArgs = {
    /**
     * Filter which SimplePolicy to aggregate.
     * 
    **/
    where?: SimplePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimplePolicies to fetch.
     * 
    **/
    orderBy?: Enumerable<SimplePolicyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SimplePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimplePolicies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimplePolicies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SimplePolicies
    **/
    _count?: true | SimplePolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SimplePolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SimplePolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SimplePolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SimplePolicyMaxAggregateInputType
  }

  export type GetSimplePolicyAggregateType<T extends SimplePolicyAggregateArgs> = {
        [P in keyof T & keyof AggregateSimplePolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSimplePolicy[P]>
      : GetScalarType<T[P], AggregateSimplePolicy[P]>
  }




  export type SimplePolicyGroupByArgs = {
    where?: SimplePolicyWhereInput
    orderBy?: Enumerable<SimplePolicyOrderByWithAggregationInput>
    by: Array<SimplePolicyScalarFieldEnum>
    having?: SimplePolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SimplePolicyCountAggregateInputType | true
    _avg?: SimplePolicyAvgAggregateInputType
    _sum?: SimplePolicySumAggregateInputType
    _min?: SimplePolicyMinAggregateInputType
    _max?: SimplePolicyMaxAggregateInputType
  }


  export type SimplePolicyGroupByOutputType = {
    id: number
    shopId: number
    okay: boolean
    message: string
    _count: SimplePolicyCountAggregateOutputType | null
    _avg: SimplePolicyAvgAggregateOutputType | null
    _sum: SimplePolicySumAggregateOutputType | null
    _min: SimplePolicyMinAggregateOutputType | null
    _max: SimplePolicyMaxAggregateOutputType | null
  }

  type GetSimplePolicyGroupByPayload<T extends SimplePolicyGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SimplePolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SimplePolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SimplePolicyGroupByOutputType[P]>
            : GetScalarType<T[P], SimplePolicyGroupByOutputType[P]>
        }
      >
    >


  export type SimplePolicySelect = {
    policy?: boolean | PolicyArgs
    id?: boolean
    shopId?: boolean
    okay?: boolean
    message?: boolean
  }

  export type SimplePolicyInclude = {
    policy?: boolean | PolicyArgs
  }

  export type SimplePolicyGetPayload<
    S extends boolean | null | undefined | SimplePolicyArgs,
    U = keyof S
      > = S extends true
        ? SimplePolicy
    : S extends undefined
    ? never
    : S extends SimplePolicyArgs | SimplePolicyFindManyArgs
    ?'include' extends U
    ? SimplePolicy  & {
    [P in TrueKeys<S['include']>]:
        P extends 'policy' ? PolicyGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'policy' ? PolicyGetPayload<S['select'][P]> :  P extends keyof SimplePolicy ? SimplePolicy[P] : never
  } 
    : SimplePolicy
  : SimplePolicy


  type SimplePolicyCountArgs = Merge<
    Omit<SimplePolicyFindManyArgs, 'select' | 'include'> & {
      select?: SimplePolicyCountAggregateInputType | true
    }
  >

  export interface SimplePolicyDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one SimplePolicy that matches the filter.
     * @param {SimplePolicyFindUniqueArgs} args - Arguments to find a SimplePolicy
     * @example
     * // Get one SimplePolicy
     * const simplePolicy = await prisma.simplePolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SimplePolicyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SimplePolicyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SimplePolicy'> extends True ? CheckSelect<T, Prisma__SimplePolicyClient<SimplePolicy>, Prisma__SimplePolicyClient<SimplePolicyGetPayload<T>>> : CheckSelect<T, Prisma__SimplePolicyClient<SimplePolicy | null >, Prisma__SimplePolicyClient<SimplePolicyGetPayload<T> | null >>

    /**
     * Find the first SimplePolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimplePolicyFindFirstArgs} args - Arguments to find a SimplePolicy
     * @example
     * // Get one SimplePolicy
     * const simplePolicy = await prisma.simplePolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SimplePolicyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SimplePolicyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SimplePolicy'> extends True ? CheckSelect<T, Prisma__SimplePolicyClient<SimplePolicy>, Prisma__SimplePolicyClient<SimplePolicyGetPayload<T>>> : CheckSelect<T, Prisma__SimplePolicyClient<SimplePolicy | null >, Prisma__SimplePolicyClient<SimplePolicyGetPayload<T> | null >>

    /**
     * Find zero or more SimplePolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimplePolicyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SimplePolicies
     * const simplePolicies = await prisma.simplePolicy.findMany()
     * 
     * // Get first 10 SimplePolicies
     * const simplePolicies = await prisma.simplePolicy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const simplePolicyWithIdOnly = await prisma.simplePolicy.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SimplePolicyFindManyArgs>(
      args?: SelectSubset<T, SimplePolicyFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SimplePolicy>>, PrismaPromise<Array<SimplePolicyGetPayload<T>>>>

    /**
     * Create a SimplePolicy.
     * @param {SimplePolicyCreateArgs} args - Arguments to create a SimplePolicy.
     * @example
     * // Create one SimplePolicy
     * const SimplePolicy = await prisma.simplePolicy.create({
     *   data: {
     *     // ... data to create a SimplePolicy
     *   }
     * })
     * 
    **/
    create<T extends SimplePolicyCreateArgs>(
      args: SelectSubset<T, SimplePolicyCreateArgs>
    ): CheckSelect<T, Prisma__SimplePolicyClient<SimplePolicy>, Prisma__SimplePolicyClient<SimplePolicyGetPayload<T>>>

    /**
     * Create many SimplePolicies.
     *     @param {SimplePolicyCreateManyArgs} args - Arguments to create many SimplePolicies.
     *     @example
     *     // Create many SimplePolicies
     *     const simplePolicy = await prisma.simplePolicy.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SimplePolicyCreateManyArgs>(
      args?: SelectSubset<T, SimplePolicyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SimplePolicy.
     * @param {SimplePolicyDeleteArgs} args - Arguments to delete one SimplePolicy.
     * @example
     * // Delete one SimplePolicy
     * const SimplePolicy = await prisma.simplePolicy.delete({
     *   where: {
     *     // ... filter to delete one SimplePolicy
     *   }
     * })
     * 
    **/
    delete<T extends SimplePolicyDeleteArgs>(
      args: SelectSubset<T, SimplePolicyDeleteArgs>
    ): CheckSelect<T, Prisma__SimplePolicyClient<SimplePolicy>, Prisma__SimplePolicyClient<SimplePolicyGetPayload<T>>>

    /**
     * Update one SimplePolicy.
     * @param {SimplePolicyUpdateArgs} args - Arguments to update one SimplePolicy.
     * @example
     * // Update one SimplePolicy
     * const simplePolicy = await prisma.simplePolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SimplePolicyUpdateArgs>(
      args: SelectSubset<T, SimplePolicyUpdateArgs>
    ): CheckSelect<T, Prisma__SimplePolicyClient<SimplePolicy>, Prisma__SimplePolicyClient<SimplePolicyGetPayload<T>>>

    /**
     * Delete zero or more SimplePolicies.
     * @param {SimplePolicyDeleteManyArgs} args - Arguments to filter SimplePolicies to delete.
     * @example
     * // Delete a few SimplePolicies
     * const { count } = await prisma.simplePolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SimplePolicyDeleteManyArgs>(
      args?: SelectSubset<T, SimplePolicyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SimplePolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimplePolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SimplePolicies
     * const simplePolicy = await prisma.simplePolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SimplePolicyUpdateManyArgs>(
      args: SelectSubset<T, SimplePolicyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SimplePolicy.
     * @param {SimplePolicyUpsertArgs} args - Arguments to update or create a SimplePolicy.
     * @example
     * // Update or create a SimplePolicy
     * const simplePolicy = await prisma.simplePolicy.upsert({
     *   create: {
     *     // ... data to create a SimplePolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SimplePolicy we want to update
     *   }
     * })
    **/
    upsert<T extends SimplePolicyUpsertArgs>(
      args: SelectSubset<T, SimplePolicyUpsertArgs>
    ): CheckSelect<T, Prisma__SimplePolicyClient<SimplePolicy>, Prisma__SimplePolicyClient<SimplePolicyGetPayload<T>>>

    /**
     * Count the number of SimplePolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimplePolicyCountArgs} args - Arguments to filter SimplePolicies to count.
     * @example
     * // Count the number of SimplePolicies
     * const count = await prisma.simplePolicy.count({
     *   where: {
     *     // ... the filter for the SimplePolicies we want to count
     *   }
     * })
    **/
    count<T extends SimplePolicyCountArgs>(
      args?: Subset<T, SimplePolicyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SimplePolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SimplePolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimplePolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SimplePolicyAggregateArgs>(args: Subset<T, SimplePolicyAggregateArgs>): PrismaPromise<GetSimplePolicyAggregateType<T>>

    /**
     * Group by SimplePolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimplePolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SimplePolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SimplePolicyGroupByArgs['orderBy'] }
        : { orderBy?: SimplePolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SimplePolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSimplePolicyGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for SimplePolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SimplePolicyClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    policy<T extends PolicyArgs = {}>(args?: Subset<T, PolicyArgs>): CheckSelect<T, Prisma__PolicyClient<Policy | null >, Prisma__PolicyClient<PolicyGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * SimplePolicy findUnique
   */
  export type SimplePolicyFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the SimplePolicy
     * 
    **/
    select?: SimplePolicySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SimplePolicyInclude | null
    /**
     * Throw an Error if a SimplePolicy can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SimplePolicy to fetch.
     * 
    **/
    where: SimplePolicyWhereUniqueInput
  }


  /**
   * SimplePolicy findFirst
   */
  export type SimplePolicyFindFirstArgs = {
    /**
     * Select specific fields to fetch from the SimplePolicy
     * 
    **/
    select?: SimplePolicySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SimplePolicyInclude | null
    /**
     * Throw an Error if a SimplePolicy can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SimplePolicy to fetch.
     * 
    **/
    where?: SimplePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimplePolicies to fetch.
     * 
    **/
    orderBy?: Enumerable<SimplePolicyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SimplePolicies.
     * 
    **/
    cursor?: SimplePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimplePolicies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimplePolicies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SimplePolicies.
     * 
    **/
    distinct?: Enumerable<SimplePolicyScalarFieldEnum>
  }


  /**
   * SimplePolicy findMany
   */
  export type SimplePolicyFindManyArgs = {
    /**
     * Select specific fields to fetch from the SimplePolicy
     * 
    **/
    select?: SimplePolicySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SimplePolicyInclude | null
    /**
     * Filter, which SimplePolicies to fetch.
     * 
    **/
    where?: SimplePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimplePolicies to fetch.
     * 
    **/
    orderBy?: Enumerable<SimplePolicyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SimplePolicies.
     * 
    **/
    cursor?: SimplePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimplePolicies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimplePolicies.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SimplePolicyScalarFieldEnum>
  }


  /**
   * SimplePolicy create
   */
  export type SimplePolicyCreateArgs = {
    /**
     * Select specific fields to fetch from the SimplePolicy
     * 
    **/
    select?: SimplePolicySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SimplePolicyInclude | null
    /**
     * The data needed to create a SimplePolicy.
     * 
    **/
    data: XOR<SimplePolicyCreateInput, SimplePolicyUncheckedCreateInput>
  }


  /**
   * SimplePolicy createMany
   */
  export type SimplePolicyCreateManyArgs = {
    /**
     * The data used to create many SimplePolicies.
     * 
    **/
    data: Enumerable<SimplePolicyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SimplePolicy update
   */
  export type SimplePolicyUpdateArgs = {
    /**
     * Select specific fields to fetch from the SimplePolicy
     * 
    **/
    select?: SimplePolicySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SimplePolicyInclude | null
    /**
     * The data needed to update a SimplePolicy.
     * 
    **/
    data: XOR<SimplePolicyUpdateInput, SimplePolicyUncheckedUpdateInput>
    /**
     * Choose, which SimplePolicy to update.
     * 
    **/
    where: SimplePolicyWhereUniqueInput
  }


  /**
   * SimplePolicy updateMany
   */
  export type SimplePolicyUpdateManyArgs = {
    /**
     * The data used to update SimplePolicies.
     * 
    **/
    data: XOR<SimplePolicyUpdateManyMutationInput, SimplePolicyUncheckedUpdateManyInput>
    /**
     * Filter which SimplePolicies to update
     * 
    **/
    where?: SimplePolicyWhereInput
  }


  /**
   * SimplePolicy upsert
   */
  export type SimplePolicyUpsertArgs = {
    /**
     * Select specific fields to fetch from the SimplePolicy
     * 
    **/
    select?: SimplePolicySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SimplePolicyInclude | null
    /**
     * The filter to search for the SimplePolicy to update in case it exists.
     * 
    **/
    where: SimplePolicyWhereUniqueInput
    /**
     * In case the SimplePolicy found by the `where` argument doesn't exist, create a new SimplePolicy with this data.
     * 
    **/
    create: XOR<SimplePolicyCreateInput, SimplePolicyUncheckedCreateInput>
    /**
     * In case the SimplePolicy was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SimplePolicyUpdateInput, SimplePolicyUncheckedUpdateInput>
  }


  /**
   * SimplePolicy delete
   */
  export type SimplePolicyDeleteArgs = {
    /**
     * Select specific fields to fetch from the SimplePolicy
     * 
    **/
    select?: SimplePolicySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SimplePolicyInclude | null
    /**
     * Filter which SimplePolicy to delete.
     * 
    **/
    where: SimplePolicyWhereUniqueInput
  }


  /**
   * SimplePolicy deleteMany
   */
  export type SimplePolicyDeleteManyArgs = {
    /**
     * Filter which SimplePolicies to delete
     * 
    **/
    where?: SimplePolicyWhereInput
  }


  /**
   * SimplePolicy without action
   */
  export type SimplePolicyArgs = {
    /**
     * Select specific fields to fetch from the SimplePolicy
     * 
    **/
    select?: SimplePolicySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SimplePolicyInclude | null
  }



  /**
   * Model ConditionalPolicy
   */


  export type AggregateConditionalPolicy = {
    _count: ConditionalPolicyCountAggregateOutputType | null
    _avg: ConditionalPolicyAvgAggregateOutputType | null
    _sum: ConditionalPolicySumAggregateOutputType | null
    _min: ConditionalPolicyMinAggregateOutputType | null
    _max: ConditionalPolicyMaxAggregateOutputType | null
  }

  export type ConditionalPolicyAvgAggregateOutputType = {
    id: number | null
    shopId: number | null
    dependent: number | null
    dependentShopId: number | null
    dependentOn: number | null
    dependentOnShopId: number | null
  }

  export type ConditionalPolicySumAggregateOutputType = {
    id: number | null
    shopId: number | null
    dependent: number | null
    dependentShopId: number | null
    dependentOn: number | null
    dependentOnShopId: number | null
  }

  export type ConditionalPolicyMinAggregateOutputType = {
    id: number | null
    shopId: number | null
    dependent: number | null
    dependentShopId: number | null
    dependentOn: number | null
    dependentOnShopId: number | null
    description: string | null
  }

  export type ConditionalPolicyMaxAggregateOutputType = {
    id: number | null
    shopId: number | null
    dependent: number | null
    dependentShopId: number | null
    dependentOn: number | null
    dependentOnShopId: number | null
    description: string | null
  }

  export type ConditionalPolicyCountAggregateOutputType = {
    id: number
    shopId: number
    dependent: number
    dependentShopId: number
    dependentOn: number
    dependentOnShopId: number
    description: number
    _all: number
  }


  export type ConditionalPolicyAvgAggregateInputType = {
    id?: true
    shopId?: true
    dependent?: true
    dependentShopId?: true
    dependentOn?: true
    dependentOnShopId?: true
  }

  export type ConditionalPolicySumAggregateInputType = {
    id?: true
    shopId?: true
    dependent?: true
    dependentShopId?: true
    dependentOn?: true
    dependentOnShopId?: true
  }

  export type ConditionalPolicyMinAggregateInputType = {
    id?: true
    shopId?: true
    dependent?: true
    dependentShopId?: true
    dependentOn?: true
    dependentOnShopId?: true
    description?: true
  }

  export type ConditionalPolicyMaxAggregateInputType = {
    id?: true
    shopId?: true
    dependent?: true
    dependentShopId?: true
    dependentOn?: true
    dependentOnShopId?: true
    description?: true
  }

  export type ConditionalPolicyCountAggregateInputType = {
    id?: true
    shopId?: true
    dependent?: true
    dependentShopId?: true
    dependentOn?: true
    dependentOnShopId?: true
    description?: true
    _all?: true
  }

  export type ConditionalPolicyAggregateArgs = {
    /**
     * Filter which ConditionalPolicy to aggregate.
     * 
    **/
    where?: ConditionalPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConditionalPolicies to fetch.
     * 
    **/
    orderBy?: Enumerable<ConditionalPolicyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ConditionalPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConditionalPolicies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConditionalPolicies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConditionalPolicies
    **/
    _count?: true | ConditionalPolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConditionalPolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConditionalPolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConditionalPolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConditionalPolicyMaxAggregateInputType
  }

  export type GetConditionalPolicyAggregateType<T extends ConditionalPolicyAggregateArgs> = {
        [P in keyof T & keyof AggregateConditionalPolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConditionalPolicy[P]>
      : GetScalarType<T[P], AggregateConditionalPolicy[P]>
  }




  export type ConditionalPolicyGroupByArgs = {
    where?: ConditionalPolicyWhereInput
    orderBy?: Enumerable<ConditionalPolicyOrderByWithAggregationInput>
    by: Array<ConditionalPolicyScalarFieldEnum>
    having?: ConditionalPolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConditionalPolicyCountAggregateInputType | true
    _avg?: ConditionalPolicyAvgAggregateInputType
    _sum?: ConditionalPolicySumAggregateInputType
    _min?: ConditionalPolicyMinAggregateInputType
    _max?: ConditionalPolicyMaxAggregateInputType
  }


  export type ConditionalPolicyGroupByOutputType = {
    id: number
    shopId: number
    dependent: number
    dependentShopId: number
    dependentOn: number
    dependentOnShopId: number
    description: string
    _count: ConditionalPolicyCountAggregateOutputType | null
    _avg: ConditionalPolicyAvgAggregateOutputType | null
    _sum: ConditionalPolicySumAggregateOutputType | null
    _min: ConditionalPolicyMinAggregateOutputType | null
    _max: ConditionalPolicyMaxAggregateOutputType | null
  }

  type GetConditionalPolicyGroupByPayload<T extends ConditionalPolicyGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ConditionalPolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConditionalPolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConditionalPolicyGroupByOutputType[P]>
            : GetScalarType<T[P], ConditionalPolicyGroupByOutputType[P]>
        }
      >
    >


  export type ConditionalPolicySelect = {
    policy?: boolean | PolicyArgs
    id?: boolean
    shopId?: boolean
    dependent?: boolean
    dependentShopId?: boolean
    dependentOn?: boolean
    dependentOnShopId?: boolean
    description?: boolean
    policyPredicate?: boolean | PolicyPredicateArgs
  }

  export type ConditionalPolicyInclude = {
    policy?: boolean | PolicyArgs
    policyPredicate?: boolean | PolicyPredicateArgs
  }

  export type ConditionalPolicyGetPayload<
    S extends boolean | null | undefined | ConditionalPolicyArgs,
    U = keyof S
      > = S extends true
        ? ConditionalPolicy
    : S extends undefined
    ? never
    : S extends ConditionalPolicyArgs | ConditionalPolicyFindManyArgs
    ?'include' extends U
    ? ConditionalPolicy  & {
    [P in TrueKeys<S['include']>]:
        P extends 'policy' ? PolicyGetPayload<S['include'][P]> :
        P extends 'policyPredicate' ? PolicyPredicateGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'policy' ? PolicyGetPayload<S['select'][P]> :
        P extends 'policyPredicate' ? PolicyPredicateGetPayload<S['select'][P]> | null :  P extends keyof ConditionalPolicy ? ConditionalPolicy[P] : never
  } 
    : ConditionalPolicy
  : ConditionalPolicy


  type ConditionalPolicyCountArgs = Merge<
    Omit<ConditionalPolicyFindManyArgs, 'select' | 'include'> & {
      select?: ConditionalPolicyCountAggregateInputType | true
    }
  >

  export interface ConditionalPolicyDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ConditionalPolicy that matches the filter.
     * @param {ConditionalPolicyFindUniqueArgs} args - Arguments to find a ConditionalPolicy
     * @example
     * // Get one ConditionalPolicy
     * const conditionalPolicy = await prisma.conditionalPolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConditionalPolicyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ConditionalPolicyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ConditionalPolicy'> extends True ? CheckSelect<T, Prisma__ConditionalPolicyClient<ConditionalPolicy>, Prisma__ConditionalPolicyClient<ConditionalPolicyGetPayload<T>>> : CheckSelect<T, Prisma__ConditionalPolicyClient<ConditionalPolicy | null >, Prisma__ConditionalPolicyClient<ConditionalPolicyGetPayload<T> | null >>

    /**
     * Find the first ConditionalPolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionalPolicyFindFirstArgs} args - Arguments to find a ConditionalPolicy
     * @example
     * // Get one ConditionalPolicy
     * const conditionalPolicy = await prisma.conditionalPolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConditionalPolicyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ConditionalPolicyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ConditionalPolicy'> extends True ? CheckSelect<T, Prisma__ConditionalPolicyClient<ConditionalPolicy>, Prisma__ConditionalPolicyClient<ConditionalPolicyGetPayload<T>>> : CheckSelect<T, Prisma__ConditionalPolicyClient<ConditionalPolicy | null >, Prisma__ConditionalPolicyClient<ConditionalPolicyGetPayload<T> | null >>

    /**
     * Find zero or more ConditionalPolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionalPolicyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConditionalPolicies
     * const conditionalPolicies = await prisma.conditionalPolicy.findMany()
     * 
     * // Get first 10 ConditionalPolicies
     * const conditionalPolicies = await prisma.conditionalPolicy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conditionalPolicyWithIdOnly = await prisma.conditionalPolicy.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConditionalPolicyFindManyArgs>(
      args?: SelectSubset<T, ConditionalPolicyFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ConditionalPolicy>>, PrismaPromise<Array<ConditionalPolicyGetPayload<T>>>>

    /**
     * Create a ConditionalPolicy.
     * @param {ConditionalPolicyCreateArgs} args - Arguments to create a ConditionalPolicy.
     * @example
     * // Create one ConditionalPolicy
     * const ConditionalPolicy = await prisma.conditionalPolicy.create({
     *   data: {
     *     // ... data to create a ConditionalPolicy
     *   }
     * })
     * 
    **/
    create<T extends ConditionalPolicyCreateArgs>(
      args: SelectSubset<T, ConditionalPolicyCreateArgs>
    ): CheckSelect<T, Prisma__ConditionalPolicyClient<ConditionalPolicy>, Prisma__ConditionalPolicyClient<ConditionalPolicyGetPayload<T>>>

    /**
     * Create many ConditionalPolicies.
     *     @param {ConditionalPolicyCreateManyArgs} args - Arguments to create many ConditionalPolicies.
     *     @example
     *     // Create many ConditionalPolicies
     *     const conditionalPolicy = await prisma.conditionalPolicy.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConditionalPolicyCreateManyArgs>(
      args?: SelectSubset<T, ConditionalPolicyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ConditionalPolicy.
     * @param {ConditionalPolicyDeleteArgs} args - Arguments to delete one ConditionalPolicy.
     * @example
     * // Delete one ConditionalPolicy
     * const ConditionalPolicy = await prisma.conditionalPolicy.delete({
     *   where: {
     *     // ... filter to delete one ConditionalPolicy
     *   }
     * })
     * 
    **/
    delete<T extends ConditionalPolicyDeleteArgs>(
      args: SelectSubset<T, ConditionalPolicyDeleteArgs>
    ): CheckSelect<T, Prisma__ConditionalPolicyClient<ConditionalPolicy>, Prisma__ConditionalPolicyClient<ConditionalPolicyGetPayload<T>>>

    /**
     * Update one ConditionalPolicy.
     * @param {ConditionalPolicyUpdateArgs} args - Arguments to update one ConditionalPolicy.
     * @example
     * // Update one ConditionalPolicy
     * const conditionalPolicy = await prisma.conditionalPolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConditionalPolicyUpdateArgs>(
      args: SelectSubset<T, ConditionalPolicyUpdateArgs>
    ): CheckSelect<T, Prisma__ConditionalPolicyClient<ConditionalPolicy>, Prisma__ConditionalPolicyClient<ConditionalPolicyGetPayload<T>>>

    /**
     * Delete zero or more ConditionalPolicies.
     * @param {ConditionalPolicyDeleteManyArgs} args - Arguments to filter ConditionalPolicies to delete.
     * @example
     * // Delete a few ConditionalPolicies
     * const { count } = await prisma.conditionalPolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConditionalPolicyDeleteManyArgs>(
      args?: SelectSubset<T, ConditionalPolicyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConditionalPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionalPolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConditionalPolicies
     * const conditionalPolicy = await prisma.conditionalPolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConditionalPolicyUpdateManyArgs>(
      args: SelectSubset<T, ConditionalPolicyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ConditionalPolicy.
     * @param {ConditionalPolicyUpsertArgs} args - Arguments to update or create a ConditionalPolicy.
     * @example
     * // Update or create a ConditionalPolicy
     * const conditionalPolicy = await prisma.conditionalPolicy.upsert({
     *   create: {
     *     // ... data to create a ConditionalPolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConditionalPolicy we want to update
     *   }
     * })
    **/
    upsert<T extends ConditionalPolicyUpsertArgs>(
      args: SelectSubset<T, ConditionalPolicyUpsertArgs>
    ): CheckSelect<T, Prisma__ConditionalPolicyClient<ConditionalPolicy>, Prisma__ConditionalPolicyClient<ConditionalPolicyGetPayload<T>>>

    /**
     * Count the number of ConditionalPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionalPolicyCountArgs} args - Arguments to filter ConditionalPolicies to count.
     * @example
     * // Count the number of ConditionalPolicies
     * const count = await prisma.conditionalPolicy.count({
     *   where: {
     *     // ... the filter for the ConditionalPolicies we want to count
     *   }
     * })
    **/
    count<T extends ConditionalPolicyCountArgs>(
      args?: Subset<T, ConditionalPolicyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConditionalPolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConditionalPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionalPolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConditionalPolicyAggregateArgs>(args: Subset<T, ConditionalPolicyAggregateArgs>): PrismaPromise<GetConditionalPolicyAggregateType<T>>

    /**
     * Group by ConditionalPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionalPolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConditionalPolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConditionalPolicyGroupByArgs['orderBy'] }
        : { orderBy?: ConditionalPolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConditionalPolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConditionalPolicyGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConditionalPolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ConditionalPolicyClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    policy<T extends PolicyArgs = {}>(args?: Subset<T, PolicyArgs>): CheckSelect<T, Prisma__PolicyClient<Policy | null >, Prisma__PolicyClient<PolicyGetPayload<T> | null >>;

    policyPredicate<T extends PolicyPredicateArgs = {}>(args?: Subset<T, PolicyPredicateArgs>): CheckSelect<T, Prisma__PolicyPredicateClient<PolicyPredicate | null >, Prisma__PolicyPredicateClient<PolicyPredicateGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ConditionalPolicy findUnique
   */
  export type ConditionalPolicyFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ConditionalPolicy
     * 
    **/
    select?: ConditionalPolicySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConditionalPolicyInclude | null
    /**
     * Throw an Error if a ConditionalPolicy can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ConditionalPolicy to fetch.
     * 
    **/
    where: ConditionalPolicyWhereUniqueInput
  }


  /**
   * ConditionalPolicy findFirst
   */
  export type ConditionalPolicyFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ConditionalPolicy
     * 
    **/
    select?: ConditionalPolicySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConditionalPolicyInclude | null
    /**
     * Throw an Error if a ConditionalPolicy can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ConditionalPolicy to fetch.
     * 
    **/
    where?: ConditionalPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConditionalPolicies to fetch.
     * 
    **/
    orderBy?: Enumerable<ConditionalPolicyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConditionalPolicies.
     * 
    **/
    cursor?: ConditionalPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConditionalPolicies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConditionalPolicies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConditionalPolicies.
     * 
    **/
    distinct?: Enumerable<ConditionalPolicyScalarFieldEnum>
  }


  /**
   * ConditionalPolicy findMany
   */
  export type ConditionalPolicyFindManyArgs = {
    /**
     * Select specific fields to fetch from the ConditionalPolicy
     * 
    **/
    select?: ConditionalPolicySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConditionalPolicyInclude | null
    /**
     * Filter, which ConditionalPolicies to fetch.
     * 
    **/
    where?: ConditionalPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConditionalPolicies to fetch.
     * 
    **/
    orderBy?: Enumerable<ConditionalPolicyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConditionalPolicies.
     * 
    **/
    cursor?: ConditionalPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConditionalPolicies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConditionalPolicies.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ConditionalPolicyScalarFieldEnum>
  }


  /**
   * ConditionalPolicy create
   */
  export type ConditionalPolicyCreateArgs = {
    /**
     * Select specific fields to fetch from the ConditionalPolicy
     * 
    **/
    select?: ConditionalPolicySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConditionalPolicyInclude | null
    /**
     * The data needed to create a ConditionalPolicy.
     * 
    **/
    data: XOR<ConditionalPolicyCreateInput, ConditionalPolicyUncheckedCreateInput>
  }


  /**
   * ConditionalPolicy createMany
   */
  export type ConditionalPolicyCreateManyArgs = {
    /**
     * The data used to create many ConditionalPolicies.
     * 
    **/
    data: Enumerable<ConditionalPolicyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ConditionalPolicy update
   */
  export type ConditionalPolicyUpdateArgs = {
    /**
     * Select specific fields to fetch from the ConditionalPolicy
     * 
    **/
    select?: ConditionalPolicySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConditionalPolicyInclude | null
    /**
     * The data needed to update a ConditionalPolicy.
     * 
    **/
    data: XOR<ConditionalPolicyUpdateInput, ConditionalPolicyUncheckedUpdateInput>
    /**
     * Choose, which ConditionalPolicy to update.
     * 
    **/
    where: ConditionalPolicyWhereUniqueInput
  }


  /**
   * ConditionalPolicy updateMany
   */
  export type ConditionalPolicyUpdateManyArgs = {
    /**
     * The data used to update ConditionalPolicies.
     * 
    **/
    data: XOR<ConditionalPolicyUpdateManyMutationInput, ConditionalPolicyUncheckedUpdateManyInput>
    /**
     * Filter which ConditionalPolicies to update
     * 
    **/
    where?: ConditionalPolicyWhereInput
  }


  /**
   * ConditionalPolicy upsert
   */
  export type ConditionalPolicyUpsertArgs = {
    /**
     * Select specific fields to fetch from the ConditionalPolicy
     * 
    **/
    select?: ConditionalPolicySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConditionalPolicyInclude | null
    /**
     * The filter to search for the ConditionalPolicy to update in case it exists.
     * 
    **/
    where: ConditionalPolicyWhereUniqueInput
    /**
     * In case the ConditionalPolicy found by the `where` argument doesn't exist, create a new ConditionalPolicy with this data.
     * 
    **/
    create: XOR<ConditionalPolicyCreateInput, ConditionalPolicyUncheckedCreateInput>
    /**
     * In case the ConditionalPolicy was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ConditionalPolicyUpdateInput, ConditionalPolicyUncheckedUpdateInput>
  }


  /**
   * ConditionalPolicy delete
   */
  export type ConditionalPolicyDeleteArgs = {
    /**
     * Select specific fields to fetch from the ConditionalPolicy
     * 
    **/
    select?: ConditionalPolicySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConditionalPolicyInclude | null
    /**
     * Filter which ConditionalPolicy to delete.
     * 
    **/
    where: ConditionalPolicyWhereUniqueInput
  }


  /**
   * ConditionalPolicy deleteMany
   */
  export type ConditionalPolicyDeleteManyArgs = {
    /**
     * Filter which ConditionalPolicies to delete
     * 
    **/
    where?: ConditionalPolicyWhereInput
  }


  /**
   * ConditionalPolicy without action
   */
  export type ConditionalPolicyArgs = {
    /**
     * Select specific fields to fetch from the ConditionalPolicy
     * 
    **/
    select?: ConditionalPolicySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConditionalPolicyInclude | null
  }



  /**
   * Model PolicyPredicate
   */


  export type AggregatePolicyPredicate = {
    _count: PolicyPredicateCountAggregateOutputType | null
    _avg: PolicyPredicateAvgAggregateOutputType | null
    _sum: PolicyPredicateSumAggregateOutputType | null
    _min: PolicyPredicateMinAggregateOutputType | null
    _max: PolicyPredicateMaxAggregateOutputType | null
  }

  export type PolicyPredicateAvgAggregateOutputType = {
    policyId: number | null
    shopId: number | null
    value: number | null
    productId: number | null
  }

  export type PolicyPredicateSumAggregateOutputType = {
    policyId: number | null
    shopId: number | null
    value: number | null
    productId: number | null
  }

  export type PolicyPredicateMinAggregateOutputType = {
    policyId: number | null
    shopId: number | null
    policyType: SimplePolicyType | null
    relation: RelationType | null
    value: number | null
    description: string | null
    productId: number | null
    productCategory: ProductCategory | null
    guest: string | null
  }

  export type PolicyPredicateMaxAggregateOutputType = {
    policyId: number | null
    shopId: number | null
    policyType: SimplePolicyType | null
    relation: RelationType | null
    value: number | null
    description: string | null
    productId: number | null
    productCategory: ProductCategory | null
    guest: string | null
  }

  export type PolicyPredicateCountAggregateOutputType = {
    policyId: number
    shopId: number
    policyType: number
    relation: number
    value: number
    description: number
    productId: number
    productCategory: number
    guest: number
    _all: number
  }


  export type PolicyPredicateAvgAggregateInputType = {
    policyId?: true
    shopId?: true
    value?: true
    productId?: true
  }

  export type PolicyPredicateSumAggregateInputType = {
    policyId?: true
    shopId?: true
    value?: true
    productId?: true
  }

  export type PolicyPredicateMinAggregateInputType = {
    policyId?: true
    shopId?: true
    policyType?: true
    relation?: true
    value?: true
    description?: true
    productId?: true
    productCategory?: true
    guest?: true
  }

  export type PolicyPredicateMaxAggregateInputType = {
    policyId?: true
    shopId?: true
    policyType?: true
    relation?: true
    value?: true
    description?: true
    productId?: true
    productCategory?: true
    guest?: true
  }

  export type PolicyPredicateCountAggregateInputType = {
    policyId?: true
    shopId?: true
    policyType?: true
    relation?: true
    value?: true
    description?: true
    productId?: true
    productCategory?: true
    guest?: true
    _all?: true
  }

  export type PolicyPredicateAggregateArgs = {
    /**
     * Filter which PolicyPredicate to aggregate.
     * 
    **/
    where?: PolicyPredicateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PolicyPredicates to fetch.
     * 
    **/
    orderBy?: Enumerable<PolicyPredicateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PolicyPredicateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PolicyPredicates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PolicyPredicates.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PolicyPredicates
    **/
    _count?: true | PolicyPredicateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PolicyPredicateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PolicyPredicateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PolicyPredicateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PolicyPredicateMaxAggregateInputType
  }

  export type GetPolicyPredicateAggregateType<T extends PolicyPredicateAggregateArgs> = {
        [P in keyof T & keyof AggregatePolicyPredicate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePolicyPredicate[P]>
      : GetScalarType<T[P], AggregatePolicyPredicate[P]>
  }




  export type PolicyPredicateGroupByArgs = {
    where?: PolicyPredicateWhereInput
    orderBy?: Enumerable<PolicyPredicateOrderByWithAggregationInput>
    by: Array<PolicyPredicateScalarFieldEnum>
    having?: PolicyPredicateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PolicyPredicateCountAggregateInputType | true
    _avg?: PolicyPredicateAvgAggregateInputType
    _sum?: PolicyPredicateSumAggregateInputType
    _min?: PolicyPredicateMinAggregateInputType
    _max?: PolicyPredicateMaxAggregateInputType
  }


  export type PolicyPredicateGroupByOutputType = {
    policyId: number
    shopId: number
    policyType: SimplePolicyType
    relation: RelationType
    value: number
    description: string
    productId: number | null
    productCategory: ProductCategory | null
    guest: string | null
    _count: PolicyPredicateCountAggregateOutputType | null
    _avg: PolicyPredicateAvgAggregateOutputType | null
    _sum: PolicyPredicateSumAggregateOutputType | null
    _min: PolicyPredicateMinAggregateOutputType | null
    _max: PolicyPredicateMaxAggregateOutputType | null
  }

  type GetPolicyPredicateGroupByPayload<T extends PolicyPredicateGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PolicyPredicateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PolicyPredicateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PolicyPredicateGroupByOutputType[P]>
            : GetScalarType<T[P], PolicyPredicateGroupByOutputType[P]>
        }
      >
    >


  export type PolicyPredicateSelect = {
    policy?: boolean | ConditionalPolicyArgs
    policyId?: boolean
    shopId?: boolean
    policyType?: boolean
    relation?: boolean
    value?: boolean
    description?: boolean
    productId?: boolean
    productCategory?: boolean
    guest?: boolean
  }

  export type PolicyPredicateInclude = {
    policy?: boolean | ConditionalPolicyArgs
  }

  export type PolicyPredicateGetPayload<
    S extends boolean | null | undefined | PolicyPredicateArgs,
    U = keyof S
      > = S extends true
        ? PolicyPredicate
    : S extends undefined
    ? never
    : S extends PolicyPredicateArgs | PolicyPredicateFindManyArgs
    ?'include' extends U
    ? PolicyPredicate  & {
    [P in TrueKeys<S['include']>]:
        P extends 'policy' ? ConditionalPolicyGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'policy' ? ConditionalPolicyGetPayload<S['select'][P]> :  P extends keyof PolicyPredicate ? PolicyPredicate[P] : never
  } 
    : PolicyPredicate
  : PolicyPredicate


  type PolicyPredicateCountArgs = Merge<
    Omit<PolicyPredicateFindManyArgs, 'select' | 'include'> & {
      select?: PolicyPredicateCountAggregateInputType | true
    }
  >

  export interface PolicyPredicateDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PolicyPredicate that matches the filter.
     * @param {PolicyPredicateFindUniqueArgs} args - Arguments to find a PolicyPredicate
     * @example
     * // Get one PolicyPredicate
     * const policyPredicate = await prisma.policyPredicate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PolicyPredicateFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PolicyPredicateFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PolicyPredicate'> extends True ? CheckSelect<T, Prisma__PolicyPredicateClient<PolicyPredicate>, Prisma__PolicyPredicateClient<PolicyPredicateGetPayload<T>>> : CheckSelect<T, Prisma__PolicyPredicateClient<PolicyPredicate | null >, Prisma__PolicyPredicateClient<PolicyPredicateGetPayload<T> | null >>

    /**
     * Find the first PolicyPredicate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyPredicateFindFirstArgs} args - Arguments to find a PolicyPredicate
     * @example
     * // Get one PolicyPredicate
     * const policyPredicate = await prisma.policyPredicate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PolicyPredicateFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PolicyPredicateFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PolicyPredicate'> extends True ? CheckSelect<T, Prisma__PolicyPredicateClient<PolicyPredicate>, Prisma__PolicyPredicateClient<PolicyPredicateGetPayload<T>>> : CheckSelect<T, Prisma__PolicyPredicateClient<PolicyPredicate | null >, Prisma__PolicyPredicateClient<PolicyPredicateGetPayload<T> | null >>

    /**
     * Find zero or more PolicyPredicates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyPredicateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PolicyPredicates
     * const policyPredicates = await prisma.policyPredicate.findMany()
     * 
     * // Get first 10 PolicyPredicates
     * const policyPredicates = await prisma.policyPredicate.findMany({ take: 10 })
     * 
     * // Only select the `policyId`
     * const policyPredicateWithPolicyIdOnly = await prisma.policyPredicate.findMany({ select: { policyId: true } })
     * 
    **/
    findMany<T extends PolicyPredicateFindManyArgs>(
      args?: SelectSubset<T, PolicyPredicateFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PolicyPredicate>>, PrismaPromise<Array<PolicyPredicateGetPayload<T>>>>

    /**
     * Create a PolicyPredicate.
     * @param {PolicyPredicateCreateArgs} args - Arguments to create a PolicyPredicate.
     * @example
     * // Create one PolicyPredicate
     * const PolicyPredicate = await prisma.policyPredicate.create({
     *   data: {
     *     // ... data to create a PolicyPredicate
     *   }
     * })
     * 
    **/
    create<T extends PolicyPredicateCreateArgs>(
      args: SelectSubset<T, PolicyPredicateCreateArgs>
    ): CheckSelect<T, Prisma__PolicyPredicateClient<PolicyPredicate>, Prisma__PolicyPredicateClient<PolicyPredicateGetPayload<T>>>

    /**
     * Create many PolicyPredicates.
     *     @param {PolicyPredicateCreateManyArgs} args - Arguments to create many PolicyPredicates.
     *     @example
     *     // Create many PolicyPredicates
     *     const policyPredicate = await prisma.policyPredicate.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PolicyPredicateCreateManyArgs>(
      args?: SelectSubset<T, PolicyPredicateCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PolicyPredicate.
     * @param {PolicyPredicateDeleteArgs} args - Arguments to delete one PolicyPredicate.
     * @example
     * // Delete one PolicyPredicate
     * const PolicyPredicate = await prisma.policyPredicate.delete({
     *   where: {
     *     // ... filter to delete one PolicyPredicate
     *   }
     * })
     * 
    **/
    delete<T extends PolicyPredicateDeleteArgs>(
      args: SelectSubset<T, PolicyPredicateDeleteArgs>
    ): CheckSelect<T, Prisma__PolicyPredicateClient<PolicyPredicate>, Prisma__PolicyPredicateClient<PolicyPredicateGetPayload<T>>>

    /**
     * Update one PolicyPredicate.
     * @param {PolicyPredicateUpdateArgs} args - Arguments to update one PolicyPredicate.
     * @example
     * // Update one PolicyPredicate
     * const policyPredicate = await prisma.policyPredicate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PolicyPredicateUpdateArgs>(
      args: SelectSubset<T, PolicyPredicateUpdateArgs>
    ): CheckSelect<T, Prisma__PolicyPredicateClient<PolicyPredicate>, Prisma__PolicyPredicateClient<PolicyPredicateGetPayload<T>>>

    /**
     * Delete zero or more PolicyPredicates.
     * @param {PolicyPredicateDeleteManyArgs} args - Arguments to filter PolicyPredicates to delete.
     * @example
     * // Delete a few PolicyPredicates
     * const { count } = await prisma.policyPredicate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PolicyPredicateDeleteManyArgs>(
      args?: SelectSubset<T, PolicyPredicateDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PolicyPredicates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyPredicateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PolicyPredicates
     * const policyPredicate = await prisma.policyPredicate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PolicyPredicateUpdateManyArgs>(
      args: SelectSubset<T, PolicyPredicateUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PolicyPredicate.
     * @param {PolicyPredicateUpsertArgs} args - Arguments to update or create a PolicyPredicate.
     * @example
     * // Update or create a PolicyPredicate
     * const policyPredicate = await prisma.policyPredicate.upsert({
     *   create: {
     *     // ... data to create a PolicyPredicate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PolicyPredicate we want to update
     *   }
     * })
    **/
    upsert<T extends PolicyPredicateUpsertArgs>(
      args: SelectSubset<T, PolicyPredicateUpsertArgs>
    ): CheckSelect<T, Prisma__PolicyPredicateClient<PolicyPredicate>, Prisma__PolicyPredicateClient<PolicyPredicateGetPayload<T>>>

    /**
     * Count the number of PolicyPredicates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyPredicateCountArgs} args - Arguments to filter PolicyPredicates to count.
     * @example
     * // Count the number of PolicyPredicates
     * const count = await prisma.policyPredicate.count({
     *   where: {
     *     // ... the filter for the PolicyPredicates we want to count
     *   }
     * })
    **/
    count<T extends PolicyPredicateCountArgs>(
      args?: Subset<T, PolicyPredicateCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PolicyPredicateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PolicyPredicate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyPredicateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PolicyPredicateAggregateArgs>(args: Subset<T, PolicyPredicateAggregateArgs>): PrismaPromise<GetPolicyPredicateAggregateType<T>>

    /**
     * Group by PolicyPredicate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyPredicateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PolicyPredicateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PolicyPredicateGroupByArgs['orderBy'] }
        : { orderBy?: PolicyPredicateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PolicyPredicateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPolicyPredicateGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for PolicyPredicate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PolicyPredicateClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    policy<T extends ConditionalPolicyArgs = {}>(args?: Subset<T, ConditionalPolicyArgs>): CheckSelect<T, Prisma__ConditionalPolicyClient<ConditionalPolicy | null >, Prisma__ConditionalPolicyClient<ConditionalPolicyGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PolicyPredicate findUnique
   */
  export type PolicyPredicateFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PolicyPredicate
     * 
    **/
    select?: PolicyPredicateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PolicyPredicateInclude | null
    /**
     * Throw an Error if a PolicyPredicate can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PolicyPredicate to fetch.
     * 
    **/
    where: PolicyPredicateWhereUniqueInput
  }


  /**
   * PolicyPredicate findFirst
   */
  export type PolicyPredicateFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PolicyPredicate
     * 
    **/
    select?: PolicyPredicateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PolicyPredicateInclude | null
    /**
     * Throw an Error if a PolicyPredicate can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PolicyPredicate to fetch.
     * 
    **/
    where?: PolicyPredicateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PolicyPredicates to fetch.
     * 
    **/
    orderBy?: Enumerable<PolicyPredicateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PolicyPredicates.
     * 
    **/
    cursor?: PolicyPredicateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PolicyPredicates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PolicyPredicates.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PolicyPredicates.
     * 
    **/
    distinct?: Enumerable<PolicyPredicateScalarFieldEnum>
  }


  /**
   * PolicyPredicate findMany
   */
  export type PolicyPredicateFindManyArgs = {
    /**
     * Select specific fields to fetch from the PolicyPredicate
     * 
    **/
    select?: PolicyPredicateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PolicyPredicateInclude | null
    /**
     * Filter, which PolicyPredicates to fetch.
     * 
    **/
    where?: PolicyPredicateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PolicyPredicates to fetch.
     * 
    **/
    orderBy?: Enumerable<PolicyPredicateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PolicyPredicates.
     * 
    **/
    cursor?: PolicyPredicateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PolicyPredicates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PolicyPredicates.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PolicyPredicateScalarFieldEnum>
  }


  /**
   * PolicyPredicate create
   */
  export type PolicyPredicateCreateArgs = {
    /**
     * Select specific fields to fetch from the PolicyPredicate
     * 
    **/
    select?: PolicyPredicateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PolicyPredicateInclude | null
    /**
     * The data needed to create a PolicyPredicate.
     * 
    **/
    data: XOR<PolicyPredicateCreateInput, PolicyPredicateUncheckedCreateInput>
  }


  /**
   * PolicyPredicate createMany
   */
  export type PolicyPredicateCreateManyArgs = {
    /**
     * The data used to create many PolicyPredicates.
     * 
    **/
    data: Enumerable<PolicyPredicateCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PolicyPredicate update
   */
  export type PolicyPredicateUpdateArgs = {
    /**
     * Select specific fields to fetch from the PolicyPredicate
     * 
    **/
    select?: PolicyPredicateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PolicyPredicateInclude | null
    /**
     * The data needed to update a PolicyPredicate.
     * 
    **/
    data: XOR<PolicyPredicateUpdateInput, PolicyPredicateUncheckedUpdateInput>
    /**
     * Choose, which PolicyPredicate to update.
     * 
    **/
    where: PolicyPredicateWhereUniqueInput
  }


  /**
   * PolicyPredicate updateMany
   */
  export type PolicyPredicateUpdateManyArgs = {
    /**
     * The data used to update PolicyPredicates.
     * 
    **/
    data: XOR<PolicyPredicateUpdateManyMutationInput, PolicyPredicateUncheckedUpdateManyInput>
    /**
     * Filter which PolicyPredicates to update
     * 
    **/
    where?: PolicyPredicateWhereInput
  }


  /**
   * PolicyPredicate upsert
   */
  export type PolicyPredicateUpsertArgs = {
    /**
     * Select specific fields to fetch from the PolicyPredicate
     * 
    **/
    select?: PolicyPredicateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PolicyPredicateInclude | null
    /**
     * The filter to search for the PolicyPredicate to update in case it exists.
     * 
    **/
    where: PolicyPredicateWhereUniqueInput
    /**
     * In case the PolicyPredicate found by the `where` argument doesn't exist, create a new PolicyPredicate with this data.
     * 
    **/
    create: XOR<PolicyPredicateCreateInput, PolicyPredicateUncheckedCreateInput>
    /**
     * In case the PolicyPredicate was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PolicyPredicateUpdateInput, PolicyPredicateUncheckedUpdateInput>
  }


  /**
   * PolicyPredicate delete
   */
  export type PolicyPredicateDeleteArgs = {
    /**
     * Select specific fields to fetch from the PolicyPredicate
     * 
    **/
    select?: PolicyPredicateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PolicyPredicateInclude | null
    /**
     * Filter which PolicyPredicate to delete.
     * 
    **/
    where: PolicyPredicateWhereUniqueInput
  }


  /**
   * PolicyPredicate deleteMany
   */
  export type PolicyPredicateDeleteManyArgs = {
    /**
     * Filter which PolicyPredicates to delete
     * 
    **/
    where?: PolicyPredicateWhereInput
  }


  /**
   * PolicyPredicate without action
   */
  export type PolicyPredicateArgs = {
    /**
     * Select specific fields to fetch from the PolicyPredicate
     * 
    **/
    select?: PolicyPredicateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PolicyPredicateInclude | null
  }



  /**
   * Model LogicalPolicy
   */


  export type AggregateLogicalPolicy = {
    _count: LogicalPolicyCountAggregateOutputType | null
    _avg: LogicalPolicyAvgAggregateOutputType | null
    _sum: LogicalPolicySumAggregateOutputType | null
    _min: LogicalPolicyMinAggregateOutputType | null
    _max: LogicalPolicyMaxAggregateOutputType | null
  }

  export type LogicalPolicyAvgAggregateOutputType = {
    id: number | null
    shopId: number | null
  }

  export type LogicalPolicySumAggregateOutputType = {
    id: number | null
    shopId: number | null
  }

  export type LogicalPolicyMinAggregateOutputType = {
    id: number | null
    shopId: number | null
    description: string | null
    purchasePoliciesRelation: PurchasePoliciesRelation | null
  }

  export type LogicalPolicyMaxAggregateOutputType = {
    id: number | null
    shopId: number | null
    description: string | null
    purchasePoliciesRelation: PurchasePoliciesRelation | null
  }

  export type LogicalPolicyCountAggregateOutputType = {
    id: number
    shopId: number
    description: number
    purchasePoliciesRelation: number
    _all: number
  }


  export type LogicalPolicyAvgAggregateInputType = {
    id?: true
    shopId?: true
  }

  export type LogicalPolicySumAggregateInputType = {
    id?: true
    shopId?: true
  }

  export type LogicalPolicyMinAggregateInputType = {
    id?: true
    shopId?: true
    description?: true
    purchasePoliciesRelation?: true
  }

  export type LogicalPolicyMaxAggregateInputType = {
    id?: true
    shopId?: true
    description?: true
    purchasePoliciesRelation?: true
  }

  export type LogicalPolicyCountAggregateInputType = {
    id?: true
    shopId?: true
    description?: true
    purchasePoliciesRelation?: true
    _all?: true
  }

  export type LogicalPolicyAggregateArgs = {
    /**
     * Filter which LogicalPolicy to aggregate.
     * 
    **/
    where?: LogicalPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogicalPolicies to fetch.
     * 
    **/
    orderBy?: Enumerable<LogicalPolicyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: LogicalPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogicalPolicies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogicalPolicies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LogicalPolicies
    **/
    _count?: true | LogicalPolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogicalPolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogicalPolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogicalPolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogicalPolicyMaxAggregateInputType
  }

  export type GetLogicalPolicyAggregateType<T extends LogicalPolicyAggregateArgs> = {
        [P in keyof T & keyof AggregateLogicalPolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogicalPolicy[P]>
      : GetScalarType<T[P], AggregateLogicalPolicy[P]>
  }




  export type LogicalPolicyGroupByArgs = {
    where?: LogicalPolicyWhereInput
    orderBy?: Enumerable<LogicalPolicyOrderByWithAggregationInput>
    by: Array<LogicalPolicyScalarFieldEnum>
    having?: LogicalPolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogicalPolicyCountAggregateInputType | true
    _avg?: LogicalPolicyAvgAggregateInputType
    _sum?: LogicalPolicySumAggregateInputType
    _min?: LogicalPolicyMinAggregateInputType
    _max?: LogicalPolicyMaxAggregateInputType
  }


  export type LogicalPolicyGroupByOutputType = {
    id: number
    shopId: number
    description: string
    purchasePoliciesRelation: PurchasePoliciesRelation
    _count: LogicalPolicyCountAggregateOutputType | null
    _avg: LogicalPolicyAvgAggregateOutputType | null
    _sum: LogicalPolicySumAggregateOutputType | null
    _min: LogicalPolicyMinAggregateOutputType | null
    _max: LogicalPolicyMaxAggregateOutputType | null
  }

  type GetLogicalPolicyGroupByPayload<T extends LogicalPolicyGroupByArgs> = PrismaPromise<
    Array<
      PickArray<LogicalPolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogicalPolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogicalPolicyGroupByOutputType[P]>
            : GetScalarType<T[P], LogicalPolicyGroupByOutputType[P]>
        }
      >
    >


  export type LogicalPolicySelect = {
    policy?: boolean | PolicyArgs
    id?: boolean
    shopId?: boolean
    description?: boolean
    purchasePoliciesRelation?: boolean
    policies?: boolean | PolicyInContainerFindManyArgs
    _count?: boolean | LogicalPolicyCountOutputTypeArgs
  }

  export type LogicalPolicyInclude = {
    policy?: boolean | PolicyArgs
    policies?: boolean | PolicyInContainerFindManyArgs
    _count?: boolean | LogicalPolicyCountOutputTypeArgs
  }

  export type LogicalPolicyGetPayload<
    S extends boolean | null | undefined | LogicalPolicyArgs,
    U = keyof S
      > = S extends true
        ? LogicalPolicy
    : S extends undefined
    ? never
    : S extends LogicalPolicyArgs | LogicalPolicyFindManyArgs
    ?'include' extends U
    ? LogicalPolicy  & {
    [P in TrueKeys<S['include']>]:
        P extends 'policy' ? PolicyGetPayload<S['include'][P]> :
        P extends 'policies' ? Array < PolicyInContainerGetPayload<S['include'][P]>>  :
        P extends '_count' ? LogicalPolicyCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'policy' ? PolicyGetPayload<S['select'][P]> :
        P extends 'policies' ? Array < PolicyInContainerGetPayload<S['select'][P]>>  :
        P extends '_count' ? LogicalPolicyCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof LogicalPolicy ? LogicalPolicy[P] : never
  } 
    : LogicalPolicy
  : LogicalPolicy


  type LogicalPolicyCountArgs = Merge<
    Omit<LogicalPolicyFindManyArgs, 'select' | 'include'> & {
      select?: LogicalPolicyCountAggregateInputType | true
    }
  >

  export interface LogicalPolicyDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one LogicalPolicy that matches the filter.
     * @param {LogicalPolicyFindUniqueArgs} args - Arguments to find a LogicalPolicy
     * @example
     * // Get one LogicalPolicy
     * const logicalPolicy = await prisma.logicalPolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LogicalPolicyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LogicalPolicyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LogicalPolicy'> extends True ? CheckSelect<T, Prisma__LogicalPolicyClient<LogicalPolicy>, Prisma__LogicalPolicyClient<LogicalPolicyGetPayload<T>>> : CheckSelect<T, Prisma__LogicalPolicyClient<LogicalPolicy | null >, Prisma__LogicalPolicyClient<LogicalPolicyGetPayload<T> | null >>

    /**
     * Find the first LogicalPolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogicalPolicyFindFirstArgs} args - Arguments to find a LogicalPolicy
     * @example
     * // Get one LogicalPolicy
     * const logicalPolicy = await prisma.logicalPolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LogicalPolicyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LogicalPolicyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LogicalPolicy'> extends True ? CheckSelect<T, Prisma__LogicalPolicyClient<LogicalPolicy>, Prisma__LogicalPolicyClient<LogicalPolicyGetPayload<T>>> : CheckSelect<T, Prisma__LogicalPolicyClient<LogicalPolicy | null >, Prisma__LogicalPolicyClient<LogicalPolicyGetPayload<T> | null >>

    /**
     * Find zero or more LogicalPolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogicalPolicyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LogicalPolicies
     * const logicalPolicies = await prisma.logicalPolicy.findMany()
     * 
     * // Get first 10 LogicalPolicies
     * const logicalPolicies = await prisma.logicalPolicy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logicalPolicyWithIdOnly = await prisma.logicalPolicy.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LogicalPolicyFindManyArgs>(
      args?: SelectSubset<T, LogicalPolicyFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<LogicalPolicy>>, PrismaPromise<Array<LogicalPolicyGetPayload<T>>>>

    /**
     * Create a LogicalPolicy.
     * @param {LogicalPolicyCreateArgs} args - Arguments to create a LogicalPolicy.
     * @example
     * // Create one LogicalPolicy
     * const LogicalPolicy = await prisma.logicalPolicy.create({
     *   data: {
     *     // ... data to create a LogicalPolicy
     *   }
     * })
     * 
    **/
    create<T extends LogicalPolicyCreateArgs>(
      args: SelectSubset<T, LogicalPolicyCreateArgs>
    ): CheckSelect<T, Prisma__LogicalPolicyClient<LogicalPolicy>, Prisma__LogicalPolicyClient<LogicalPolicyGetPayload<T>>>

    /**
     * Create many LogicalPolicies.
     *     @param {LogicalPolicyCreateManyArgs} args - Arguments to create many LogicalPolicies.
     *     @example
     *     // Create many LogicalPolicies
     *     const logicalPolicy = await prisma.logicalPolicy.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LogicalPolicyCreateManyArgs>(
      args?: SelectSubset<T, LogicalPolicyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a LogicalPolicy.
     * @param {LogicalPolicyDeleteArgs} args - Arguments to delete one LogicalPolicy.
     * @example
     * // Delete one LogicalPolicy
     * const LogicalPolicy = await prisma.logicalPolicy.delete({
     *   where: {
     *     // ... filter to delete one LogicalPolicy
     *   }
     * })
     * 
    **/
    delete<T extends LogicalPolicyDeleteArgs>(
      args: SelectSubset<T, LogicalPolicyDeleteArgs>
    ): CheckSelect<T, Prisma__LogicalPolicyClient<LogicalPolicy>, Prisma__LogicalPolicyClient<LogicalPolicyGetPayload<T>>>

    /**
     * Update one LogicalPolicy.
     * @param {LogicalPolicyUpdateArgs} args - Arguments to update one LogicalPolicy.
     * @example
     * // Update one LogicalPolicy
     * const logicalPolicy = await prisma.logicalPolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LogicalPolicyUpdateArgs>(
      args: SelectSubset<T, LogicalPolicyUpdateArgs>
    ): CheckSelect<T, Prisma__LogicalPolicyClient<LogicalPolicy>, Prisma__LogicalPolicyClient<LogicalPolicyGetPayload<T>>>

    /**
     * Delete zero or more LogicalPolicies.
     * @param {LogicalPolicyDeleteManyArgs} args - Arguments to filter LogicalPolicies to delete.
     * @example
     * // Delete a few LogicalPolicies
     * const { count } = await prisma.logicalPolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LogicalPolicyDeleteManyArgs>(
      args?: SelectSubset<T, LogicalPolicyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogicalPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogicalPolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LogicalPolicies
     * const logicalPolicy = await prisma.logicalPolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LogicalPolicyUpdateManyArgs>(
      args: SelectSubset<T, LogicalPolicyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one LogicalPolicy.
     * @param {LogicalPolicyUpsertArgs} args - Arguments to update or create a LogicalPolicy.
     * @example
     * // Update or create a LogicalPolicy
     * const logicalPolicy = await prisma.logicalPolicy.upsert({
     *   create: {
     *     // ... data to create a LogicalPolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LogicalPolicy we want to update
     *   }
     * })
    **/
    upsert<T extends LogicalPolicyUpsertArgs>(
      args: SelectSubset<T, LogicalPolicyUpsertArgs>
    ): CheckSelect<T, Prisma__LogicalPolicyClient<LogicalPolicy>, Prisma__LogicalPolicyClient<LogicalPolicyGetPayload<T>>>

    /**
     * Count the number of LogicalPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogicalPolicyCountArgs} args - Arguments to filter LogicalPolicies to count.
     * @example
     * // Count the number of LogicalPolicies
     * const count = await prisma.logicalPolicy.count({
     *   where: {
     *     // ... the filter for the LogicalPolicies we want to count
     *   }
     * })
    **/
    count<T extends LogicalPolicyCountArgs>(
      args?: Subset<T, LogicalPolicyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogicalPolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LogicalPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogicalPolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogicalPolicyAggregateArgs>(args: Subset<T, LogicalPolicyAggregateArgs>): PrismaPromise<GetLogicalPolicyAggregateType<T>>

    /**
     * Group by LogicalPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogicalPolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogicalPolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogicalPolicyGroupByArgs['orderBy'] }
        : { orderBy?: LogicalPolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogicalPolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogicalPolicyGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for LogicalPolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LogicalPolicyClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    policy<T extends PolicyArgs = {}>(args?: Subset<T, PolicyArgs>): CheckSelect<T, Prisma__PolicyClient<Policy | null >, Prisma__PolicyClient<PolicyGetPayload<T> | null >>;

    policies<T extends PolicyInContainerFindManyArgs = {}>(args?: Subset<T, PolicyInContainerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PolicyInContainer>>, PrismaPromise<Array<PolicyInContainerGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * LogicalPolicy findUnique
   */
  export type LogicalPolicyFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the LogicalPolicy
     * 
    **/
    select?: LogicalPolicySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogicalPolicyInclude | null
    /**
     * Throw an Error if a LogicalPolicy can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which LogicalPolicy to fetch.
     * 
    **/
    where: LogicalPolicyWhereUniqueInput
  }


  /**
   * LogicalPolicy findFirst
   */
  export type LogicalPolicyFindFirstArgs = {
    /**
     * Select specific fields to fetch from the LogicalPolicy
     * 
    **/
    select?: LogicalPolicySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogicalPolicyInclude | null
    /**
     * Throw an Error if a LogicalPolicy can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which LogicalPolicy to fetch.
     * 
    **/
    where?: LogicalPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogicalPolicies to fetch.
     * 
    **/
    orderBy?: Enumerable<LogicalPolicyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogicalPolicies.
     * 
    **/
    cursor?: LogicalPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogicalPolicies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogicalPolicies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogicalPolicies.
     * 
    **/
    distinct?: Enumerable<LogicalPolicyScalarFieldEnum>
  }


  /**
   * LogicalPolicy findMany
   */
  export type LogicalPolicyFindManyArgs = {
    /**
     * Select specific fields to fetch from the LogicalPolicy
     * 
    **/
    select?: LogicalPolicySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogicalPolicyInclude | null
    /**
     * Filter, which LogicalPolicies to fetch.
     * 
    **/
    where?: LogicalPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogicalPolicies to fetch.
     * 
    **/
    orderBy?: Enumerable<LogicalPolicyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LogicalPolicies.
     * 
    **/
    cursor?: LogicalPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogicalPolicies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogicalPolicies.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LogicalPolicyScalarFieldEnum>
  }


  /**
   * LogicalPolicy create
   */
  export type LogicalPolicyCreateArgs = {
    /**
     * Select specific fields to fetch from the LogicalPolicy
     * 
    **/
    select?: LogicalPolicySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogicalPolicyInclude | null
    /**
     * The data needed to create a LogicalPolicy.
     * 
    **/
    data: XOR<LogicalPolicyCreateInput, LogicalPolicyUncheckedCreateInput>
  }


  /**
   * LogicalPolicy createMany
   */
  export type LogicalPolicyCreateManyArgs = {
    /**
     * The data used to create many LogicalPolicies.
     * 
    **/
    data: Enumerable<LogicalPolicyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LogicalPolicy update
   */
  export type LogicalPolicyUpdateArgs = {
    /**
     * Select specific fields to fetch from the LogicalPolicy
     * 
    **/
    select?: LogicalPolicySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogicalPolicyInclude | null
    /**
     * The data needed to update a LogicalPolicy.
     * 
    **/
    data: XOR<LogicalPolicyUpdateInput, LogicalPolicyUncheckedUpdateInput>
    /**
     * Choose, which LogicalPolicy to update.
     * 
    **/
    where: LogicalPolicyWhereUniqueInput
  }


  /**
   * LogicalPolicy updateMany
   */
  export type LogicalPolicyUpdateManyArgs = {
    /**
     * The data used to update LogicalPolicies.
     * 
    **/
    data: XOR<LogicalPolicyUpdateManyMutationInput, LogicalPolicyUncheckedUpdateManyInput>
    /**
     * Filter which LogicalPolicies to update
     * 
    **/
    where?: LogicalPolicyWhereInput
  }


  /**
   * LogicalPolicy upsert
   */
  export type LogicalPolicyUpsertArgs = {
    /**
     * Select specific fields to fetch from the LogicalPolicy
     * 
    **/
    select?: LogicalPolicySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogicalPolicyInclude | null
    /**
     * The filter to search for the LogicalPolicy to update in case it exists.
     * 
    **/
    where: LogicalPolicyWhereUniqueInput
    /**
     * In case the LogicalPolicy found by the `where` argument doesn't exist, create a new LogicalPolicy with this data.
     * 
    **/
    create: XOR<LogicalPolicyCreateInput, LogicalPolicyUncheckedCreateInput>
    /**
     * In case the LogicalPolicy was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<LogicalPolicyUpdateInput, LogicalPolicyUncheckedUpdateInput>
  }


  /**
   * LogicalPolicy delete
   */
  export type LogicalPolicyDeleteArgs = {
    /**
     * Select specific fields to fetch from the LogicalPolicy
     * 
    **/
    select?: LogicalPolicySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogicalPolicyInclude | null
    /**
     * Filter which LogicalPolicy to delete.
     * 
    **/
    where: LogicalPolicyWhereUniqueInput
  }


  /**
   * LogicalPolicy deleteMany
   */
  export type LogicalPolicyDeleteManyArgs = {
    /**
     * Filter which LogicalPolicies to delete
     * 
    **/
    where?: LogicalPolicyWhereInput
  }


  /**
   * LogicalPolicy without action
   */
  export type LogicalPolicyArgs = {
    /**
     * Select specific fields to fetch from the LogicalPolicy
     * 
    **/
    select?: LogicalPolicySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogicalPolicyInclude | null
  }



  /**
   * Model PolicyInContainer
   */


  export type AggregatePolicyInContainer = {
    _count: PolicyInContainerCountAggregateOutputType | null
    _avg: PolicyInContainerAvgAggregateOutputType | null
    _sum: PolicyInContainerSumAggregateOutputType | null
    _min: PolicyInContainerMinAggregateOutputType | null
    _max: PolicyInContainerMaxAggregateOutputType | null
  }

  export type PolicyInContainerAvgAggregateOutputType = {
    containedPolicy: number | null
    shopId: number | null
    containingPolicy: number | null
  }

  export type PolicyInContainerSumAggregateOutputType = {
    containedPolicy: number | null
    shopId: number | null
    containingPolicy: number | null
  }

  export type PolicyInContainerMinAggregateOutputType = {
    containedPolicy: number | null
    shopId: number | null
    containingPolicy: number | null
  }

  export type PolicyInContainerMaxAggregateOutputType = {
    containedPolicy: number | null
    shopId: number | null
    containingPolicy: number | null
  }

  export type PolicyInContainerCountAggregateOutputType = {
    containedPolicy: number
    shopId: number
    containingPolicy: number
    _all: number
  }


  export type PolicyInContainerAvgAggregateInputType = {
    containedPolicy?: true
    shopId?: true
    containingPolicy?: true
  }

  export type PolicyInContainerSumAggregateInputType = {
    containedPolicy?: true
    shopId?: true
    containingPolicy?: true
  }

  export type PolicyInContainerMinAggregateInputType = {
    containedPolicy?: true
    shopId?: true
    containingPolicy?: true
  }

  export type PolicyInContainerMaxAggregateInputType = {
    containedPolicy?: true
    shopId?: true
    containingPolicy?: true
  }

  export type PolicyInContainerCountAggregateInputType = {
    containedPolicy?: true
    shopId?: true
    containingPolicy?: true
    _all?: true
  }

  export type PolicyInContainerAggregateArgs = {
    /**
     * Filter which PolicyInContainer to aggregate.
     * 
    **/
    where?: PolicyInContainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PolicyInContainers to fetch.
     * 
    **/
    orderBy?: Enumerable<PolicyInContainerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PolicyInContainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PolicyInContainers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PolicyInContainers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PolicyInContainers
    **/
    _count?: true | PolicyInContainerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PolicyInContainerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PolicyInContainerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PolicyInContainerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PolicyInContainerMaxAggregateInputType
  }

  export type GetPolicyInContainerAggregateType<T extends PolicyInContainerAggregateArgs> = {
        [P in keyof T & keyof AggregatePolicyInContainer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePolicyInContainer[P]>
      : GetScalarType<T[P], AggregatePolicyInContainer[P]>
  }




  export type PolicyInContainerGroupByArgs = {
    where?: PolicyInContainerWhereInput
    orderBy?: Enumerable<PolicyInContainerOrderByWithAggregationInput>
    by: Array<PolicyInContainerScalarFieldEnum>
    having?: PolicyInContainerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PolicyInContainerCountAggregateInputType | true
    _avg?: PolicyInContainerAvgAggregateInputType
    _sum?: PolicyInContainerSumAggregateInputType
    _min?: PolicyInContainerMinAggregateInputType
    _max?: PolicyInContainerMaxAggregateInputType
  }


  export type PolicyInContainerGroupByOutputType = {
    containedPolicy: number
    shopId: number
    containingPolicy: number
    _count: PolicyInContainerCountAggregateOutputType | null
    _avg: PolicyInContainerAvgAggregateOutputType | null
    _sum: PolicyInContainerSumAggregateOutputType | null
    _min: PolicyInContainerMinAggregateOutputType | null
    _max: PolicyInContainerMaxAggregateOutputType | null
  }

  type GetPolicyInContainerGroupByPayload<T extends PolicyInContainerGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PolicyInContainerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PolicyInContainerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PolicyInContainerGroupByOutputType[P]>
            : GetScalarType<T[P], PolicyInContainerGroupByOutputType[P]>
        }
      >
    >


  export type PolicyInContainerSelect = {
    policy?: boolean | PolicyArgs
    containedPolicy?: boolean
    shopId?: boolean
    policyContainer?: boolean | LogicalPolicyArgs
    containingPolicy?: boolean
  }

  export type PolicyInContainerInclude = {
    policy?: boolean | PolicyArgs
    policyContainer?: boolean | LogicalPolicyArgs
  }

  export type PolicyInContainerGetPayload<
    S extends boolean | null | undefined | PolicyInContainerArgs,
    U = keyof S
      > = S extends true
        ? PolicyInContainer
    : S extends undefined
    ? never
    : S extends PolicyInContainerArgs | PolicyInContainerFindManyArgs
    ?'include' extends U
    ? PolicyInContainer  & {
    [P in TrueKeys<S['include']>]:
        P extends 'policy' ? PolicyGetPayload<S['include'][P]> :
        P extends 'policyContainer' ? LogicalPolicyGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'policy' ? PolicyGetPayload<S['select'][P]> :
        P extends 'policyContainer' ? LogicalPolicyGetPayload<S['select'][P]> :  P extends keyof PolicyInContainer ? PolicyInContainer[P] : never
  } 
    : PolicyInContainer
  : PolicyInContainer


  type PolicyInContainerCountArgs = Merge<
    Omit<PolicyInContainerFindManyArgs, 'select' | 'include'> & {
      select?: PolicyInContainerCountAggregateInputType | true
    }
  >

  export interface PolicyInContainerDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PolicyInContainer that matches the filter.
     * @param {PolicyInContainerFindUniqueArgs} args - Arguments to find a PolicyInContainer
     * @example
     * // Get one PolicyInContainer
     * const policyInContainer = await prisma.policyInContainer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PolicyInContainerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PolicyInContainerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PolicyInContainer'> extends True ? CheckSelect<T, Prisma__PolicyInContainerClient<PolicyInContainer>, Prisma__PolicyInContainerClient<PolicyInContainerGetPayload<T>>> : CheckSelect<T, Prisma__PolicyInContainerClient<PolicyInContainer | null >, Prisma__PolicyInContainerClient<PolicyInContainerGetPayload<T> | null >>

    /**
     * Find the first PolicyInContainer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyInContainerFindFirstArgs} args - Arguments to find a PolicyInContainer
     * @example
     * // Get one PolicyInContainer
     * const policyInContainer = await prisma.policyInContainer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PolicyInContainerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PolicyInContainerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PolicyInContainer'> extends True ? CheckSelect<T, Prisma__PolicyInContainerClient<PolicyInContainer>, Prisma__PolicyInContainerClient<PolicyInContainerGetPayload<T>>> : CheckSelect<T, Prisma__PolicyInContainerClient<PolicyInContainer | null >, Prisma__PolicyInContainerClient<PolicyInContainerGetPayload<T> | null >>

    /**
     * Find zero or more PolicyInContainers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyInContainerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PolicyInContainers
     * const policyInContainers = await prisma.policyInContainer.findMany()
     * 
     * // Get first 10 PolicyInContainers
     * const policyInContainers = await prisma.policyInContainer.findMany({ take: 10 })
     * 
     * // Only select the `containedPolicy`
     * const policyInContainerWithContainedPolicyOnly = await prisma.policyInContainer.findMany({ select: { containedPolicy: true } })
     * 
    **/
    findMany<T extends PolicyInContainerFindManyArgs>(
      args?: SelectSubset<T, PolicyInContainerFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PolicyInContainer>>, PrismaPromise<Array<PolicyInContainerGetPayload<T>>>>

    /**
     * Create a PolicyInContainer.
     * @param {PolicyInContainerCreateArgs} args - Arguments to create a PolicyInContainer.
     * @example
     * // Create one PolicyInContainer
     * const PolicyInContainer = await prisma.policyInContainer.create({
     *   data: {
     *     // ... data to create a PolicyInContainer
     *   }
     * })
     * 
    **/
    create<T extends PolicyInContainerCreateArgs>(
      args: SelectSubset<T, PolicyInContainerCreateArgs>
    ): CheckSelect<T, Prisma__PolicyInContainerClient<PolicyInContainer>, Prisma__PolicyInContainerClient<PolicyInContainerGetPayload<T>>>

    /**
     * Create many PolicyInContainers.
     *     @param {PolicyInContainerCreateManyArgs} args - Arguments to create many PolicyInContainers.
     *     @example
     *     // Create many PolicyInContainers
     *     const policyInContainer = await prisma.policyInContainer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PolicyInContainerCreateManyArgs>(
      args?: SelectSubset<T, PolicyInContainerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PolicyInContainer.
     * @param {PolicyInContainerDeleteArgs} args - Arguments to delete one PolicyInContainer.
     * @example
     * // Delete one PolicyInContainer
     * const PolicyInContainer = await prisma.policyInContainer.delete({
     *   where: {
     *     // ... filter to delete one PolicyInContainer
     *   }
     * })
     * 
    **/
    delete<T extends PolicyInContainerDeleteArgs>(
      args: SelectSubset<T, PolicyInContainerDeleteArgs>
    ): CheckSelect<T, Prisma__PolicyInContainerClient<PolicyInContainer>, Prisma__PolicyInContainerClient<PolicyInContainerGetPayload<T>>>

    /**
     * Update one PolicyInContainer.
     * @param {PolicyInContainerUpdateArgs} args - Arguments to update one PolicyInContainer.
     * @example
     * // Update one PolicyInContainer
     * const policyInContainer = await prisma.policyInContainer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PolicyInContainerUpdateArgs>(
      args: SelectSubset<T, PolicyInContainerUpdateArgs>
    ): CheckSelect<T, Prisma__PolicyInContainerClient<PolicyInContainer>, Prisma__PolicyInContainerClient<PolicyInContainerGetPayload<T>>>

    /**
     * Delete zero or more PolicyInContainers.
     * @param {PolicyInContainerDeleteManyArgs} args - Arguments to filter PolicyInContainers to delete.
     * @example
     * // Delete a few PolicyInContainers
     * const { count } = await prisma.policyInContainer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PolicyInContainerDeleteManyArgs>(
      args?: SelectSubset<T, PolicyInContainerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PolicyInContainers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyInContainerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PolicyInContainers
     * const policyInContainer = await prisma.policyInContainer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PolicyInContainerUpdateManyArgs>(
      args: SelectSubset<T, PolicyInContainerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PolicyInContainer.
     * @param {PolicyInContainerUpsertArgs} args - Arguments to update or create a PolicyInContainer.
     * @example
     * // Update or create a PolicyInContainer
     * const policyInContainer = await prisma.policyInContainer.upsert({
     *   create: {
     *     // ... data to create a PolicyInContainer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PolicyInContainer we want to update
     *   }
     * })
    **/
    upsert<T extends PolicyInContainerUpsertArgs>(
      args: SelectSubset<T, PolicyInContainerUpsertArgs>
    ): CheckSelect<T, Prisma__PolicyInContainerClient<PolicyInContainer>, Prisma__PolicyInContainerClient<PolicyInContainerGetPayload<T>>>

    /**
     * Count the number of PolicyInContainers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyInContainerCountArgs} args - Arguments to filter PolicyInContainers to count.
     * @example
     * // Count the number of PolicyInContainers
     * const count = await prisma.policyInContainer.count({
     *   where: {
     *     // ... the filter for the PolicyInContainers we want to count
     *   }
     * })
    **/
    count<T extends PolicyInContainerCountArgs>(
      args?: Subset<T, PolicyInContainerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PolicyInContainerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PolicyInContainer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyInContainerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PolicyInContainerAggregateArgs>(args: Subset<T, PolicyInContainerAggregateArgs>): PrismaPromise<GetPolicyInContainerAggregateType<T>>

    /**
     * Group by PolicyInContainer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyInContainerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PolicyInContainerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PolicyInContainerGroupByArgs['orderBy'] }
        : { orderBy?: PolicyInContainerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PolicyInContainerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPolicyInContainerGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for PolicyInContainer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PolicyInContainerClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    policy<T extends PolicyArgs = {}>(args?: Subset<T, PolicyArgs>): CheckSelect<T, Prisma__PolicyClient<Policy | null >, Prisma__PolicyClient<PolicyGetPayload<T> | null >>;

    policyContainer<T extends LogicalPolicyArgs = {}>(args?: Subset<T, LogicalPolicyArgs>): CheckSelect<T, Prisma__LogicalPolicyClient<LogicalPolicy | null >, Prisma__LogicalPolicyClient<LogicalPolicyGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PolicyInContainer findUnique
   */
  export type PolicyInContainerFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PolicyInContainer
     * 
    **/
    select?: PolicyInContainerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PolicyInContainerInclude | null
    /**
     * Throw an Error if a PolicyInContainer can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PolicyInContainer to fetch.
     * 
    **/
    where: PolicyInContainerWhereUniqueInput
  }


  /**
   * PolicyInContainer findFirst
   */
  export type PolicyInContainerFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PolicyInContainer
     * 
    **/
    select?: PolicyInContainerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PolicyInContainerInclude | null
    /**
     * Throw an Error if a PolicyInContainer can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PolicyInContainer to fetch.
     * 
    **/
    where?: PolicyInContainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PolicyInContainers to fetch.
     * 
    **/
    orderBy?: Enumerable<PolicyInContainerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PolicyInContainers.
     * 
    **/
    cursor?: PolicyInContainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PolicyInContainers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PolicyInContainers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PolicyInContainers.
     * 
    **/
    distinct?: Enumerable<PolicyInContainerScalarFieldEnum>
  }


  /**
   * PolicyInContainer findMany
   */
  export type PolicyInContainerFindManyArgs = {
    /**
     * Select specific fields to fetch from the PolicyInContainer
     * 
    **/
    select?: PolicyInContainerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PolicyInContainerInclude | null
    /**
     * Filter, which PolicyInContainers to fetch.
     * 
    **/
    where?: PolicyInContainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PolicyInContainers to fetch.
     * 
    **/
    orderBy?: Enumerable<PolicyInContainerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PolicyInContainers.
     * 
    **/
    cursor?: PolicyInContainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PolicyInContainers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PolicyInContainers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PolicyInContainerScalarFieldEnum>
  }


  /**
   * PolicyInContainer create
   */
  export type PolicyInContainerCreateArgs = {
    /**
     * Select specific fields to fetch from the PolicyInContainer
     * 
    **/
    select?: PolicyInContainerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PolicyInContainerInclude | null
    /**
     * The data needed to create a PolicyInContainer.
     * 
    **/
    data: XOR<PolicyInContainerCreateInput, PolicyInContainerUncheckedCreateInput>
  }


  /**
   * PolicyInContainer createMany
   */
  export type PolicyInContainerCreateManyArgs = {
    /**
     * The data used to create many PolicyInContainers.
     * 
    **/
    data: Enumerable<PolicyInContainerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PolicyInContainer update
   */
  export type PolicyInContainerUpdateArgs = {
    /**
     * Select specific fields to fetch from the PolicyInContainer
     * 
    **/
    select?: PolicyInContainerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PolicyInContainerInclude | null
    /**
     * The data needed to update a PolicyInContainer.
     * 
    **/
    data: XOR<PolicyInContainerUpdateInput, PolicyInContainerUncheckedUpdateInput>
    /**
     * Choose, which PolicyInContainer to update.
     * 
    **/
    where: PolicyInContainerWhereUniqueInput
  }


  /**
   * PolicyInContainer updateMany
   */
  export type PolicyInContainerUpdateManyArgs = {
    /**
     * The data used to update PolicyInContainers.
     * 
    **/
    data: XOR<PolicyInContainerUpdateManyMutationInput, PolicyInContainerUncheckedUpdateManyInput>
    /**
     * Filter which PolicyInContainers to update
     * 
    **/
    where?: PolicyInContainerWhereInput
  }


  /**
   * PolicyInContainer upsert
   */
  export type PolicyInContainerUpsertArgs = {
    /**
     * Select specific fields to fetch from the PolicyInContainer
     * 
    **/
    select?: PolicyInContainerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PolicyInContainerInclude | null
    /**
     * The filter to search for the PolicyInContainer to update in case it exists.
     * 
    **/
    where: PolicyInContainerWhereUniqueInput
    /**
     * In case the PolicyInContainer found by the `where` argument doesn't exist, create a new PolicyInContainer with this data.
     * 
    **/
    create: XOR<PolicyInContainerCreateInput, PolicyInContainerUncheckedCreateInput>
    /**
     * In case the PolicyInContainer was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PolicyInContainerUpdateInput, PolicyInContainerUncheckedUpdateInput>
  }


  /**
   * PolicyInContainer delete
   */
  export type PolicyInContainerDeleteArgs = {
    /**
     * Select specific fields to fetch from the PolicyInContainer
     * 
    **/
    select?: PolicyInContainerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PolicyInContainerInclude | null
    /**
     * Filter which PolicyInContainer to delete.
     * 
    **/
    where: PolicyInContainerWhereUniqueInput
  }


  /**
   * PolicyInContainer deleteMany
   */
  export type PolicyInContainerDeleteManyArgs = {
    /**
     * Filter which PolicyInContainers to delete
     * 
    **/
    where?: PolicyInContainerWhereInput
  }


  /**
   * PolicyInContainer without action
   */
  export type PolicyInContainerArgs = {
    /**
     * Select specific fields to fetch from the PolicyInContainer
     * 
    **/
    select?: PolicyInContainerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PolicyInContainerInclude | null
  }



  /**
   * Model Offer
   */


  export type AggregateOffer = {
    _count: OfferCountAggregateOutputType | null
    _avg: OfferAvgAggregateOutputType | null
    _sum: OfferSumAggregateOutputType | null
    _min: OfferMinAggregateOutputType | null
    _max: OfferMaxAggregateOutputType | null
  }

  export type OfferAvgAggregateOutputType = {
    id: number | null
    shopId: number | null
    productId: number | null
    price: number | null
  }

  export type OfferSumAggregateOutputType = {
    id: number | null
    shopId: number | null
    productId: number | null
    price: number | null
  }

  export type OfferMinAggregateOutputType = {
    id: number | null
    username: string | null
    shopId: number | null
    productId: number | null
    price: number | null
  }

  export type OfferMaxAggregateOutputType = {
    id: number | null
    username: string | null
    shopId: number | null
    productId: number | null
    price: number | null
  }

  export type OfferCountAggregateOutputType = {
    id: number
    username: number
    shopId: number
    productId: number
    price: number
    _all: number
  }


  export type OfferAvgAggregateInputType = {
    id?: true
    shopId?: true
    productId?: true
    price?: true
  }

  export type OfferSumAggregateInputType = {
    id?: true
    shopId?: true
    productId?: true
    price?: true
  }

  export type OfferMinAggregateInputType = {
    id?: true
    username?: true
    shopId?: true
    productId?: true
    price?: true
  }

  export type OfferMaxAggregateInputType = {
    id?: true
    username?: true
    shopId?: true
    productId?: true
    price?: true
  }

  export type OfferCountAggregateInputType = {
    id?: true
    username?: true
    shopId?: true
    productId?: true
    price?: true
    _all?: true
  }

  export type OfferAggregateArgs = {
    /**
     * Filter which Offer to aggregate.
     * 
    **/
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     * 
    **/
    orderBy?: Enumerable<OfferOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Offers
    **/
    _count?: true | OfferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OfferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OfferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfferMaxAggregateInputType
  }

  export type GetOfferAggregateType<T extends OfferAggregateArgs> = {
        [P in keyof T & keyof AggregateOffer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffer[P]>
      : GetScalarType<T[P], AggregateOffer[P]>
  }




  export type OfferGroupByArgs = {
    where?: OfferWhereInput
    orderBy?: Enumerable<OfferOrderByWithAggregationInput>
    by: Array<OfferScalarFieldEnum>
    having?: OfferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfferCountAggregateInputType | true
    _avg?: OfferAvgAggregateInputType
    _sum?: OfferSumAggregateInputType
    _min?: OfferMinAggregateInputType
    _max?: OfferMaxAggregateInputType
  }


  export type OfferGroupByOutputType = {
    id: number
    username: string
    shopId: number
    productId: number
    price: number
    _count: OfferCountAggregateOutputType | null
    _avg: OfferAvgAggregateOutputType | null
    _sum: OfferSumAggregateOutputType | null
    _min: OfferMinAggregateOutputType | null
    _max: OfferMaxAggregateOutputType | null
  }

  type GetOfferGroupByPayload<T extends OfferGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OfferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfferGroupByOutputType[P]>
            : GetScalarType<T[P], OfferGroupByOutputType[P]>
        }
      >
    >


  export type OfferSelect = {
    id?: boolean
    member?: boolean | MemberArgs
    username?: boolean
    shop?: boolean | ShopArgs
    shopId?: boolean
    product?: boolean | ProductArgs
    productId?: boolean
    price?: boolean
    offerApprover?: boolean | OfferApproverFindManyArgs
    _count?: boolean | OfferCountOutputTypeArgs
  }

  export type OfferInclude = {
    member?: boolean | MemberArgs
    shop?: boolean | ShopArgs
    product?: boolean | ProductArgs
    offerApprover?: boolean | OfferApproverFindManyArgs
    _count?: boolean | OfferCountOutputTypeArgs
  }

  export type OfferGetPayload<
    S extends boolean | null | undefined | OfferArgs,
    U = keyof S
      > = S extends true
        ? Offer
    : S extends undefined
    ? never
    : S extends OfferArgs | OfferFindManyArgs
    ?'include' extends U
    ? Offer  & {
    [P in TrueKeys<S['include']>]:
        P extends 'member' ? MemberGetPayload<S['include'][P]> :
        P extends 'shop' ? ShopGetPayload<S['include'][P]> :
        P extends 'product' ? ProductGetPayload<S['include'][P]> :
        P extends 'offerApprover' ? Array < OfferApproverGetPayload<S['include'][P]>>  :
        P extends '_count' ? OfferCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'member' ? MemberGetPayload<S['select'][P]> :
        P extends 'shop' ? ShopGetPayload<S['select'][P]> :
        P extends 'product' ? ProductGetPayload<S['select'][P]> :
        P extends 'offerApprover' ? Array < OfferApproverGetPayload<S['select'][P]>>  :
        P extends '_count' ? OfferCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Offer ? Offer[P] : never
  } 
    : Offer
  : Offer


  type OfferCountArgs = Merge<
    Omit<OfferFindManyArgs, 'select' | 'include'> & {
      select?: OfferCountAggregateInputType | true
    }
  >

  export interface OfferDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Offer that matches the filter.
     * @param {OfferFindUniqueArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OfferFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OfferFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Offer'> extends True ? CheckSelect<T, Prisma__OfferClient<Offer>, Prisma__OfferClient<OfferGetPayload<T>>> : CheckSelect<T, Prisma__OfferClient<Offer | null >, Prisma__OfferClient<OfferGetPayload<T> | null >>

    /**
     * Find the first Offer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindFirstArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OfferFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OfferFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Offer'> extends True ? CheckSelect<T, Prisma__OfferClient<Offer>, Prisma__OfferClient<OfferGetPayload<T>>> : CheckSelect<T, Prisma__OfferClient<Offer | null >, Prisma__OfferClient<OfferGetPayload<T> | null >>

    /**
     * Find zero or more Offers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Offers
     * const offers = await prisma.offer.findMany()
     * 
     * // Get first 10 Offers
     * const offers = await prisma.offer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offerWithIdOnly = await prisma.offer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OfferFindManyArgs>(
      args?: SelectSubset<T, OfferFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Offer>>, PrismaPromise<Array<OfferGetPayload<T>>>>

    /**
     * Create a Offer.
     * @param {OfferCreateArgs} args - Arguments to create a Offer.
     * @example
     * // Create one Offer
     * const Offer = await prisma.offer.create({
     *   data: {
     *     // ... data to create a Offer
     *   }
     * })
     * 
    **/
    create<T extends OfferCreateArgs>(
      args: SelectSubset<T, OfferCreateArgs>
    ): CheckSelect<T, Prisma__OfferClient<Offer>, Prisma__OfferClient<OfferGetPayload<T>>>

    /**
     * Create many Offers.
     *     @param {OfferCreateManyArgs} args - Arguments to create many Offers.
     *     @example
     *     // Create many Offers
     *     const offer = await prisma.offer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OfferCreateManyArgs>(
      args?: SelectSubset<T, OfferCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Offer.
     * @param {OfferDeleteArgs} args - Arguments to delete one Offer.
     * @example
     * // Delete one Offer
     * const Offer = await prisma.offer.delete({
     *   where: {
     *     // ... filter to delete one Offer
     *   }
     * })
     * 
    **/
    delete<T extends OfferDeleteArgs>(
      args: SelectSubset<T, OfferDeleteArgs>
    ): CheckSelect<T, Prisma__OfferClient<Offer>, Prisma__OfferClient<OfferGetPayload<T>>>

    /**
     * Update one Offer.
     * @param {OfferUpdateArgs} args - Arguments to update one Offer.
     * @example
     * // Update one Offer
     * const offer = await prisma.offer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OfferUpdateArgs>(
      args: SelectSubset<T, OfferUpdateArgs>
    ): CheckSelect<T, Prisma__OfferClient<Offer>, Prisma__OfferClient<OfferGetPayload<T>>>

    /**
     * Delete zero or more Offers.
     * @param {OfferDeleteManyArgs} args - Arguments to filter Offers to delete.
     * @example
     * // Delete a few Offers
     * const { count } = await prisma.offer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OfferDeleteManyArgs>(
      args?: SelectSubset<T, OfferDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Offers
     * const offer = await prisma.offer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OfferUpdateManyArgs>(
      args: SelectSubset<T, OfferUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Offer.
     * @param {OfferUpsertArgs} args - Arguments to update or create a Offer.
     * @example
     * // Update or create a Offer
     * const offer = await prisma.offer.upsert({
     *   create: {
     *     // ... data to create a Offer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Offer we want to update
     *   }
     * })
    **/
    upsert<T extends OfferUpsertArgs>(
      args: SelectSubset<T, OfferUpsertArgs>
    ): CheckSelect<T, Prisma__OfferClient<Offer>, Prisma__OfferClient<OfferGetPayload<T>>>

    /**
     * Count the number of Offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferCountArgs} args - Arguments to filter Offers to count.
     * @example
     * // Count the number of Offers
     * const count = await prisma.offer.count({
     *   where: {
     *     // ... the filter for the Offers we want to count
     *   }
     * })
    **/
    count<T extends OfferCountArgs>(
      args?: Subset<T, OfferCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Offer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfferAggregateArgs>(args: Subset<T, OfferAggregateArgs>): PrismaPromise<GetOfferAggregateType<T>>

    /**
     * Group by Offer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfferGroupByArgs['orderBy'] }
        : { orderBy?: OfferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfferGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Offer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OfferClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    member<T extends MemberArgs = {}>(args?: Subset<T, MemberArgs>): CheckSelect<T, Prisma__MemberClient<Member | null >, Prisma__MemberClient<MemberGetPayload<T> | null >>;

    shop<T extends ShopArgs = {}>(args?: Subset<T, ShopArgs>): CheckSelect<T, Prisma__ShopClient<Shop | null >, Prisma__ShopClient<ShopGetPayload<T> | null >>;

    product<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>;

    offerApprover<T extends OfferApproverFindManyArgs = {}>(args?: Subset<T, OfferApproverFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OfferApprover>>, PrismaPromise<Array<OfferApproverGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Offer findUnique
   */
  export type OfferFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Offer
     * 
    **/
    select?: OfferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OfferInclude | null
    /**
     * Throw an Error if a Offer can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Offer to fetch.
     * 
    **/
    where: OfferWhereUniqueInput
  }


  /**
   * Offer findFirst
   */
  export type OfferFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Offer
     * 
    **/
    select?: OfferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OfferInclude | null
    /**
     * Throw an Error if a Offer can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Offer to fetch.
     * 
    **/
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     * 
    **/
    orderBy?: Enumerable<OfferOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Offers.
     * 
    **/
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Offers.
     * 
    **/
    distinct?: Enumerable<OfferScalarFieldEnum>
  }


  /**
   * Offer findMany
   */
  export type OfferFindManyArgs = {
    /**
     * Select specific fields to fetch from the Offer
     * 
    **/
    select?: OfferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OfferInclude | null
    /**
     * Filter, which Offers to fetch.
     * 
    **/
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     * 
    **/
    orderBy?: Enumerable<OfferOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Offers.
     * 
    **/
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OfferScalarFieldEnum>
  }


  /**
   * Offer create
   */
  export type OfferCreateArgs = {
    /**
     * Select specific fields to fetch from the Offer
     * 
    **/
    select?: OfferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OfferInclude | null
    /**
     * The data needed to create a Offer.
     * 
    **/
    data: XOR<OfferCreateInput, OfferUncheckedCreateInput>
  }


  /**
   * Offer createMany
   */
  export type OfferCreateManyArgs = {
    /**
     * The data used to create many Offers.
     * 
    **/
    data: Enumerable<OfferCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Offer update
   */
  export type OfferUpdateArgs = {
    /**
     * Select specific fields to fetch from the Offer
     * 
    **/
    select?: OfferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OfferInclude | null
    /**
     * The data needed to update a Offer.
     * 
    **/
    data: XOR<OfferUpdateInput, OfferUncheckedUpdateInput>
    /**
     * Choose, which Offer to update.
     * 
    **/
    where: OfferWhereUniqueInput
  }


  /**
   * Offer updateMany
   */
  export type OfferUpdateManyArgs = {
    /**
     * The data used to update Offers.
     * 
    **/
    data: XOR<OfferUpdateManyMutationInput, OfferUncheckedUpdateManyInput>
    /**
     * Filter which Offers to update
     * 
    **/
    where?: OfferWhereInput
  }


  /**
   * Offer upsert
   */
  export type OfferUpsertArgs = {
    /**
     * Select specific fields to fetch from the Offer
     * 
    **/
    select?: OfferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OfferInclude | null
    /**
     * The filter to search for the Offer to update in case it exists.
     * 
    **/
    where: OfferWhereUniqueInput
    /**
     * In case the Offer found by the `where` argument doesn't exist, create a new Offer with this data.
     * 
    **/
    create: XOR<OfferCreateInput, OfferUncheckedCreateInput>
    /**
     * In case the Offer was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OfferUpdateInput, OfferUncheckedUpdateInput>
  }


  /**
   * Offer delete
   */
  export type OfferDeleteArgs = {
    /**
     * Select specific fields to fetch from the Offer
     * 
    **/
    select?: OfferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OfferInclude | null
    /**
     * Filter which Offer to delete.
     * 
    **/
    where: OfferWhereUniqueInput
  }


  /**
   * Offer deleteMany
   */
  export type OfferDeleteManyArgs = {
    /**
     * Filter which Offers to delete
     * 
    **/
    where?: OfferWhereInput
  }


  /**
   * Offer without action
   */
  export type OfferArgs = {
    /**
     * Select specific fields to fetch from the Offer
     * 
    **/
    select?: OfferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OfferInclude | null
  }



  /**
   * Model OfferApprover
   */


  export type AggregateOfferApprover = {
    _count: OfferApproverCountAggregateOutputType | null
    _avg: OfferApproverAvgAggregateOutputType | null
    _sum: OfferApproverSumAggregateOutputType | null
    _min: OfferApproverMinAggregateOutputType | null
    _max: OfferApproverMaxAggregateOutputType | null
  }

  export type OfferApproverAvgAggregateOutputType = {
    offerId: number | null
  }

  export type OfferApproverSumAggregateOutputType = {
    offerId: number | null
  }

  export type OfferApproverMinAggregateOutputType = {
    username: string | null
    offerId: number | null
    answered: boolean | null
    approved: boolean | null
  }

  export type OfferApproverMaxAggregateOutputType = {
    username: string | null
    offerId: number | null
    answered: boolean | null
    approved: boolean | null
  }

  export type OfferApproverCountAggregateOutputType = {
    username: number
    offerId: number
    answered: number
    approved: number
    _all: number
  }


  export type OfferApproverAvgAggregateInputType = {
    offerId?: true
  }

  export type OfferApproverSumAggregateInputType = {
    offerId?: true
  }

  export type OfferApproverMinAggregateInputType = {
    username?: true
    offerId?: true
    answered?: true
    approved?: true
  }

  export type OfferApproverMaxAggregateInputType = {
    username?: true
    offerId?: true
    answered?: true
    approved?: true
  }

  export type OfferApproverCountAggregateInputType = {
    username?: true
    offerId?: true
    answered?: true
    approved?: true
    _all?: true
  }

  export type OfferApproverAggregateArgs = {
    /**
     * Filter which OfferApprover to aggregate.
     * 
    **/
    where?: OfferApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferApprovers to fetch.
     * 
    **/
    orderBy?: Enumerable<OfferApproverOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OfferApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferApprovers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferApprovers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OfferApprovers
    **/
    _count?: true | OfferApproverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OfferApproverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OfferApproverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfferApproverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfferApproverMaxAggregateInputType
  }

  export type GetOfferApproverAggregateType<T extends OfferApproverAggregateArgs> = {
        [P in keyof T & keyof AggregateOfferApprover]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOfferApprover[P]>
      : GetScalarType<T[P], AggregateOfferApprover[P]>
  }




  export type OfferApproverGroupByArgs = {
    where?: OfferApproverWhereInput
    orderBy?: Enumerable<OfferApproverOrderByWithAggregationInput>
    by: Array<OfferApproverScalarFieldEnum>
    having?: OfferApproverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfferApproverCountAggregateInputType | true
    _avg?: OfferApproverAvgAggregateInputType
    _sum?: OfferApproverSumAggregateInputType
    _min?: OfferApproverMinAggregateInputType
    _max?: OfferApproverMaxAggregateInputType
  }


  export type OfferApproverGroupByOutputType = {
    username: string
    offerId: number
    answered: boolean
    approved: boolean
    _count: OfferApproverCountAggregateOutputType | null
    _avg: OfferApproverAvgAggregateOutputType | null
    _sum: OfferApproverSumAggregateOutputType | null
    _min: OfferApproverMinAggregateOutputType | null
    _max: OfferApproverMaxAggregateOutputType | null
  }

  type GetOfferApproverGroupByPayload<T extends OfferApproverGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OfferApproverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfferApproverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfferApproverGroupByOutputType[P]>
            : GetScalarType<T[P], OfferApproverGroupByOutputType[P]>
        }
      >
    >


  export type OfferApproverSelect = {
    member?: boolean | MemberArgs
    username?: boolean
    offer?: boolean | OfferArgs
    offerId?: boolean
    answered?: boolean
    approved?: boolean
  }

  export type OfferApproverInclude = {
    member?: boolean | MemberArgs
    offer?: boolean | OfferArgs
  }

  export type OfferApproverGetPayload<
    S extends boolean | null | undefined | OfferApproverArgs,
    U = keyof S
      > = S extends true
        ? OfferApprover
    : S extends undefined
    ? never
    : S extends OfferApproverArgs | OfferApproverFindManyArgs
    ?'include' extends U
    ? OfferApprover  & {
    [P in TrueKeys<S['include']>]:
        P extends 'member' ? MemberGetPayload<S['include'][P]> :
        P extends 'offer' ? OfferGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'member' ? MemberGetPayload<S['select'][P]> :
        P extends 'offer' ? OfferGetPayload<S['select'][P]> :  P extends keyof OfferApprover ? OfferApprover[P] : never
  } 
    : OfferApprover
  : OfferApprover


  type OfferApproverCountArgs = Merge<
    Omit<OfferApproverFindManyArgs, 'select' | 'include'> & {
      select?: OfferApproverCountAggregateInputType | true
    }
  >

  export interface OfferApproverDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one OfferApprover that matches the filter.
     * @param {OfferApproverFindUniqueArgs} args - Arguments to find a OfferApprover
     * @example
     * // Get one OfferApprover
     * const offerApprover = await prisma.offerApprover.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OfferApproverFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OfferApproverFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OfferApprover'> extends True ? CheckSelect<T, Prisma__OfferApproverClient<OfferApprover>, Prisma__OfferApproverClient<OfferApproverGetPayload<T>>> : CheckSelect<T, Prisma__OfferApproverClient<OfferApprover | null >, Prisma__OfferApproverClient<OfferApproverGetPayload<T> | null >>

    /**
     * Find the first OfferApprover that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferApproverFindFirstArgs} args - Arguments to find a OfferApprover
     * @example
     * // Get one OfferApprover
     * const offerApprover = await prisma.offerApprover.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OfferApproverFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OfferApproverFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OfferApprover'> extends True ? CheckSelect<T, Prisma__OfferApproverClient<OfferApprover>, Prisma__OfferApproverClient<OfferApproverGetPayload<T>>> : CheckSelect<T, Prisma__OfferApproverClient<OfferApprover | null >, Prisma__OfferApproverClient<OfferApproverGetPayload<T> | null >>

    /**
     * Find zero or more OfferApprovers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferApproverFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OfferApprovers
     * const offerApprovers = await prisma.offerApprover.findMany()
     * 
     * // Get first 10 OfferApprovers
     * const offerApprovers = await prisma.offerApprover.findMany({ take: 10 })
     * 
     * // Only select the `username`
     * const offerApproverWithUsernameOnly = await prisma.offerApprover.findMany({ select: { username: true } })
     * 
    **/
    findMany<T extends OfferApproverFindManyArgs>(
      args?: SelectSubset<T, OfferApproverFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<OfferApprover>>, PrismaPromise<Array<OfferApproverGetPayload<T>>>>

    /**
     * Create a OfferApprover.
     * @param {OfferApproverCreateArgs} args - Arguments to create a OfferApprover.
     * @example
     * // Create one OfferApprover
     * const OfferApprover = await prisma.offerApprover.create({
     *   data: {
     *     // ... data to create a OfferApprover
     *   }
     * })
     * 
    **/
    create<T extends OfferApproverCreateArgs>(
      args: SelectSubset<T, OfferApproverCreateArgs>
    ): CheckSelect<T, Prisma__OfferApproverClient<OfferApprover>, Prisma__OfferApproverClient<OfferApproverGetPayload<T>>>

    /**
     * Create many OfferApprovers.
     *     @param {OfferApproverCreateManyArgs} args - Arguments to create many OfferApprovers.
     *     @example
     *     // Create many OfferApprovers
     *     const offerApprover = await prisma.offerApprover.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OfferApproverCreateManyArgs>(
      args?: SelectSubset<T, OfferApproverCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OfferApprover.
     * @param {OfferApproverDeleteArgs} args - Arguments to delete one OfferApprover.
     * @example
     * // Delete one OfferApprover
     * const OfferApprover = await prisma.offerApprover.delete({
     *   where: {
     *     // ... filter to delete one OfferApprover
     *   }
     * })
     * 
    **/
    delete<T extends OfferApproverDeleteArgs>(
      args: SelectSubset<T, OfferApproverDeleteArgs>
    ): CheckSelect<T, Prisma__OfferApproverClient<OfferApprover>, Prisma__OfferApproverClient<OfferApproverGetPayload<T>>>

    /**
     * Update one OfferApprover.
     * @param {OfferApproverUpdateArgs} args - Arguments to update one OfferApprover.
     * @example
     * // Update one OfferApprover
     * const offerApprover = await prisma.offerApprover.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OfferApproverUpdateArgs>(
      args: SelectSubset<T, OfferApproverUpdateArgs>
    ): CheckSelect<T, Prisma__OfferApproverClient<OfferApprover>, Prisma__OfferApproverClient<OfferApproverGetPayload<T>>>

    /**
     * Delete zero or more OfferApprovers.
     * @param {OfferApproverDeleteManyArgs} args - Arguments to filter OfferApprovers to delete.
     * @example
     * // Delete a few OfferApprovers
     * const { count } = await prisma.offerApprover.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OfferApproverDeleteManyArgs>(
      args?: SelectSubset<T, OfferApproverDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OfferApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferApproverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OfferApprovers
     * const offerApprover = await prisma.offerApprover.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OfferApproverUpdateManyArgs>(
      args: SelectSubset<T, OfferApproverUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OfferApprover.
     * @param {OfferApproverUpsertArgs} args - Arguments to update or create a OfferApprover.
     * @example
     * // Update or create a OfferApprover
     * const offerApprover = await prisma.offerApprover.upsert({
     *   create: {
     *     // ... data to create a OfferApprover
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OfferApprover we want to update
     *   }
     * })
    **/
    upsert<T extends OfferApproverUpsertArgs>(
      args: SelectSubset<T, OfferApproverUpsertArgs>
    ): CheckSelect<T, Prisma__OfferApproverClient<OfferApprover>, Prisma__OfferApproverClient<OfferApproverGetPayload<T>>>

    /**
     * Count the number of OfferApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferApproverCountArgs} args - Arguments to filter OfferApprovers to count.
     * @example
     * // Count the number of OfferApprovers
     * const count = await prisma.offerApprover.count({
     *   where: {
     *     // ... the filter for the OfferApprovers we want to count
     *   }
     * })
    **/
    count<T extends OfferApproverCountArgs>(
      args?: Subset<T, OfferApproverCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfferApproverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OfferApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferApproverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfferApproverAggregateArgs>(args: Subset<T, OfferApproverAggregateArgs>): PrismaPromise<GetOfferApproverAggregateType<T>>

    /**
     * Group by OfferApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferApproverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfferApproverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfferApproverGroupByArgs['orderBy'] }
        : { orderBy?: OfferApproverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfferApproverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfferApproverGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for OfferApprover.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OfferApproverClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    member<T extends MemberArgs = {}>(args?: Subset<T, MemberArgs>): CheckSelect<T, Prisma__MemberClient<Member | null >, Prisma__MemberClient<MemberGetPayload<T> | null >>;

    offer<T extends OfferArgs = {}>(args?: Subset<T, OfferArgs>): CheckSelect<T, Prisma__OfferClient<Offer | null >, Prisma__OfferClient<OfferGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * OfferApprover findUnique
   */
  export type OfferApproverFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the OfferApprover
     * 
    **/
    select?: OfferApproverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OfferApproverInclude | null
    /**
     * Throw an Error if a OfferApprover can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which OfferApprover to fetch.
     * 
    **/
    where: OfferApproverWhereUniqueInput
  }


  /**
   * OfferApprover findFirst
   */
  export type OfferApproverFindFirstArgs = {
    /**
     * Select specific fields to fetch from the OfferApprover
     * 
    **/
    select?: OfferApproverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OfferApproverInclude | null
    /**
     * Throw an Error if a OfferApprover can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which OfferApprover to fetch.
     * 
    **/
    where?: OfferApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferApprovers to fetch.
     * 
    **/
    orderBy?: Enumerable<OfferApproverOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfferApprovers.
     * 
    **/
    cursor?: OfferApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferApprovers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferApprovers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfferApprovers.
     * 
    **/
    distinct?: Enumerable<OfferApproverScalarFieldEnum>
  }


  /**
   * OfferApprover findMany
   */
  export type OfferApproverFindManyArgs = {
    /**
     * Select specific fields to fetch from the OfferApprover
     * 
    **/
    select?: OfferApproverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OfferApproverInclude | null
    /**
     * Filter, which OfferApprovers to fetch.
     * 
    **/
    where?: OfferApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferApprovers to fetch.
     * 
    **/
    orderBy?: Enumerable<OfferApproverOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OfferApprovers.
     * 
    **/
    cursor?: OfferApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferApprovers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferApprovers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OfferApproverScalarFieldEnum>
  }


  /**
   * OfferApprover create
   */
  export type OfferApproverCreateArgs = {
    /**
     * Select specific fields to fetch from the OfferApprover
     * 
    **/
    select?: OfferApproverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OfferApproverInclude | null
    /**
     * The data needed to create a OfferApprover.
     * 
    **/
    data: XOR<OfferApproverCreateInput, OfferApproverUncheckedCreateInput>
  }


  /**
   * OfferApprover createMany
   */
  export type OfferApproverCreateManyArgs = {
    /**
     * The data used to create many OfferApprovers.
     * 
    **/
    data: Enumerable<OfferApproverCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OfferApprover update
   */
  export type OfferApproverUpdateArgs = {
    /**
     * Select specific fields to fetch from the OfferApprover
     * 
    **/
    select?: OfferApproverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OfferApproverInclude | null
    /**
     * The data needed to update a OfferApprover.
     * 
    **/
    data: XOR<OfferApproverUpdateInput, OfferApproverUncheckedUpdateInput>
    /**
     * Choose, which OfferApprover to update.
     * 
    **/
    where: OfferApproverWhereUniqueInput
  }


  /**
   * OfferApprover updateMany
   */
  export type OfferApproverUpdateManyArgs = {
    /**
     * The data used to update OfferApprovers.
     * 
    **/
    data: XOR<OfferApproverUpdateManyMutationInput, OfferApproverUncheckedUpdateManyInput>
    /**
     * Filter which OfferApprovers to update
     * 
    **/
    where?: OfferApproverWhereInput
  }


  /**
   * OfferApprover upsert
   */
  export type OfferApproverUpsertArgs = {
    /**
     * Select specific fields to fetch from the OfferApprover
     * 
    **/
    select?: OfferApproverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OfferApproverInclude | null
    /**
     * The filter to search for the OfferApprover to update in case it exists.
     * 
    **/
    where: OfferApproverWhereUniqueInput
    /**
     * In case the OfferApprover found by the `where` argument doesn't exist, create a new OfferApprover with this data.
     * 
    **/
    create: XOR<OfferApproverCreateInput, OfferApproverUncheckedCreateInput>
    /**
     * In case the OfferApprover was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OfferApproverUpdateInput, OfferApproverUncheckedUpdateInput>
  }


  /**
   * OfferApprover delete
   */
  export type OfferApproverDeleteArgs = {
    /**
     * Select specific fields to fetch from the OfferApprover
     * 
    **/
    select?: OfferApproverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OfferApproverInclude | null
    /**
     * Filter which OfferApprover to delete.
     * 
    **/
    where: OfferApproverWhereUniqueInput
  }


  /**
   * OfferApprover deleteMany
   */
  export type OfferApproverDeleteManyArgs = {
    /**
     * Filter which OfferApprovers to delete
     * 
    **/
    where?: OfferApproverWhereInput
  }


  /**
   * OfferApprover without action
   */
  export type OfferApproverArgs = {
    /**
     * Select specific fields to fetch from the OfferApprover
     * 
    **/
    select?: OfferApproverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OfferApproverInclude | null
  }



  /**
   * Model Appointment
   */


  export type AggregateAppointment = {
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  export type AppointmentAvgAggregateOutputType = {
    shopId: number | null
  }

  export type AppointmentSumAggregateOutputType = {
    shopId: number | null
  }

  export type AppointmentMinAggregateOutputType = {
    username: string | null
    shopId: number | null
    assigner: string | null
  }

  export type AppointmentMaxAggregateOutputType = {
    username: string | null
    shopId: number | null
    assigner: string | null
  }

  export type AppointmentCountAggregateOutputType = {
    username: number
    shopId: number
    assigner: number
    _all: number
  }


  export type AppointmentAvgAggregateInputType = {
    shopId?: true
  }

  export type AppointmentSumAggregateInputType = {
    shopId?: true
  }

  export type AppointmentMinAggregateInputType = {
    username?: true
    shopId?: true
    assigner?: true
  }

  export type AppointmentMaxAggregateInputType = {
    username?: true
    shopId?: true
    assigner?: true
  }

  export type AppointmentCountAggregateInputType = {
    username?: true
    shopId?: true
    assigner?: true
    _all?: true
  }

  export type AppointmentAggregateArgs = {
    /**
     * Filter which Appointment to aggregate.
     * 
    **/
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     * 
    **/
    orderBy?: Enumerable<AppointmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Appointments
    **/
    _count?: true | AppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppointmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppointmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentMaxAggregateInputType
  }

  export type GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointment[P]>
      : GetScalarType<T[P], AggregateAppointment[P]>
  }




  export type AppointmentGroupByArgs = {
    where?: AppointmentWhereInput
    orderBy?: Enumerable<AppointmentOrderByWithAggregationInput>
    by: Array<AppointmentScalarFieldEnum>
    having?: AppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentCountAggregateInputType | true
    _avg?: AppointmentAvgAggregateInputType
    _sum?: AppointmentSumAggregateInputType
    _min?: AppointmentMinAggregateInputType
    _max?: AppointmentMaxAggregateInputType
  }


  export type AppointmentGroupByOutputType = {
    username: string
    shopId: number
    assigner: string
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  type GetAppointmentGroupByPayload<T extends AppointmentGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentSelect = {
    member?: boolean | MemberArgs
    username?: boolean
    shop?: boolean | ShopArgs
    shopId?: boolean
    assigner?: boolean
    appointmentAgreements?: boolean | AppointmentAgreementFindManyArgs
    _count?: boolean | AppointmentCountOutputTypeArgs
  }

  export type AppointmentInclude = {
    member?: boolean | MemberArgs
    shop?: boolean | ShopArgs
    appointmentAgreements?: boolean | AppointmentAgreementFindManyArgs
    _count?: boolean | AppointmentCountOutputTypeArgs
  }

  export type AppointmentGetPayload<
    S extends boolean | null | undefined | AppointmentArgs,
    U = keyof S
      > = S extends true
        ? Appointment
    : S extends undefined
    ? never
    : S extends AppointmentArgs | AppointmentFindManyArgs
    ?'include' extends U
    ? Appointment  & {
    [P in TrueKeys<S['include']>]:
        P extends 'member' ? MemberGetPayload<S['include'][P]> :
        P extends 'shop' ? ShopGetPayload<S['include'][P]> :
        P extends 'appointmentAgreements' ? Array < AppointmentAgreementGetPayload<S['include'][P]>>  :
        P extends '_count' ? AppointmentCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'member' ? MemberGetPayload<S['select'][P]> :
        P extends 'shop' ? ShopGetPayload<S['select'][P]> :
        P extends 'appointmentAgreements' ? Array < AppointmentAgreementGetPayload<S['select'][P]>>  :
        P extends '_count' ? AppointmentCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Appointment ? Appointment[P] : never
  } 
    : Appointment
  : Appointment


  type AppointmentCountArgs = Merge<
    Omit<AppointmentFindManyArgs, 'select' | 'include'> & {
      select?: AppointmentCountAggregateInputType | true
    }
  >

  export interface AppointmentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Appointment that matches the filter.
     * @param {AppointmentFindUniqueArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AppointmentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AppointmentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Appointment'> extends True ? CheckSelect<T, Prisma__AppointmentClient<Appointment>, Prisma__AppointmentClient<AppointmentGetPayload<T>>> : CheckSelect<T, Prisma__AppointmentClient<Appointment | null >, Prisma__AppointmentClient<AppointmentGetPayload<T> | null >>

    /**
     * Find the first Appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AppointmentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AppointmentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Appointment'> extends True ? CheckSelect<T, Prisma__AppointmentClient<Appointment>, Prisma__AppointmentClient<AppointmentGetPayload<T>>> : CheckSelect<T, Prisma__AppointmentClient<Appointment | null >, Prisma__AppointmentClient<AppointmentGetPayload<T> | null >>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointment.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointment.findMany({ take: 10 })
     * 
     * // Only select the `username`
     * const appointmentWithUsernameOnly = await prisma.appointment.findMany({ select: { username: true } })
     * 
    **/
    findMany<T extends AppointmentFindManyArgs>(
      args?: SelectSubset<T, AppointmentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Appointment>>, PrismaPromise<Array<AppointmentGetPayload<T>>>>

    /**
     * Create a Appointment.
     * @param {AppointmentCreateArgs} args - Arguments to create a Appointment.
     * @example
     * // Create one Appointment
     * const Appointment = await prisma.appointment.create({
     *   data: {
     *     // ... data to create a Appointment
     *   }
     * })
     * 
    **/
    create<T extends AppointmentCreateArgs>(
      args: SelectSubset<T, AppointmentCreateArgs>
    ): CheckSelect<T, Prisma__AppointmentClient<Appointment>, Prisma__AppointmentClient<AppointmentGetPayload<T>>>

    /**
     * Create many Appointments.
     *     @param {AppointmentCreateManyArgs} args - Arguments to create many Appointments.
     *     @example
     *     // Create many Appointments
     *     const appointment = await prisma.appointment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AppointmentCreateManyArgs>(
      args?: SelectSubset<T, AppointmentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Appointment.
     * @param {AppointmentDeleteArgs} args - Arguments to delete one Appointment.
     * @example
     * // Delete one Appointment
     * const Appointment = await prisma.appointment.delete({
     *   where: {
     *     // ... filter to delete one Appointment
     *   }
     * })
     * 
    **/
    delete<T extends AppointmentDeleteArgs>(
      args: SelectSubset<T, AppointmentDeleteArgs>
    ): CheckSelect<T, Prisma__AppointmentClient<Appointment>, Prisma__AppointmentClient<AppointmentGetPayload<T>>>

    /**
     * Update one Appointment.
     * @param {AppointmentUpdateArgs} args - Arguments to update one Appointment.
     * @example
     * // Update one Appointment
     * const appointment = await prisma.appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AppointmentUpdateArgs>(
      args: SelectSubset<T, AppointmentUpdateArgs>
    ): CheckSelect<T, Prisma__AppointmentClient<Appointment>, Prisma__AppointmentClient<AppointmentGetPayload<T>>>

    /**
     * Delete zero or more Appointments.
     * @param {AppointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AppointmentDeleteManyArgs>(
      args?: SelectSubset<T, AppointmentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AppointmentUpdateManyArgs>(
      args: SelectSubset<T, AppointmentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Appointment.
     * @param {AppointmentUpsertArgs} args - Arguments to update or create a Appointment.
     * @example
     * // Update or create a Appointment
     * const appointment = await prisma.appointment.upsert({
     *   create: {
     *     // ... data to create a Appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment we want to update
     *   }
     * })
    **/
    upsert<T extends AppointmentUpsertArgs>(
      args: SelectSubset<T, AppointmentUpsertArgs>
    ): CheckSelect<T, Prisma__AppointmentClient<Appointment>, Prisma__AppointmentClient<AppointmentGetPayload<T>>>

    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointment.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends AppointmentCountArgs>(
      args?: Subset<T, AppointmentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAggregateArgs>(args: Subset<T, AppointmentAggregateArgs>): PrismaPromise<GetAppointmentAggregateType<T>>

    /**
     * Group by Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Appointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AppointmentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    member<T extends MemberArgs = {}>(args?: Subset<T, MemberArgs>): CheckSelect<T, Prisma__MemberClient<Member | null >, Prisma__MemberClient<MemberGetPayload<T> | null >>;

    shop<T extends ShopArgs = {}>(args?: Subset<T, ShopArgs>): CheckSelect<T, Prisma__ShopClient<Shop | null >, Prisma__ShopClient<ShopGetPayload<T> | null >>;

    appointmentAgreements<T extends AppointmentAgreementFindManyArgs = {}>(args?: Subset<T, AppointmentAgreementFindManyArgs>): CheckSelect<T, PrismaPromise<Array<AppointmentAgreement>>, PrismaPromise<Array<AppointmentAgreementGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Appointment findUnique
   */
  export type AppointmentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Appointment
     * 
    **/
    select?: AppointmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AppointmentInclude | null
    /**
     * Throw an Error if a Appointment can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Appointment to fetch.
     * 
    **/
    where: AppointmentWhereUniqueInput
  }


  /**
   * Appointment findFirst
   */
  export type AppointmentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Appointment
     * 
    **/
    select?: AppointmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AppointmentInclude | null
    /**
     * Throw an Error if a Appointment can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Appointment to fetch.
     * 
    **/
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     * 
    **/
    orderBy?: Enumerable<AppointmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     * 
    **/
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     * 
    **/
    distinct?: Enumerable<AppointmentScalarFieldEnum>
  }


  /**
   * Appointment findMany
   */
  export type AppointmentFindManyArgs = {
    /**
     * Select specific fields to fetch from the Appointment
     * 
    **/
    select?: AppointmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AppointmentInclude | null
    /**
     * Filter, which Appointments to fetch.
     * 
    **/
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     * 
    **/
    orderBy?: Enumerable<AppointmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Appointments.
     * 
    **/
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AppointmentScalarFieldEnum>
  }


  /**
   * Appointment create
   */
  export type AppointmentCreateArgs = {
    /**
     * Select specific fields to fetch from the Appointment
     * 
    **/
    select?: AppointmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AppointmentInclude | null
    /**
     * The data needed to create a Appointment.
     * 
    **/
    data: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
  }


  /**
   * Appointment createMany
   */
  export type AppointmentCreateManyArgs = {
    /**
     * The data used to create many Appointments.
     * 
    **/
    data: Enumerable<AppointmentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Appointment update
   */
  export type AppointmentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Appointment
     * 
    **/
    select?: AppointmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AppointmentInclude | null
    /**
     * The data needed to update a Appointment.
     * 
    **/
    data: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
    /**
     * Choose, which Appointment to update.
     * 
    **/
    where: AppointmentWhereUniqueInput
  }


  /**
   * Appointment updateMany
   */
  export type AppointmentUpdateManyArgs = {
    /**
     * The data used to update Appointments.
     * 
    **/
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     * 
    **/
    where?: AppointmentWhereInput
  }


  /**
   * Appointment upsert
   */
  export type AppointmentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Appointment
     * 
    **/
    select?: AppointmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AppointmentInclude | null
    /**
     * The filter to search for the Appointment to update in case it exists.
     * 
    **/
    where: AppointmentWhereUniqueInput
    /**
     * In case the Appointment found by the `where` argument doesn't exist, create a new Appointment with this data.
     * 
    **/
    create: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
    /**
     * In case the Appointment was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
  }


  /**
   * Appointment delete
   */
  export type AppointmentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Appointment
     * 
    **/
    select?: AppointmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AppointmentInclude | null
    /**
     * Filter which Appointment to delete.
     * 
    **/
    where: AppointmentWhereUniqueInput
  }


  /**
   * Appointment deleteMany
   */
  export type AppointmentDeleteManyArgs = {
    /**
     * Filter which Appointments to delete
     * 
    **/
    where?: AppointmentWhereInput
  }


  /**
   * Appointment without action
   */
  export type AppointmentArgs = {
    /**
     * Select specific fields to fetch from the Appointment
     * 
    **/
    select?: AppointmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AppointmentInclude | null
  }



  /**
   * Model AppointmentAgreement
   */


  export type AggregateAppointmentAgreement = {
    _count: AppointmentAgreementCountAggregateOutputType | null
    _avg: AppointmentAgreementAvgAggregateOutputType | null
    _sum: AppointmentAgreementSumAggregateOutputType | null
    _min: AppointmentAgreementMinAggregateOutputType | null
    _max: AppointmentAgreementMaxAggregateOutputType | null
  }

  export type AppointmentAgreementAvgAggregateOutputType = {
    shopId: number | null
  }

  export type AppointmentAgreementSumAggregateOutputType = {
    shopId: number | null
  }

  export type AppointmentAgreementMinAggregateOutputType = {
    username: string | null
    shopId: number | null
    approver: string | null
    answered: boolean | null
    approved: boolean | null
  }

  export type AppointmentAgreementMaxAggregateOutputType = {
    username: string | null
    shopId: number | null
    approver: string | null
    answered: boolean | null
    approved: boolean | null
  }

  export type AppointmentAgreementCountAggregateOutputType = {
    username: number
    shopId: number
    approver: number
    answered: number
    approved: number
    _all: number
  }


  export type AppointmentAgreementAvgAggregateInputType = {
    shopId?: true
  }

  export type AppointmentAgreementSumAggregateInputType = {
    shopId?: true
  }

  export type AppointmentAgreementMinAggregateInputType = {
    username?: true
    shopId?: true
    approver?: true
    answered?: true
    approved?: true
  }

  export type AppointmentAgreementMaxAggregateInputType = {
    username?: true
    shopId?: true
    approver?: true
    answered?: true
    approved?: true
  }

  export type AppointmentAgreementCountAggregateInputType = {
    username?: true
    shopId?: true
    approver?: true
    answered?: true
    approved?: true
    _all?: true
  }

  export type AppointmentAgreementAggregateArgs = {
    /**
     * Filter which AppointmentAgreement to aggregate.
     * 
    **/
    where?: AppointmentAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppointmentAgreements to fetch.
     * 
    **/
    orderBy?: Enumerable<AppointmentAgreementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AppointmentAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppointmentAgreements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppointmentAgreements.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AppointmentAgreements
    **/
    _count?: true | AppointmentAgreementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppointmentAgreementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppointmentAgreementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentAgreementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentAgreementMaxAggregateInputType
  }

  export type GetAppointmentAgreementAggregateType<T extends AppointmentAgreementAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointmentAgreement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointmentAgreement[P]>
      : GetScalarType<T[P], AggregateAppointmentAgreement[P]>
  }




  export type AppointmentAgreementGroupByArgs = {
    where?: AppointmentAgreementWhereInput
    orderBy?: Enumerable<AppointmentAgreementOrderByWithAggregationInput>
    by: Array<AppointmentAgreementScalarFieldEnum>
    having?: AppointmentAgreementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentAgreementCountAggregateInputType | true
    _avg?: AppointmentAgreementAvgAggregateInputType
    _sum?: AppointmentAgreementSumAggregateInputType
    _min?: AppointmentAgreementMinAggregateInputType
    _max?: AppointmentAgreementMaxAggregateInputType
  }


  export type AppointmentAgreementGroupByOutputType = {
    username: string
    shopId: number
    approver: string
    answered: boolean
    approved: boolean
    _count: AppointmentAgreementCountAggregateOutputType | null
    _avg: AppointmentAgreementAvgAggregateOutputType | null
    _sum: AppointmentAgreementSumAggregateOutputType | null
    _min: AppointmentAgreementMinAggregateOutputType | null
    _max: AppointmentAgreementMaxAggregateOutputType | null
  }

  type GetAppointmentAgreementGroupByPayload<T extends AppointmentAgreementGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AppointmentAgreementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentAgreementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentAgreementGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentAgreementGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentAgreementSelect = {
    appointment?: boolean | AppointmentArgs
    username?: boolean
    shopId?: boolean
    approver?: boolean
    answered?: boolean
    approved?: boolean
  }

  export type AppointmentAgreementInclude = {
    appointment?: boolean | AppointmentArgs
  }

  export type AppointmentAgreementGetPayload<
    S extends boolean | null | undefined | AppointmentAgreementArgs,
    U = keyof S
      > = S extends true
        ? AppointmentAgreement
    : S extends undefined
    ? never
    : S extends AppointmentAgreementArgs | AppointmentAgreementFindManyArgs
    ?'include' extends U
    ? AppointmentAgreement  & {
    [P in TrueKeys<S['include']>]:
        P extends 'appointment' ? AppointmentGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'appointment' ? AppointmentGetPayload<S['select'][P]> :  P extends keyof AppointmentAgreement ? AppointmentAgreement[P] : never
  } 
    : AppointmentAgreement
  : AppointmentAgreement


  type AppointmentAgreementCountArgs = Merge<
    Omit<AppointmentAgreementFindManyArgs, 'select' | 'include'> & {
      select?: AppointmentAgreementCountAggregateInputType | true
    }
  >

  export interface AppointmentAgreementDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one AppointmentAgreement that matches the filter.
     * @param {AppointmentAgreementFindUniqueArgs} args - Arguments to find a AppointmentAgreement
     * @example
     * // Get one AppointmentAgreement
     * const appointmentAgreement = await prisma.appointmentAgreement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AppointmentAgreementFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AppointmentAgreementFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AppointmentAgreement'> extends True ? CheckSelect<T, Prisma__AppointmentAgreementClient<AppointmentAgreement>, Prisma__AppointmentAgreementClient<AppointmentAgreementGetPayload<T>>> : CheckSelect<T, Prisma__AppointmentAgreementClient<AppointmentAgreement | null >, Prisma__AppointmentAgreementClient<AppointmentAgreementGetPayload<T> | null >>

    /**
     * Find the first AppointmentAgreement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAgreementFindFirstArgs} args - Arguments to find a AppointmentAgreement
     * @example
     * // Get one AppointmentAgreement
     * const appointmentAgreement = await prisma.appointmentAgreement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AppointmentAgreementFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AppointmentAgreementFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AppointmentAgreement'> extends True ? CheckSelect<T, Prisma__AppointmentAgreementClient<AppointmentAgreement>, Prisma__AppointmentAgreementClient<AppointmentAgreementGetPayload<T>>> : CheckSelect<T, Prisma__AppointmentAgreementClient<AppointmentAgreement | null >, Prisma__AppointmentAgreementClient<AppointmentAgreementGetPayload<T> | null >>

    /**
     * Find zero or more AppointmentAgreements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAgreementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AppointmentAgreements
     * const appointmentAgreements = await prisma.appointmentAgreement.findMany()
     * 
     * // Get first 10 AppointmentAgreements
     * const appointmentAgreements = await prisma.appointmentAgreement.findMany({ take: 10 })
     * 
     * // Only select the `username`
     * const appointmentAgreementWithUsernameOnly = await prisma.appointmentAgreement.findMany({ select: { username: true } })
     * 
    **/
    findMany<T extends AppointmentAgreementFindManyArgs>(
      args?: SelectSubset<T, AppointmentAgreementFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AppointmentAgreement>>, PrismaPromise<Array<AppointmentAgreementGetPayload<T>>>>

    /**
     * Create a AppointmentAgreement.
     * @param {AppointmentAgreementCreateArgs} args - Arguments to create a AppointmentAgreement.
     * @example
     * // Create one AppointmentAgreement
     * const AppointmentAgreement = await prisma.appointmentAgreement.create({
     *   data: {
     *     // ... data to create a AppointmentAgreement
     *   }
     * })
     * 
    **/
    create<T extends AppointmentAgreementCreateArgs>(
      args: SelectSubset<T, AppointmentAgreementCreateArgs>
    ): CheckSelect<T, Prisma__AppointmentAgreementClient<AppointmentAgreement>, Prisma__AppointmentAgreementClient<AppointmentAgreementGetPayload<T>>>

    /**
     * Create many AppointmentAgreements.
     *     @param {AppointmentAgreementCreateManyArgs} args - Arguments to create many AppointmentAgreements.
     *     @example
     *     // Create many AppointmentAgreements
     *     const appointmentAgreement = await prisma.appointmentAgreement.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AppointmentAgreementCreateManyArgs>(
      args?: SelectSubset<T, AppointmentAgreementCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AppointmentAgreement.
     * @param {AppointmentAgreementDeleteArgs} args - Arguments to delete one AppointmentAgreement.
     * @example
     * // Delete one AppointmentAgreement
     * const AppointmentAgreement = await prisma.appointmentAgreement.delete({
     *   where: {
     *     // ... filter to delete one AppointmentAgreement
     *   }
     * })
     * 
    **/
    delete<T extends AppointmentAgreementDeleteArgs>(
      args: SelectSubset<T, AppointmentAgreementDeleteArgs>
    ): CheckSelect<T, Prisma__AppointmentAgreementClient<AppointmentAgreement>, Prisma__AppointmentAgreementClient<AppointmentAgreementGetPayload<T>>>

    /**
     * Update one AppointmentAgreement.
     * @param {AppointmentAgreementUpdateArgs} args - Arguments to update one AppointmentAgreement.
     * @example
     * // Update one AppointmentAgreement
     * const appointmentAgreement = await prisma.appointmentAgreement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AppointmentAgreementUpdateArgs>(
      args: SelectSubset<T, AppointmentAgreementUpdateArgs>
    ): CheckSelect<T, Prisma__AppointmentAgreementClient<AppointmentAgreement>, Prisma__AppointmentAgreementClient<AppointmentAgreementGetPayload<T>>>

    /**
     * Delete zero or more AppointmentAgreements.
     * @param {AppointmentAgreementDeleteManyArgs} args - Arguments to filter AppointmentAgreements to delete.
     * @example
     * // Delete a few AppointmentAgreements
     * const { count } = await prisma.appointmentAgreement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AppointmentAgreementDeleteManyArgs>(
      args?: SelectSubset<T, AppointmentAgreementDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppointmentAgreements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAgreementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AppointmentAgreements
     * const appointmentAgreement = await prisma.appointmentAgreement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AppointmentAgreementUpdateManyArgs>(
      args: SelectSubset<T, AppointmentAgreementUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AppointmentAgreement.
     * @param {AppointmentAgreementUpsertArgs} args - Arguments to update or create a AppointmentAgreement.
     * @example
     * // Update or create a AppointmentAgreement
     * const appointmentAgreement = await prisma.appointmentAgreement.upsert({
     *   create: {
     *     // ... data to create a AppointmentAgreement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AppointmentAgreement we want to update
     *   }
     * })
    **/
    upsert<T extends AppointmentAgreementUpsertArgs>(
      args: SelectSubset<T, AppointmentAgreementUpsertArgs>
    ): CheckSelect<T, Prisma__AppointmentAgreementClient<AppointmentAgreement>, Prisma__AppointmentAgreementClient<AppointmentAgreementGetPayload<T>>>

    /**
     * Count the number of AppointmentAgreements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAgreementCountArgs} args - Arguments to filter AppointmentAgreements to count.
     * @example
     * // Count the number of AppointmentAgreements
     * const count = await prisma.appointmentAgreement.count({
     *   where: {
     *     // ... the filter for the AppointmentAgreements we want to count
     *   }
     * })
    **/
    count<T extends AppointmentAgreementCountArgs>(
      args?: Subset<T, AppointmentAgreementCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentAgreementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AppointmentAgreement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAgreementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAgreementAggregateArgs>(args: Subset<T, AppointmentAgreementAggregateArgs>): PrismaPromise<GetAppointmentAgreementAggregateType<T>>

    /**
     * Group by AppointmentAgreement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAgreementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentAgreementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentAgreementGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentAgreementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentAgreementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentAgreementGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for AppointmentAgreement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AppointmentAgreementClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    appointment<T extends AppointmentArgs = {}>(args?: Subset<T, AppointmentArgs>): CheckSelect<T, Prisma__AppointmentClient<Appointment | null >, Prisma__AppointmentClient<AppointmentGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * AppointmentAgreement findUnique
   */
  export type AppointmentAgreementFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the AppointmentAgreement
     * 
    **/
    select?: AppointmentAgreementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AppointmentAgreementInclude | null
    /**
     * Throw an Error if a AppointmentAgreement can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AppointmentAgreement to fetch.
     * 
    **/
    where: AppointmentAgreementWhereUniqueInput
  }


  /**
   * AppointmentAgreement findFirst
   */
  export type AppointmentAgreementFindFirstArgs = {
    /**
     * Select specific fields to fetch from the AppointmentAgreement
     * 
    **/
    select?: AppointmentAgreementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AppointmentAgreementInclude | null
    /**
     * Throw an Error if a AppointmentAgreement can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AppointmentAgreement to fetch.
     * 
    **/
    where?: AppointmentAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppointmentAgreements to fetch.
     * 
    **/
    orderBy?: Enumerable<AppointmentAgreementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppointmentAgreements.
     * 
    **/
    cursor?: AppointmentAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppointmentAgreements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppointmentAgreements.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppointmentAgreements.
     * 
    **/
    distinct?: Enumerable<AppointmentAgreementScalarFieldEnum>
  }


  /**
   * AppointmentAgreement findMany
   */
  export type AppointmentAgreementFindManyArgs = {
    /**
     * Select specific fields to fetch from the AppointmentAgreement
     * 
    **/
    select?: AppointmentAgreementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AppointmentAgreementInclude | null
    /**
     * Filter, which AppointmentAgreements to fetch.
     * 
    **/
    where?: AppointmentAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppointmentAgreements to fetch.
     * 
    **/
    orderBy?: Enumerable<AppointmentAgreementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AppointmentAgreements.
     * 
    **/
    cursor?: AppointmentAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppointmentAgreements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppointmentAgreements.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AppointmentAgreementScalarFieldEnum>
  }


  /**
   * AppointmentAgreement create
   */
  export type AppointmentAgreementCreateArgs = {
    /**
     * Select specific fields to fetch from the AppointmentAgreement
     * 
    **/
    select?: AppointmentAgreementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AppointmentAgreementInclude | null
    /**
     * The data needed to create a AppointmentAgreement.
     * 
    **/
    data: XOR<AppointmentAgreementCreateInput, AppointmentAgreementUncheckedCreateInput>
  }


  /**
   * AppointmentAgreement createMany
   */
  export type AppointmentAgreementCreateManyArgs = {
    /**
     * The data used to create many AppointmentAgreements.
     * 
    **/
    data: Enumerable<AppointmentAgreementCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AppointmentAgreement update
   */
  export type AppointmentAgreementUpdateArgs = {
    /**
     * Select specific fields to fetch from the AppointmentAgreement
     * 
    **/
    select?: AppointmentAgreementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AppointmentAgreementInclude | null
    /**
     * The data needed to update a AppointmentAgreement.
     * 
    **/
    data: XOR<AppointmentAgreementUpdateInput, AppointmentAgreementUncheckedUpdateInput>
    /**
     * Choose, which AppointmentAgreement to update.
     * 
    **/
    where: AppointmentAgreementWhereUniqueInput
  }


  /**
   * AppointmentAgreement updateMany
   */
  export type AppointmentAgreementUpdateManyArgs = {
    /**
     * The data used to update AppointmentAgreements.
     * 
    **/
    data: XOR<AppointmentAgreementUpdateManyMutationInput, AppointmentAgreementUncheckedUpdateManyInput>
    /**
     * Filter which AppointmentAgreements to update
     * 
    **/
    where?: AppointmentAgreementWhereInput
  }


  /**
   * AppointmentAgreement upsert
   */
  export type AppointmentAgreementUpsertArgs = {
    /**
     * Select specific fields to fetch from the AppointmentAgreement
     * 
    **/
    select?: AppointmentAgreementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AppointmentAgreementInclude | null
    /**
     * The filter to search for the AppointmentAgreement to update in case it exists.
     * 
    **/
    where: AppointmentAgreementWhereUniqueInput
    /**
     * In case the AppointmentAgreement found by the `where` argument doesn't exist, create a new AppointmentAgreement with this data.
     * 
    **/
    create: XOR<AppointmentAgreementCreateInput, AppointmentAgreementUncheckedCreateInput>
    /**
     * In case the AppointmentAgreement was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AppointmentAgreementUpdateInput, AppointmentAgreementUncheckedUpdateInput>
  }


  /**
   * AppointmentAgreement delete
   */
  export type AppointmentAgreementDeleteArgs = {
    /**
     * Select specific fields to fetch from the AppointmentAgreement
     * 
    **/
    select?: AppointmentAgreementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AppointmentAgreementInclude | null
    /**
     * Filter which AppointmentAgreement to delete.
     * 
    **/
    where: AppointmentAgreementWhereUniqueInput
  }


  /**
   * AppointmentAgreement deleteMany
   */
  export type AppointmentAgreementDeleteManyArgs = {
    /**
     * Filter which AppointmentAgreements to delete
     * 
    **/
    where?: AppointmentAgreementWhereInput
  }


  /**
   * AppointmentAgreement without action
   */
  export type AppointmentAgreementArgs = {
    /**
     * Select specific fields to fetch from the AppointmentAgreement
     * 
    **/
    select?: AppointmentAgreementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AppointmentAgreementInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const MemberScalarFieldEnum: {
    username: 'username'
  };

  export type MemberScalarFieldEnum = (typeof MemberScalarFieldEnum)[keyof typeof MemberScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    username: 'username',
    shopId: 'shopId',
    job_type: 'job_type',
    permissions: 'permissions'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    shopId: 'shopId',
    category: 'category',
    rate: 'rate',
    description: 'description'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ShopScalarFieldEnum: {
    id: 'id',
    name: 'name',
    status: 'status',
    shop_founder: 'shop_founder',
    rate: 'rate',
    description: 'description'
  };

  export type ShopScalarFieldEnum = (typeof ShopScalarFieldEnum)[keyof typeof ShopScalarFieldEnum]


  export const ShopOwnerScalarFieldEnum: {
    username: 'username',
    shopId: 'shopId'
  };

  export type ShopOwnerScalarFieldEnum = (typeof ShopOwnerScalarFieldEnum)[keyof typeof ShopOwnerScalarFieldEnum]


  export const ShopManagerScalarFieldEnum: {
    username: 'username',
    shopId: 'shopId'
  };

  export type ShopManagerScalarFieldEnum = (typeof ShopManagerScalarFieldEnum)[keyof typeof ShopManagerScalarFieldEnum]


  export const ProductInShopScalarFieldEnum: {
    shopId: 'shopId',
    productId: 'productId',
    product_quantity: 'product_quantity'
  };

  export type ProductInShopScalarFieldEnum = (typeof ProductInShopScalarFieldEnum)[keyof typeof ProductInShopScalarFieldEnum]


  export const ShoppingCartScalarFieldEnum: {
    username: 'username'
  };

  export type ShoppingCartScalarFieldEnum = (typeof ShoppingCartScalarFieldEnum)[keyof typeof ShoppingCartScalarFieldEnum]


  export const ShoppingBagScalarFieldEnum: {
    username: 'username',
    shopId: 'shopId'
  };

  export type ShoppingBagScalarFieldEnum = (typeof ShoppingBagScalarFieldEnum)[keyof typeof ShoppingBagScalarFieldEnum]


  export const ProductInBagScalarFieldEnum: {
    username: 'username',
    shopId: 'shopId',
    productId: 'productId',
    product_quantity: 'product_quantity'
  };

  export type ProductInBagScalarFieldEnum = (typeof ProductInBagScalarFieldEnum)[keyof typeof ProductInBagScalarFieldEnum]


  export const MemberCredentialsScalarFieldEnum: {
    username: 'username',
    password: 'password'
  };

  export type MemberCredentialsScalarFieldEnum = (typeof MemberCredentialsScalarFieldEnum)[keyof typeof MemberCredentialsScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    isRead: 'isRead',
    messageType: 'messageType'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const MessageRecipientsScalarFieldEnum: {
    messageId: 'messageId',
    username: 'username'
  };

  export type MessageRecipientsScalarFieldEnum = (typeof MessageRecipientsScalarFieldEnum)[keyof typeof MessageRecipientsScalarFieldEnum]


  export const DiscountScalarFieldEnum: {
    id: 'id',
    shopId: 'shopId',
    kind: 'kind'
  };

  export type DiscountScalarFieldEnum = (typeof DiscountScalarFieldEnum)[keyof typeof DiscountScalarFieldEnum]


  export const SimpleDiscountScalarFieldEnum: {
    id: 'id',
    shopId: 'shopId',
    discountType: 'discountType',
    discountPercent: 'discountPercent',
    description: 'description',
    productId: 'productId',
    category: 'category'
  };

  export type SimpleDiscountScalarFieldEnum = (typeof SimpleDiscountScalarFieldEnum)[keyof typeof SimpleDiscountScalarFieldEnum]


  export const ConditionalDiscountScalarFieldEnum: {
    id: 'id',
    shopId: 'shopId',
    simpleId: 'simpleId',
    simpleShopId: 'simpleShopId'
  };

  export type ConditionalDiscountScalarFieldEnum = (typeof ConditionalDiscountScalarFieldEnum)[keyof typeof ConditionalDiscountScalarFieldEnum]


  export const DiscountPredicateScalarFieldEnum: {
    discountId: 'discountId',
    shopId: 'shopId',
    discountType: 'discountType',
    relation: 'relation',
    value: 'value',
    description: 'description',
    productId: 'productId',
    category: 'category'
  };

  export type DiscountPredicateScalarFieldEnum = (typeof DiscountPredicateScalarFieldEnum)[keyof typeof DiscountPredicateScalarFieldEnum]


  export const DiscountContainerScalarFieldEnum: {
    id: 'id',
    shopId: 'shopId',
    description: 'description',
    type: 'type'
  };

  export type DiscountContainerScalarFieldEnum = (typeof DiscountContainerScalarFieldEnum)[keyof typeof DiscountContainerScalarFieldEnum]


  export const DiscountInContainerScalarFieldEnum: {
    containedDiscount: 'containedDiscount',
    shopId: 'shopId',
    containingDiscount: 'containingDiscount'
  };

  export type DiscountInContainerScalarFieldEnum = (typeof DiscountInContainerScalarFieldEnum)[keyof typeof DiscountInContainerScalarFieldEnum]


  export const PolicyScalarFieldEnum: {
    id: 'id',
    shopId: 'shopId'
  };

  export type PolicyScalarFieldEnum = (typeof PolicyScalarFieldEnum)[keyof typeof PolicyScalarFieldEnum]


  export const SimplePolicyScalarFieldEnum: {
    id: 'id',
    shopId: 'shopId',
    okay: 'okay',
    message: 'message'
  };

  export type SimplePolicyScalarFieldEnum = (typeof SimplePolicyScalarFieldEnum)[keyof typeof SimplePolicyScalarFieldEnum]


  export const ConditionalPolicyScalarFieldEnum: {
    id: 'id',
    shopId: 'shopId',
    dependent: 'dependent',
    dependentShopId: 'dependentShopId',
    dependentOn: 'dependentOn',
    dependentOnShopId: 'dependentOnShopId',
    description: 'description'
  };

  export type ConditionalPolicyScalarFieldEnum = (typeof ConditionalPolicyScalarFieldEnum)[keyof typeof ConditionalPolicyScalarFieldEnum]


  export const PolicyPredicateScalarFieldEnum: {
    policyId: 'policyId',
    shopId: 'shopId',
    policyType: 'policyType',
    relation: 'relation',
    value: 'value',
    description: 'description',
    productId: 'productId',
    productCategory: 'productCategory',
    guest: 'guest'
  };

  export type PolicyPredicateScalarFieldEnum = (typeof PolicyPredicateScalarFieldEnum)[keyof typeof PolicyPredicateScalarFieldEnum]


  export const LogicalPolicyScalarFieldEnum: {
    id: 'id',
    shopId: 'shopId',
    description: 'description',
    purchasePoliciesRelation: 'purchasePoliciesRelation'
  };

  export type LogicalPolicyScalarFieldEnum = (typeof LogicalPolicyScalarFieldEnum)[keyof typeof LogicalPolicyScalarFieldEnum]


  export const PolicyInContainerScalarFieldEnum: {
    containedPolicy: 'containedPolicy',
    shopId: 'shopId',
    containingPolicy: 'containingPolicy'
  };

  export type PolicyInContainerScalarFieldEnum = (typeof PolicyInContainerScalarFieldEnum)[keyof typeof PolicyInContainerScalarFieldEnum]


  export const OfferScalarFieldEnum: {
    id: 'id',
    username: 'username',
    shopId: 'shopId',
    productId: 'productId',
    price: 'price'
  };

  export type OfferScalarFieldEnum = (typeof OfferScalarFieldEnum)[keyof typeof OfferScalarFieldEnum]


  export const OfferApproverScalarFieldEnum: {
    username: 'username',
    offerId: 'offerId',
    answered: 'answered',
    approved: 'approved'
  };

  export type OfferApproverScalarFieldEnum = (typeof OfferApproverScalarFieldEnum)[keyof typeof OfferApproverScalarFieldEnum]


  export const AppointmentScalarFieldEnum: {
    username: 'username',
    shopId: 'shopId',
    assigner: 'assigner'
  };

  export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


  export const AppointmentAgreementScalarFieldEnum: {
    username: 'username',
    shopId: 'shopId',
    approver: 'approver',
    answered: 'answered',
    approved: 'approved'
  };

  export type AppointmentAgreementScalarFieldEnum = (typeof AppointmentAgreementScalarFieldEnum)[keyof typeof AppointmentAgreementScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type MemberWhereInput = {
    AND?: Enumerable<MemberWhereInput>
    OR?: Enumerable<MemberWhereInput>
    NOT?: Enumerable<MemberWhereInput>
    username?: StringFilter | string
    roles?: RoleListRelationFilter
    shops?: ShopListRelationFilter
    ShoppingCart?: XOR<ShoppingCartRelationFilter, ShoppingCartWhereInput> | null
    MemberCredentials?: XOR<MemberCredentialsRelationFilter, MemberCredentialsWhereInput> | null
    offers?: OfferListRelationFilter
    offerApprovers?: OfferApproverListRelationFilter
    appointments?: AppointmentListRelationFilter
    messageRecipients?: MessageRecipientsListRelationFilter
  }

  export type MemberOrderByWithRelationInput = {
    username?: SortOrder
    roles?: RoleOrderByRelationAggregateInput
    shops?: ShopOrderByRelationAggregateInput
    ShoppingCart?: ShoppingCartOrderByWithRelationInput
    MemberCredentials?: MemberCredentialsOrderByWithRelationInput
    offers?: OfferOrderByRelationAggregateInput
    offerApprovers?: OfferApproverOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    messageRecipients?: MessageRecipientsOrderByRelationAggregateInput
  }

  export type MemberWhereUniqueInput = {
    username?: string
  }

  export type MemberOrderByWithAggregationInput = {
    username?: SortOrder
    _count?: MemberCountOrderByAggregateInput
    _max?: MemberMaxOrderByAggregateInput
    _min?: MemberMinOrderByAggregateInput
  }

  export type MemberScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MemberScalarWhereWithAggregatesInput>
    OR?: Enumerable<MemberScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MemberScalarWhereWithAggregatesInput>
    username?: StringWithAggregatesFilter | string
  }

  export type RoleWhereInput = {
    AND?: Enumerable<RoleWhereInput>
    OR?: Enumerable<RoleWhereInput>
    NOT?: Enumerable<RoleWhereInput>
    member?: XOR<MemberRelationFilter, MemberWhereInput>
    username?: StringFilter | string
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
    shopId?: IntFilter | number
    job_type?: EnumJobTypeFilter | JobType
    permissions?: EnumPermissionsNullableListFilter
    shop_owners?: ShopOwnerListRelationFilter
    shop_managers?: ShopManagerListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    member?: MemberOrderByWithRelationInput
    username?: SortOrder
    shop?: ShopOrderByWithRelationInput
    shopId?: SortOrder
    job_type?: SortOrder
    permissions?: SortOrder
    shop_owners?: ShopOwnerOrderByRelationAggregateInput
    shop_managers?: ShopManagerOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = {
    username_shopId?: RoleUsernameShopIdCompoundUniqueInput
  }

  export type RoleOrderByWithAggregationInput = {
    username?: SortOrder
    shopId?: SortOrder
    job_type?: SortOrder
    permissions?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RoleScalarWhereWithAggregatesInput>
    OR?: Enumerable<RoleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RoleScalarWhereWithAggregatesInput>
    username?: StringWithAggregatesFilter | string
    shopId?: IntWithAggregatesFilter | number
    job_type?: EnumJobTypeWithAggregatesFilter | JobType
    permissions?: EnumPermissionsNullableListFilter
  }

  export type ProductWhereInput = {
    AND?: Enumerable<ProductWhereInput>
    OR?: Enumerable<ProductWhereInput>
    NOT?: Enumerable<ProductWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
    shopId?: IntFilter | number
    category?: EnumProductCategoryFilter | ProductCategory
    rate?: EnumProductRateFilter | ProductRate
    description?: StringNullableFilter | string | null
    products_in_shop?: ProductInShopListRelationFilter
    products_in_bag?: ProductInBagListRelationFilter
    offers?: OfferListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    shop?: ShopOrderByWithRelationInput
    shopId?: SortOrder
    category?: SortOrder
    rate?: SortOrder
    description?: SortOrder
    products_in_shop?: ProductInShopOrderByRelationAggregateInput
    products_in_bag?: ProductInBagOrderByRelationAggregateInput
    offers?: OfferOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = {
    id?: number
  }

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    shopId?: SortOrder
    category?: SortOrder
    rate?: SortOrder
    description?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    shopId?: IntWithAggregatesFilter | number
    category?: EnumProductCategoryWithAggregatesFilter | ProductCategory
    rate?: EnumProductRateWithAggregatesFilter | ProductRate
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type ShopWhereInput = {
    AND?: Enumerable<ShopWhereInput>
    OR?: Enumerable<ShopWhereInput>
    NOT?: Enumerable<ShopWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    status?: EnumShopStatusFilter | ShopStatus
    member?: XOR<MemberRelationFilter, MemberWhereInput>
    shop_founder?: StringFilter | string
    rate?: EnumShopRateFilter | ShopRate
    description?: StringNullableFilter | string | null
    role?: RoleListRelationFilter
    products?: ProductListRelationFilter
    products_in_shop?: ProductInShopListRelationFilter
    bags?: ShoppingBagListRelationFilter
    discounts?: DiscountListRelationFilter
    policies?: PolicyListRelationFilter
    offers?: OfferListRelationFilter
    appointments?: AppointmentListRelationFilter
  }

  export type ShopOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    member?: MemberOrderByWithRelationInput
    shop_founder?: SortOrder
    rate?: SortOrder
    description?: SortOrder
    role?: RoleOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    products_in_shop?: ProductInShopOrderByRelationAggregateInput
    bags?: ShoppingBagOrderByRelationAggregateInput
    discounts?: DiscountOrderByRelationAggregateInput
    policies?: PolicyOrderByRelationAggregateInput
    offers?: OfferOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
  }

  export type ShopWhereUniqueInput = {
    id?: number
  }

  export type ShopOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    shop_founder?: SortOrder
    rate?: SortOrder
    description?: SortOrder
    _count?: ShopCountOrderByAggregateInput
    _avg?: ShopAvgOrderByAggregateInput
    _max?: ShopMaxOrderByAggregateInput
    _min?: ShopMinOrderByAggregateInput
    _sum?: ShopSumOrderByAggregateInput
  }

  export type ShopScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ShopScalarWhereWithAggregatesInput>
    OR?: Enumerable<ShopScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ShopScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    status?: EnumShopStatusWithAggregatesFilter | ShopStatus
    shop_founder?: StringWithAggregatesFilter | string
    rate?: EnumShopRateWithAggregatesFilter | ShopRate
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type ShopOwnerWhereInput = {
    AND?: Enumerable<ShopOwnerWhereInput>
    OR?: Enumerable<ShopOwnerWhereInput>
    NOT?: Enumerable<ShopOwnerWhereInput>
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    username?: StringFilter | string
    shopId?: IntFilter | number
  }

  export type ShopOwnerOrderByWithRelationInput = {
    role?: RoleOrderByWithRelationInput
    username?: SortOrder
    shopId?: SortOrder
  }

  export type ShopOwnerWhereUniqueInput = {
    username_shopId?: ShopOwnerUsernameShopIdCompoundUniqueInput
  }

  export type ShopOwnerOrderByWithAggregationInput = {
    username?: SortOrder
    shopId?: SortOrder
    _count?: ShopOwnerCountOrderByAggregateInput
    _avg?: ShopOwnerAvgOrderByAggregateInput
    _max?: ShopOwnerMaxOrderByAggregateInput
    _min?: ShopOwnerMinOrderByAggregateInput
    _sum?: ShopOwnerSumOrderByAggregateInput
  }

  export type ShopOwnerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ShopOwnerScalarWhereWithAggregatesInput>
    OR?: Enumerable<ShopOwnerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ShopOwnerScalarWhereWithAggregatesInput>
    username?: StringWithAggregatesFilter | string
    shopId?: IntWithAggregatesFilter | number
  }

  export type ShopManagerWhereInput = {
    AND?: Enumerable<ShopManagerWhereInput>
    OR?: Enumerable<ShopManagerWhereInput>
    NOT?: Enumerable<ShopManagerWhereInput>
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    username?: StringFilter | string
    shopId?: IntFilter | number
  }

  export type ShopManagerOrderByWithRelationInput = {
    role?: RoleOrderByWithRelationInput
    username?: SortOrder
    shopId?: SortOrder
  }

  export type ShopManagerWhereUniqueInput = {
    username_shopId?: ShopManagerUsernameShopIdCompoundUniqueInput
  }

  export type ShopManagerOrderByWithAggregationInput = {
    username?: SortOrder
    shopId?: SortOrder
    _count?: ShopManagerCountOrderByAggregateInput
    _avg?: ShopManagerAvgOrderByAggregateInput
    _max?: ShopManagerMaxOrderByAggregateInput
    _min?: ShopManagerMinOrderByAggregateInput
    _sum?: ShopManagerSumOrderByAggregateInput
  }

  export type ShopManagerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ShopManagerScalarWhereWithAggregatesInput>
    OR?: Enumerable<ShopManagerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ShopManagerScalarWhereWithAggregatesInput>
    username?: StringWithAggregatesFilter | string
    shopId?: IntWithAggregatesFilter | number
  }

  export type ProductInShopWhereInput = {
    AND?: Enumerable<ProductInShopWhereInput>
    OR?: Enumerable<ProductInShopWhereInput>
    NOT?: Enumerable<ProductInShopWhereInput>
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
    shopId?: IntFilter | number
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    productId?: IntFilter | number
    product_quantity?: IntFilter | number
  }

  export type ProductInShopOrderByWithRelationInput = {
    shop?: ShopOrderByWithRelationInput
    shopId?: SortOrder
    product?: ProductOrderByWithRelationInput
    productId?: SortOrder
    product_quantity?: SortOrder
  }

  export type ProductInShopWhereUniqueInput = {
    shopId_productId?: ProductInShopShopIdProductIdCompoundUniqueInput
  }

  export type ProductInShopOrderByWithAggregationInput = {
    shopId?: SortOrder
    productId?: SortOrder
    product_quantity?: SortOrder
    _count?: ProductInShopCountOrderByAggregateInput
    _avg?: ProductInShopAvgOrderByAggregateInput
    _max?: ProductInShopMaxOrderByAggregateInput
    _min?: ProductInShopMinOrderByAggregateInput
    _sum?: ProductInShopSumOrderByAggregateInput
  }

  export type ProductInShopScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductInShopScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductInShopScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductInShopScalarWhereWithAggregatesInput>
    shopId?: IntWithAggregatesFilter | number
    productId?: IntWithAggregatesFilter | number
    product_quantity?: IntWithAggregatesFilter | number
  }

  export type ShoppingCartWhereInput = {
    AND?: Enumerable<ShoppingCartWhereInput>
    OR?: Enumerable<ShoppingCartWhereInput>
    NOT?: Enumerable<ShoppingCartWhereInput>
    member?: XOR<MemberRelationFilter, MemberWhereInput>
    username?: StringFilter | string
    bags?: ShoppingBagListRelationFilter
  }

  export type ShoppingCartOrderByWithRelationInput = {
    member?: MemberOrderByWithRelationInput
    username?: SortOrder
    bags?: ShoppingBagOrderByRelationAggregateInput
  }

  export type ShoppingCartWhereUniqueInput = {
    username?: string
  }

  export type ShoppingCartOrderByWithAggregationInput = {
    username?: SortOrder
    _count?: ShoppingCartCountOrderByAggregateInput
    _max?: ShoppingCartMaxOrderByAggregateInput
    _min?: ShoppingCartMinOrderByAggregateInput
  }

  export type ShoppingCartScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ShoppingCartScalarWhereWithAggregatesInput>
    OR?: Enumerable<ShoppingCartScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ShoppingCartScalarWhereWithAggregatesInput>
    username?: StringWithAggregatesFilter | string
  }

  export type ShoppingBagWhereInput = {
    AND?: Enumerable<ShoppingBagWhereInput>
    OR?: Enumerable<ShoppingBagWhereInput>
    NOT?: Enumerable<ShoppingBagWhereInput>
    shoppingCart?: XOR<ShoppingCartRelationFilter, ShoppingCartWhereInput>
    username?: StringFilter | string
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
    shopId?: IntFilter | number
    products_in_bag?: ProductInBagListRelationFilter
  }

  export type ShoppingBagOrderByWithRelationInput = {
    shoppingCart?: ShoppingCartOrderByWithRelationInput
    username?: SortOrder
    shop?: ShopOrderByWithRelationInput
    shopId?: SortOrder
    products_in_bag?: ProductInBagOrderByRelationAggregateInput
  }

  export type ShoppingBagWhereUniqueInput = {
    username_shopId?: ShoppingBagUsernameShopIdCompoundUniqueInput
  }

  export type ShoppingBagOrderByWithAggregationInput = {
    username?: SortOrder
    shopId?: SortOrder
    _count?: ShoppingBagCountOrderByAggregateInput
    _avg?: ShoppingBagAvgOrderByAggregateInput
    _max?: ShoppingBagMaxOrderByAggregateInput
    _min?: ShoppingBagMinOrderByAggregateInput
    _sum?: ShoppingBagSumOrderByAggregateInput
  }

  export type ShoppingBagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ShoppingBagScalarWhereWithAggregatesInput>
    OR?: Enumerable<ShoppingBagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ShoppingBagScalarWhereWithAggregatesInput>
    username?: StringWithAggregatesFilter | string
    shopId?: IntWithAggregatesFilter | number
  }

  export type ProductInBagWhereInput = {
    AND?: Enumerable<ProductInBagWhereInput>
    OR?: Enumerable<ProductInBagWhereInput>
    NOT?: Enumerable<ProductInBagWhereInput>
    shoppingBag?: XOR<ShoppingBagRelationFilter, ShoppingBagWhereInput>
    username?: StringFilter | string
    shopId?: IntFilter | number
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    productId?: IntFilter | number
    product_quantity?: IntFilter | number
  }

  export type ProductInBagOrderByWithRelationInput = {
    shoppingBag?: ShoppingBagOrderByWithRelationInput
    username?: SortOrder
    shopId?: SortOrder
    product?: ProductOrderByWithRelationInput
    productId?: SortOrder
    product_quantity?: SortOrder
  }

  export type ProductInBagWhereUniqueInput = {
    username_shopId_productId?: ProductInBagUsernameShopIdProductIdCompoundUniqueInput
  }

  export type ProductInBagOrderByWithAggregationInput = {
    username?: SortOrder
    shopId?: SortOrder
    productId?: SortOrder
    product_quantity?: SortOrder
    _count?: ProductInBagCountOrderByAggregateInput
    _avg?: ProductInBagAvgOrderByAggregateInput
    _max?: ProductInBagMaxOrderByAggregateInput
    _min?: ProductInBagMinOrderByAggregateInput
    _sum?: ProductInBagSumOrderByAggregateInput
  }

  export type ProductInBagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductInBagScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductInBagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductInBagScalarWhereWithAggregatesInput>
    username?: StringWithAggregatesFilter | string
    shopId?: IntWithAggregatesFilter | number
    productId?: IntWithAggregatesFilter | number
    product_quantity?: IntWithAggregatesFilter | number
  }

  export type MemberCredentialsWhereInput = {
    AND?: Enumerable<MemberCredentialsWhereInput>
    OR?: Enumerable<MemberCredentialsWhereInput>
    NOT?: Enumerable<MemberCredentialsWhereInput>
    member?: XOR<MemberRelationFilter, MemberWhereInput> | null
    username?: StringFilter | string
    password?: StringFilter | string
  }

  export type MemberCredentialsOrderByWithRelationInput = {
    member?: MemberOrderByWithRelationInput
    username?: SortOrder
    password?: SortOrder
  }

  export type MemberCredentialsWhereUniqueInput = {
    username?: string
  }

  export type MemberCredentialsOrderByWithAggregationInput = {
    username?: SortOrder
    password?: SortOrder
    _count?: MemberCredentialsCountOrderByAggregateInput
    _max?: MemberCredentialsMaxOrderByAggregateInput
    _min?: MemberCredentialsMinOrderByAggregateInput
  }

  export type MemberCredentialsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MemberCredentialsScalarWhereWithAggregatesInput>
    OR?: Enumerable<MemberCredentialsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MemberCredentialsScalarWhereWithAggregatesInput>
    username?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
  }

  export type MessageWhereInput = {
    AND?: Enumerable<MessageWhereInput>
    OR?: Enumerable<MessageWhereInput>
    NOT?: Enumerable<MessageWhereInput>
    id?: IntFilter | number
    timestamp?: IntFilter | number
    isRead?: BoolFilter | boolean
    messageType?: EnumMessageTypeFilter | MessageType
    recipients?: MessageRecipientsListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    isRead?: SortOrder
    messageType?: SortOrder
    recipients?: MessageRecipientsOrderByRelationAggregateInput
  }

  export type MessageWhereUniqueInput = {
    id?: number
  }

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    isRead?: SortOrder
    messageType?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _avg?: MessageAvgOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
    _sum?: MessageSumOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MessageScalarWhereWithAggregatesInput>
    OR?: Enumerable<MessageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MessageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    timestamp?: IntWithAggregatesFilter | number
    isRead?: BoolWithAggregatesFilter | boolean
    messageType?: EnumMessageTypeWithAggregatesFilter | MessageType
  }

  export type MessageRecipientsWhereInput = {
    AND?: Enumerable<MessageRecipientsWhereInput>
    OR?: Enumerable<MessageRecipientsWhereInput>
    NOT?: Enumerable<MessageRecipientsWhereInput>
    message?: XOR<MessageRelationFilter, MessageWhereInput>
    messageId?: IntFilter | number
    member?: XOR<MemberRelationFilter, MemberWhereInput>
    username?: StringFilter | string
  }

  export type MessageRecipientsOrderByWithRelationInput = {
    message?: MessageOrderByWithRelationInput
    messageId?: SortOrder
    member?: MemberOrderByWithRelationInput
    username?: SortOrder
  }

  export type MessageRecipientsWhereUniqueInput = {
    messageId_username?: MessageRecipientsMessageIdUsernameCompoundUniqueInput
  }

  export type MessageRecipientsOrderByWithAggregationInput = {
    messageId?: SortOrder
    username?: SortOrder
    _count?: MessageRecipientsCountOrderByAggregateInput
    _avg?: MessageRecipientsAvgOrderByAggregateInput
    _max?: MessageRecipientsMaxOrderByAggregateInput
    _min?: MessageRecipientsMinOrderByAggregateInput
    _sum?: MessageRecipientsSumOrderByAggregateInput
  }

  export type MessageRecipientsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MessageRecipientsScalarWhereWithAggregatesInput>
    OR?: Enumerable<MessageRecipientsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MessageRecipientsScalarWhereWithAggregatesInput>
    messageId?: IntWithAggregatesFilter | number
    username?: StringWithAggregatesFilter | string
  }

  export type DiscountWhereInput = {
    AND?: Enumerable<DiscountWhereInput>
    OR?: Enumerable<DiscountWhereInput>
    NOT?: Enumerable<DiscountWhereInput>
    id?: IntFilter | number
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
    shopId?: IntFilter | number
    kind?: EnumDiscountKindsFilter | DiscountKinds
    simpleDiscount?: XOR<SimpleDiscountRelationFilter, SimpleDiscountWhereInput> | null
    conditionalDiscount?: XOR<ConditionalDiscountRelationFilter, ConditionalDiscountWhereInput> | null
    discountContainer?: XOR<DiscountContainerRelationFilter, DiscountContainerWhereInput> | null
    discountInContainer?: XOR<DiscountInContainerRelationFilter, DiscountInContainerWhereInput> | null
  }

  export type DiscountOrderByWithRelationInput = {
    id?: SortOrder
    shop?: ShopOrderByWithRelationInput
    shopId?: SortOrder
    kind?: SortOrder
    simpleDiscount?: SimpleDiscountOrderByWithRelationInput
    conditionalDiscount?: ConditionalDiscountOrderByWithRelationInput
    discountContainer?: DiscountContainerOrderByWithRelationInput
    discountInContainer?: DiscountInContainerOrderByWithRelationInput
  }

  export type DiscountWhereUniqueInput = {
    id_shopId?: DiscountIdShopIdCompoundUniqueInput
  }

  export type DiscountOrderByWithAggregationInput = {
    id?: SortOrder
    shopId?: SortOrder
    kind?: SortOrder
    _count?: DiscountCountOrderByAggregateInput
    _avg?: DiscountAvgOrderByAggregateInput
    _max?: DiscountMaxOrderByAggregateInput
    _min?: DiscountMinOrderByAggregateInput
    _sum?: DiscountSumOrderByAggregateInput
  }

  export type DiscountScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DiscountScalarWhereWithAggregatesInput>
    OR?: Enumerable<DiscountScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DiscountScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    shopId?: IntWithAggregatesFilter | number
    kind?: EnumDiscountKindsWithAggregatesFilter | DiscountKinds
  }

  export type SimpleDiscountWhereInput = {
    AND?: Enumerable<SimpleDiscountWhereInput>
    OR?: Enumerable<SimpleDiscountWhereInput>
    NOT?: Enumerable<SimpleDiscountWhereInput>
    discount?: XOR<DiscountRelationFilter, DiscountWhereInput>
    id?: IntFilter | number
    shopId?: IntFilter | number
    discountType?: EnumDiscountTypeFilter | DiscountType
    discountPercent?: IntFilter | number
    description?: StringFilter | string
    productId?: IntNullableFilter | number | null
    category?: EnumProductCategoryNullableFilter | ProductCategory | null
    conditionalDiscount?: XOR<ConditionalDiscountRelationFilter, ConditionalDiscountWhereInput> | null
  }

  export type SimpleDiscountOrderByWithRelationInput = {
    discount?: DiscountOrderByWithRelationInput
    id?: SortOrder
    shopId?: SortOrder
    discountType?: SortOrder
    discountPercent?: SortOrder
    description?: SortOrder
    productId?: SortOrder
    category?: SortOrder
    conditionalDiscount?: ConditionalDiscountOrderByWithRelationInput
  }

  export type SimpleDiscountWhereUniqueInput = {
    id_shopId?: SimpleDiscountIdShopIdCompoundUniqueInput
  }

  export type SimpleDiscountOrderByWithAggregationInput = {
    id?: SortOrder
    shopId?: SortOrder
    discountType?: SortOrder
    discountPercent?: SortOrder
    description?: SortOrder
    productId?: SortOrder
    category?: SortOrder
    _count?: SimpleDiscountCountOrderByAggregateInput
    _avg?: SimpleDiscountAvgOrderByAggregateInput
    _max?: SimpleDiscountMaxOrderByAggregateInput
    _min?: SimpleDiscountMinOrderByAggregateInput
    _sum?: SimpleDiscountSumOrderByAggregateInput
  }

  export type SimpleDiscountScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SimpleDiscountScalarWhereWithAggregatesInput>
    OR?: Enumerable<SimpleDiscountScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SimpleDiscountScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    shopId?: IntWithAggregatesFilter | number
    discountType?: EnumDiscountTypeWithAggregatesFilter | DiscountType
    discountPercent?: IntWithAggregatesFilter | number
    description?: StringWithAggregatesFilter | string
    productId?: IntNullableWithAggregatesFilter | number | null
    category?: EnumProductCategoryNullableWithAggregatesFilter | ProductCategory | null
  }

  export type ConditionalDiscountWhereInput = {
    AND?: Enumerable<ConditionalDiscountWhereInput>
    OR?: Enumerable<ConditionalDiscountWhereInput>
    NOT?: Enumerable<ConditionalDiscountWhereInput>
    discount?: XOR<DiscountRelationFilter, DiscountWhereInput>
    id?: IntFilter | number
    shopId?: IntFilter | number
    simpleDiscount?: XOR<SimpleDiscountRelationFilter, SimpleDiscountWhereInput>
    simpleId?: IntFilter | number
    simpleShopId?: IntFilter | number
    discountPredicate?: XOR<DiscountPredicateRelationFilter, DiscountPredicateWhereInput> | null
  }

  export type ConditionalDiscountOrderByWithRelationInput = {
    discount?: DiscountOrderByWithRelationInput
    id?: SortOrder
    shopId?: SortOrder
    simpleDiscount?: SimpleDiscountOrderByWithRelationInput
    simpleId?: SortOrder
    simpleShopId?: SortOrder
    discountPredicate?: DiscountPredicateOrderByWithRelationInput
  }

  export type ConditionalDiscountWhereUniqueInput = {
    simpleId_simpleShopId?: ConditionalDiscountSimpleIdSimpleShopIdCompoundUniqueInput
    id_shopId?: ConditionalDiscountIdShopIdCompoundUniqueInput
  }

  export type ConditionalDiscountOrderByWithAggregationInput = {
    id?: SortOrder
    shopId?: SortOrder
    simpleId?: SortOrder
    simpleShopId?: SortOrder
    _count?: ConditionalDiscountCountOrderByAggregateInput
    _avg?: ConditionalDiscountAvgOrderByAggregateInput
    _max?: ConditionalDiscountMaxOrderByAggregateInput
    _min?: ConditionalDiscountMinOrderByAggregateInput
    _sum?: ConditionalDiscountSumOrderByAggregateInput
  }

  export type ConditionalDiscountScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ConditionalDiscountScalarWhereWithAggregatesInput>
    OR?: Enumerable<ConditionalDiscountScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ConditionalDiscountScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    shopId?: IntWithAggregatesFilter | number
    simpleId?: IntWithAggregatesFilter | number
    simpleShopId?: IntWithAggregatesFilter | number
  }

  export type DiscountPredicateWhereInput = {
    AND?: Enumerable<DiscountPredicateWhereInput>
    OR?: Enumerable<DiscountPredicateWhereInput>
    NOT?: Enumerable<DiscountPredicateWhereInput>
    discount?: XOR<ConditionalDiscountRelationFilter, ConditionalDiscountWhereInput>
    discountId?: IntFilter | number
    shopId?: IntFilter | number
    discountType?: EnumDiscountTypeFilter | DiscountType
    relation?: EnumRelationTypeFilter | RelationType
    value?: IntFilter | number
    description?: StringFilter | string
    productId?: IntNullableFilter | number | null
    category?: EnumProductCategoryNullableFilter | ProductCategory | null
  }

  export type DiscountPredicateOrderByWithRelationInput = {
    discount?: ConditionalDiscountOrderByWithRelationInput
    discountId?: SortOrder
    shopId?: SortOrder
    discountType?: SortOrder
    relation?: SortOrder
    value?: SortOrder
    description?: SortOrder
    productId?: SortOrder
    category?: SortOrder
  }

  export type DiscountPredicateWhereUniqueInput = {
    discountId_shopId?: DiscountPredicateDiscountIdShopIdCompoundUniqueInput
  }

  export type DiscountPredicateOrderByWithAggregationInput = {
    discountId?: SortOrder
    shopId?: SortOrder
    discountType?: SortOrder
    relation?: SortOrder
    value?: SortOrder
    description?: SortOrder
    productId?: SortOrder
    category?: SortOrder
    _count?: DiscountPredicateCountOrderByAggregateInput
    _avg?: DiscountPredicateAvgOrderByAggregateInput
    _max?: DiscountPredicateMaxOrderByAggregateInput
    _min?: DiscountPredicateMinOrderByAggregateInput
    _sum?: DiscountPredicateSumOrderByAggregateInput
  }

  export type DiscountPredicateScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DiscountPredicateScalarWhereWithAggregatesInput>
    OR?: Enumerable<DiscountPredicateScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DiscountPredicateScalarWhereWithAggregatesInput>
    discountId?: IntWithAggregatesFilter | number
    shopId?: IntWithAggregatesFilter | number
    discountType?: EnumDiscountTypeWithAggregatesFilter | DiscountType
    relation?: EnumRelationTypeWithAggregatesFilter | RelationType
    value?: IntWithAggregatesFilter | number
    description?: StringWithAggregatesFilter | string
    productId?: IntNullableWithAggregatesFilter | number | null
    category?: EnumProductCategoryNullableWithAggregatesFilter | ProductCategory | null
  }

  export type DiscountContainerWhereInput = {
    AND?: Enumerable<DiscountContainerWhereInput>
    OR?: Enumerable<DiscountContainerWhereInput>
    NOT?: Enumerable<DiscountContainerWhereInput>
    discount?: XOR<DiscountRelationFilter, DiscountWhereInput>
    id?: IntFilter | number
    shopId?: IntFilter | number
    description?: StringFilter | string
    type?: EnumDiscountRelationFilter | DiscountRelation
    discounts?: DiscountInContainerListRelationFilter
  }

  export type DiscountContainerOrderByWithRelationInput = {
    discount?: DiscountOrderByWithRelationInput
    id?: SortOrder
    shopId?: SortOrder
    description?: SortOrder
    type?: SortOrder
    discounts?: DiscountInContainerOrderByRelationAggregateInput
  }

  export type DiscountContainerWhereUniqueInput = {
    id_shopId?: DiscountContainerIdShopIdCompoundUniqueInput
  }

  export type DiscountContainerOrderByWithAggregationInput = {
    id?: SortOrder
    shopId?: SortOrder
    description?: SortOrder
    type?: SortOrder
    _count?: DiscountContainerCountOrderByAggregateInput
    _avg?: DiscountContainerAvgOrderByAggregateInput
    _max?: DiscountContainerMaxOrderByAggregateInput
    _min?: DiscountContainerMinOrderByAggregateInput
    _sum?: DiscountContainerSumOrderByAggregateInput
  }

  export type DiscountContainerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DiscountContainerScalarWhereWithAggregatesInput>
    OR?: Enumerable<DiscountContainerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DiscountContainerScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    shopId?: IntWithAggregatesFilter | number
    description?: StringWithAggregatesFilter | string
    type?: EnumDiscountRelationWithAggregatesFilter | DiscountRelation
  }

  export type DiscountInContainerWhereInput = {
    AND?: Enumerable<DiscountInContainerWhereInput>
    OR?: Enumerable<DiscountInContainerWhereInput>
    NOT?: Enumerable<DiscountInContainerWhereInput>
    discount?: XOR<DiscountRelationFilter, DiscountWhereInput>
    containedDiscount?: IntFilter | number
    shopId?: IntFilter | number
    discountContainer?: XOR<DiscountContainerRelationFilter, DiscountContainerWhereInput>
    containingDiscount?: IntFilter | number
  }

  export type DiscountInContainerOrderByWithRelationInput = {
    discount?: DiscountOrderByWithRelationInput
    containedDiscount?: SortOrder
    shopId?: SortOrder
    discountContainer?: DiscountContainerOrderByWithRelationInput
    containingDiscount?: SortOrder
  }

  export type DiscountInContainerWhereUniqueInput = {
    containedDiscount_shopId?: DiscountInContainerContainedDiscountShopIdCompoundUniqueInput
    containedDiscount_containingDiscount_shopId?: DiscountInContainerContainedDiscountContainingDiscountShopIdCompoundUniqueInput
  }

  export type DiscountInContainerOrderByWithAggregationInput = {
    containedDiscount?: SortOrder
    shopId?: SortOrder
    containingDiscount?: SortOrder
    _count?: DiscountInContainerCountOrderByAggregateInput
    _avg?: DiscountInContainerAvgOrderByAggregateInput
    _max?: DiscountInContainerMaxOrderByAggregateInput
    _min?: DiscountInContainerMinOrderByAggregateInput
    _sum?: DiscountInContainerSumOrderByAggregateInput
  }

  export type DiscountInContainerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DiscountInContainerScalarWhereWithAggregatesInput>
    OR?: Enumerable<DiscountInContainerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DiscountInContainerScalarWhereWithAggregatesInput>
    containedDiscount?: IntWithAggregatesFilter | number
    shopId?: IntWithAggregatesFilter | number
    containingDiscount?: IntWithAggregatesFilter | number
  }

  export type PolicyWhereInput = {
    AND?: Enumerable<PolicyWhereInput>
    OR?: Enumerable<PolicyWhereInput>
    NOT?: Enumerable<PolicyWhereInput>
    id?: IntFilter | number
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
    shopId?: IntFilter | number
    simplePolicy?: XOR<SimplePolicyRelationFilter, SimplePolicyWhereInput> | null
    conditionalPolicy?: XOR<ConditionalPolicyRelationFilter, ConditionalPolicyWhereInput> | null
    logicalPolicy?: XOR<LogicalPolicyRelationFilter, LogicalPolicyWhereInput> | null
    policyInContainer?: XOR<PolicyInContainerRelationFilter, PolicyInContainerWhereInput> | null
  }

  export type PolicyOrderByWithRelationInput = {
    id?: SortOrder
    shop?: ShopOrderByWithRelationInput
    shopId?: SortOrder
    simplePolicy?: SimplePolicyOrderByWithRelationInput
    conditionalPolicy?: ConditionalPolicyOrderByWithRelationInput
    logicalPolicy?: LogicalPolicyOrderByWithRelationInput
    policyInContainer?: PolicyInContainerOrderByWithRelationInput
  }

  export type PolicyWhereUniqueInput = {
    id_shopId?: PolicyIdShopIdCompoundUniqueInput
  }

  export type PolicyOrderByWithAggregationInput = {
    id?: SortOrder
    shopId?: SortOrder
    _count?: PolicyCountOrderByAggregateInput
    _avg?: PolicyAvgOrderByAggregateInput
    _max?: PolicyMaxOrderByAggregateInput
    _min?: PolicyMinOrderByAggregateInput
    _sum?: PolicySumOrderByAggregateInput
  }

  export type PolicyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PolicyScalarWhereWithAggregatesInput>
    OR?: Enumerable<PolicyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PolicyScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    shopId?: IntWithAggregatesFilter | number
  }

  export type SimplePolicyWhereInput = {
    AND?: Enumerable<SimplePolicyWhereInput>
    OR?: Enumerable<SimplePolicyWhereInput>
    NOT?: Enumerable<SimplePolicyWhereInput>
    policy?: XOR<PolicyRelationFilter, PolicyWhereInput>
    id?: IntFilter | number
    shopId?: IntFilter | number
    okay?: BoolFilter | boolean
    message?: StringFilter | string
  }

  export type SimplePolicyOrderByWithRelationInput = {
    policy?: PolicyOrderByWithRelationInput
    id?: SortOrder
    shopId?: SortOrder
    okay?: SortOrder
    message?: SortOrder
  }

  export type SimplePolicyWhereUniqueInput = {
    id_shopId?: SimplePolicyIdShopIdCompoundUniqueInput
  }

  export type SimplePolicyOrderByWithAggregationInput = {
    id?: SortOrder
    shopId?: SortOrder
    okay?: SortOrder
    message?: SortOrder
    _count?: SimplePolicyCountOrderByAggregateInput
    _avg?: SimplePolicyAvgOrderByAggregateInput
    _max?: SimplePolicyMaxOrderByAggregateInput
    _min?: SimplePolicyMinOrderByAggregateInput
    _sum?: SimplePolicySumOrderByAggregateInput
  }

  export type SimplePolicyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SimplePolicyScalarWhereWithAggregatesInput>
    OR?: Enumerable<SimplePolicyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SimplePolicyScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    shopId?: IntWithAggregatesFilter | number
    okay?: BoolWithAggregatesFilter | boolean
    message?: StringWithAggregatesFilter | string
  }

  export type ConditionalPolicyWhereInput = {
    AND?: Enumerable<ConditionalPolicyWhereInput>
    OR?: Enumerable<ConditionalPolicyWhereInput>
    NOT?: Enumerable<ConditionalPolicyWhereInput>
    policy?: XOR<PolicyRelationFilter, PolicyWhereInput>
    id?: IntFilter | number
    shopId?: IntFilter | number
    dependent?: IntFilter | number
    dependentShopId?: IntFilter | number
    dependentOn?: IntFilter | number
    dependentOnShopId?: IntFilter | number
    description?: StringFilter | string
    policyPredicate?: XOR<PolicyPredicateRelationFilter, PolicyPredicateWhereInput> | null
  }

  export type ConditionalPolicyOrderByWithRelationInput = {
    policy?: PolicyOrderByWithRelationInput
    id?: SortOrder
    shopId?: SortOrder
    dependent?: SortOrder
    dependentShopId?: SortOrder
    dependentOn?: SortOrder
    dependentOnShopId?: SortOrder
    description?: SortOrder
    policyPredicate?: PolicyPredicateOrderByWithRelationInput
  }

  export type ConditionalPolicyWhereUniqueInput = {
    id_shopId?: ConditionalPolicyIdShopIdCompoundUniqueInput
  }

  export type ConditionalPolicyOrderByWithAggregationInput = {
    id?: SortOrder
    shopId?: SortOrder
    dependent?: SortOrder
    dependentShopId?: SortOrder
    dependentOn?: SortOrder
    dependentOnShopId?: SortOrder
    description?: SortOrder
    _count?: ConditionalPolicyCountOrderByAggregateInput
    _avg?: ConditionalPolicyAvgOrderByAggregateInput
    _max?: ConditionalPolicyMaxOrderByAggregateInput
    _min?: ConditionalPolicyMinOrderByAggregateInput
    _sum?: ConditionalPolicySumOrderByAggregateInput
  }

  export type ConditionalPolicyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ConditionalPolicyScalarWhereWithAggregatesInput>
    OR?: Enumerable<ConditionalPolicyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ConditionalPolicyScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    shopId?: IntWithAggregatesFilter | number
    dependent?: IntWithAggregatesFilter | number
    dependentShopId?: IntWithAggregatesFilter | number
    dependentOn?: IntWithAggregatesFilter | number
    dependentOnShopId?: IntWithAggregatesFilter | number
    description?: StringWithAggregatesFilter | string
  }

  export type PolicyPredicateWhereInput = {
    AND?: Enumerable<PolicyPredicateWhereInput>
    OR?: Enumerable<PolicyPredicateWhereInput>
    NOT?: Enumerable<PolicyPredicateWhereInput>
    policy?: XOR<ConditionalPolicyRelationFilter, ConditionalPolicyWhereInput>
    policyId?: IntFilter | number
    shopId?: IntFilter | number
    policyType?: EnumSimplePolicyTypeFilter | SimplePolicyType
    relation?: EnumRelationTypeFilter | RelationType
    value?: IntFilter | number
    description?: StringFilter | string
    productId?: IntNullableFilter | number | null
    productCategory?: EnumProductCategoryNullableFilter | ProductCategory | null
    guest?: StringNullableFilter | string | null
  }

  export type PolicyPredicateOrderByWithRelationInput = {
    policy?: ConditionalPolicyOrderByWithRelationInput
    policyId?: SortOrder
    shopId?: SortOrder
    policyType?: SortOrder
    relation?: SortOrder
    value?: SortOrder
    description?: SortOrder
    productId?: SortOrder
    productCategory?: SortOrder
    guest?: SortOrder
  }

  export type PolicyPredicateWhereUniqueInput = {
    policyId_shopId?: PolicyPredicatePolicyIdShopIdCompoundUniqueInput
  }

  export type PolicyPredicateOrderByWithAggregationInput = {
    policyId?: SortOrder
    shopId?: SortOrder
    policyType?: SortOrder
    relation?: SortOrder
    value?: SortOrder
    description?: SortOrder
    productId?: SortOrder
    productCategory?: SortOrder
    guest?: SortOrder
    _count?: PolicyPredicateCountOrderByAggregateInput
    _avg?: PolicyPredicateAvgOrderByAggregateInput
    _max?: PolicyPredicateMaxOrderByAggregateInput
    _min?: PolicyPredicateMinOrderByAggregateInput
    _sum?: PolicyPredicateSumOrderByAggregateInput
  }

  export type PolicyPredicateScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PolicyPredicateScalarWhereWithAggregatesInput>
    OR?: Enumerable<PolicyPredicateScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PolicyPredicateScalarWhereWithAggregatesInput>
    policyId?: IntWithAggregatesFilter | number
    shopId?: IntWithAggregatesFilter | number
    policyType?: EnumSimplePolicyTypeWithAggregatesFilter | SimplePolicyType
    relation?: EnumRelationTypeWithAggregatesFilter | RelationType
    value?: IntWithAggregatesFilter | number
    description?: StringWithAggregatesFilter | string
    productId?: IntNullableWithAggregatesFilter | number | null
    productCategory?: EnumProductCategoryNullableWithAggregatesFilter | ProductCategory | null
    guest?: StringNullableWithAggregatesFilter | string | null
  }

  export type LogicalPolicyWhereInput = {
    AND?: Enumerable<LogicalPolicyWhereInput>
    OR?: Enumerable<LogicalPolicyWhereInput>
    NOT?: Enumerable<LogicalPolicyWhereInput>
    policy?: XOR<PolicyRelationFilter, PolicyWhereInput>
    id?: IntFilter | number
    shopId?: IntFilter | number
    description?: StringFilter | string
    purchasePoliciesRelation?: EnumPurchasePoliciesRelationFilter | PurchasePoliciesRelation
    policies?: PolicyInContainerListRelationFilter
  }

  export type LogicalPolicyOrderByWithRelationInput = {
    policy?: PolicyOrderByWithRelationInput
    id?: SortOrder
    shopId?: SortOrder
    description?: SortOrder
    purchasePoliciesRelation?: SortOrder
    policies?: PolicyInContainerOrderByRelationAggregateInput
  }

  export type LogicalPolicyWhereUniqueInput = {
    id_shopId?: LogicalPolicyIdShopIdCompoundUniqueInput
  }

  export type LogicalPolicyOrderByWithAggregationInput = {
    id?: SortOrder
    shopId?: SortOrder
    description?: SortOrder
    purchasePoliciesRelation?: SortOrder
    _count?: LogicalPolicyCountOrderByAggregateInput
    _avg?: LogicalPolicyAvgOrderByAggregateInput
    _max?: LogicalPolicyMaxOrderByAggregateInput
    _min?: LogicalPolicyMinOrderByAggregateInput
    _sum?: LogicalPolicySumOrderByAggregateInput
  }

  export type LogicalPolicyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LogicalPolicyScalarWhereWithAggregatesInput>
    OR?: Enumerable<LogicalPolicyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LogicalPolicyScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    shopId?: IntWithAggregatesFilter | number
    description?: StringWithAggregatesFilter | string
    purchasePoliciesRelation?: EnumPurchasePoliciesRelationWithAggregatesFilter | PurchasePoliciesRelation
  }

  export type PolicyInContainerWhereInput = {
    AND?: Enumerable<PolicyInContainerWhereInput>
    OR?: Enumerable<PolicyInContainerWhereInput>
    NOT?: Enumerable<PolicyInContainerWhereInput>
    policy?: XOR<PolicyRelationFilter, PolicyWhereInput>
    containedPolicy?: IntFilter | number
    shopId?: IntFilter | number
    policyContainer?: XOR<LogicalPolicyRelationFilter, LogicalPolicyWhereInput>
    containingPolicy?: IntFilter | number
  }

  export type PolicyInContainerOrderByWithRelationInput = {
    policy?: PolicyOrderByWithRelationInput
    containedPolicy?: SortOrder
    shopId?: SortOrder
    policyContainer?: LogicalPolicyOrderByWithRelationInput
    containingPolicy?: SortOrder
  }

  export type PolicyInContainerWhereUniqueInput = {
    containedPolicy_shopId?: PolicyInContainerContainedPolicyShopIdCompoundUniqueInput
    containedPolicy_containingPolicy_shopId?: PolicyInContainerContainedPolicyContainingPolicyShopIdCompoundUniqueInput
  }

  export type PolicyInContainerOrderByWithAggregationInput = {
    containedPolicy?: SortOrder
    shopId?: SortOrder
    containingPolicy?: SortOrder
    _count?: PolicyInContainerCountOrderByAggregateInput
    _avg?: PolicyInContainerAvgOrderByAggregateInput
    _max?: PolicyInContainerMaxOrderByAggregateInput
    _min?: PolicyInContainerMinOrderByAggregateInput
    _sum?: PolicyInContainerSumOrderByAggregateInput
  }

  export type PolicyInContainerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PolicyInContainerScalarWhereWithAggregatesInput>
    OR?: Enumerable<PolicyInContainerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PolicyInContainerScalarWhereWithAggregatesInput>
    containedPolicy?: IntWithAggregatesFilter | number
    shopId?: IntWithAggregatesFilter | number
    containingPolicy?: IntWithAggregatesFilter | number
  }

  export type OfferWhereInput = {
    AND?: Enumerable<OfferWhereInput>
    OR?: Enumerable<OfferWhereInput>
    NOT?: Enumerable<OfferWhereInput>
    id?: IntFilter | number
    member?: XOR<MemberRelationFilter, MemberWhereInput>
    username?: StringFilter | string
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
    shopId?: IntFilter | number
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    productId?: IntFilter | number
    price?: FloatFilter | number
    offerApprover?: OfferApproverListRelationFilter
  }

  export type OfferOrderByWithRelationInput = {
    id?: SortOrder
    member?: MemberOrderByWithRelationInput
    username?: SortOrder
    shop?: ShopOrderByWithRelationInput
    shopId?: SortOrder
    product?: ProductOrderByWithRelationInput
    productId?: SortOrder
    price?: SortOrder
    offerApprover?: OfferApproverOrderByRelationAggregateInput
  }

  export type OfferWhereUniqueInput = {
    id?: number
  }

  export type OfferOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    shopId?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    _count?: OfferCountOrderByAggregateInput
    _avg?: OfferAvgOrderByAggregateInput
    _max?: OfferMaxOrderByAggregateInput
    _min?: OfferMinOrderByAggregateInput
    _sum?: OfferSumOrderByAggregateInput
  }

  export type OfferScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OfferScalarWhereWithAggregatesInput>
    OR?: Enumerable<OfferScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OfferScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    username?: StringWithAggregatesFilter | string
    shopId?: IntWithAggregatesFilter | number
    productId?: IntWithAggregatesFilter | number
    price?: FloatWithAggregatesFilter | number
  }

  export type OfferApproverWhereInput = {
    AND?: Enumerable<OfferApproverWhereInput>
    OR?: Enumerable<OfferApproverWhereInput>
    NOT?: Enumerable<OfferApproverWhereInput>
    member?: XOR<MemberRelationFilter, MemberWhereInput>
    username?: StringFilter | string
    offer?: XOR<OfferRelationFilter, OfferWhereInput>
    offerId?: IntFilter | number
    answered?: BoolFilter | boolean
    approved?: BoolFilter | boolean
  }

  export type OfferApproverOrderByWithRelationInput = {
    member?: MemberOrderByWithRelationInput
    username?: SortOrder
    offer?: OfferOrderByWithRelationInput
    offerId?: SortOrder
    answered?: SortOrder
    approved?: SortOrder
  }

  export type OfferApproverWhereUniqueInput = {
    offerId?: number
  }

  export type OfferApproverOrderByWithAggregationInput = {
    username?: SortOrder
    offerId?: SortOrder
    answered?: SortOrder
    approved?: SortOrder
    _count?: OfferApproverCountOrderByAggregateInput
    _avg?: OfferApproverAvgOrderByAggregateInput
    _max?: OfferApproverMaxOrderByAggregateInput
    _min?: OfferApproverMinOrderByAggregateInput
    _sum?: OfferApproverSumOrderByAggregateInput
  }

  export type OfferApproverScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OfferApproverScalarWhereWithAggregatesInput>
    OR?: Enumerable<OfferApproverScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OfferApproverScalarWhereWithAggregatesInput>
    username?: StringWithAggregatesFilter | string
    offerId?: IntWithAggregatesFilter | number
    answered?: BoolWithAggregatesFilter | boolean
    approved?: BoolWithAggregatesFilter | boolean
  }

  export type AppointmentWhereInput = {
    AND?: Enumerable<AppointmentWhereInput>
    OR?: Enumerable<AppointmentWhereInput>
    NOT?: Enumerable<AppointmentWhereInput>
    member?: XOR<MemberRelationFilter, MemberWhereInput>
    username?: StringFilter | string
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
    shopId?: IntFilter | number
    assigner?: StringFilter | string
    appointmentAgreements?: AppointmentAgreementListRelationFilter
  }

  export type AppointmentOrderByWithRelationInput = {
    member?: MemberOrderByWithRelationInput
    username?: SortOrder
    shop?: ShopOrderByWithRelationInput
    shopId?: SortOrder
    assigner?: SortOrder
    appointmentAgreements?: AppointmentAgreementOrderByRelationAggregateInput
  }

  export type AppointmentWhereUniqueInput = {
    username_shopId?: AppointmentUsernameShopIdCompoundUniqueInput
  }

  export type AppointmentOrderByWithAggregationInput = {
    username?: SortOrder
    shopId?: SortOrder
    assigner?: SortOrder
    _count?: AppointmentCountOrderByAggregateInput
    _avg?: AppointmentAvgOrderByAggregateInput
    _max?: AppointmentMaxOrderByAggregateInput
    _min?: AppointmentMinOrderByAggregateInput
    _sum?: AppointmentSumOrderByAggregateInput
  }

  export type AppointmentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AppointmentScalarWhereWithAggregatesInput>
    OR?: Enumerable<AppointmentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AppointmentScalarWhereWithAggregatesInput>
    username?: StringWithAggregatesFilter | string
    shopId?: IntWithAggregatesFilter | number
    assigner?: StringWithAggregatesFilter | string
  }

  export type AppointmentAgreementWhereInput = {
    AND?: Enumerable<AppointmentAgreementWhereInput>
    OR?: Enumerable<AppointmentAgreementWhereInput>
    NOT?: Enumerable<AppointmentAgreementWhereInput>
    appointment?: XOR<AppointmentRelationFilter, AppointmentWhereInput>
    username?: StringFilter | string
    shopId?: IntFilter | number
    approver?: StringFilter | string
    answered?: BoolFilter | boolean
    approved?: BoolFilter | boolean
  }

  export type AppointmentAgreementOrderByWithRelationInput = {
    appointment?: AppointmentOrderByWithRelationInput
    username?: SortOrder
    shopId?: SortOrder
    approver?: SortOrder
    answered?: SortOrder
    approved?: SortOrder
  }

  export type AppointmentAgreementWhereUniqueInput = {
    username_shopId?: AppointmentAgreementUsernameShopIdCompoundUniqueInput
  }

  export type AppointmentAgreementOrderByWithAggregationInput = {
    username?: SortOrder
    shopId?: SortOrder
    approver?: SortOrder
    answered?: SortOrder
    approved?: SortOrder
    _count?: AppointmentAgreementCountOrderByAggregateInput
    _avg?: AppointmentAgreementAvgOrderByAggregateInput
    _max?: AppointmentAgreementMaxOrderByAggregateInput
    _min?: AppointmentAgreementMinOrderByAggregateInput
    _sum?: AppointmentAgreementSumOrderByAggregateInput
  }

  export type AppointmentAgreementScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AppointmentAgreementScalarWhereWithAggregatesInput>
    OR?: Enumerable<AppointmentAgreementScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AppointmentAgreementScalarWhereWithAggregatesInput>
    username?: StringWithAggregatesFilter | string
    shopId?: IntWithAggregatesFilter | number
    approver?: StringWithAggregatesFilter | string
    answered?: BoolWithAggregatesFilter | boolean
    approved?: BoolWithAggregatesFilter | boolean
  }

  export type MemberCreateInput = {
    username: string
    roles?: RoleCreateNestedManyWithoutMemberInput
    shops?: ShopCreateNestedManyWithoutMemberInput
    ShoppingCart?: ShoppingCartCreateNestedOneWithoutMemberInput
    MemberCredentials?: MemberCredentialsCreateNestedOneWithoutMemberInput
    offers?: OfferCreateNestedManyWithoutMemberInput
    offerApprovers?: OfferApproverCreateNestedManyWithoutMemberInput
    appointments?: AppointmentCreateNestedManyWithoutMemberInput
    messageRecipients?: MessageRecipientsCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateInput = {
    username: string
    roles?: RoleUncheckedCreateNestedManyWithoutMemberInput
    shops?: ShopUncheckedCreateNestedManyWithoutMemberInput
    ShoppingCart?: ShoppingCartUncheckedCreateNestedOneWithoutMemberInput
    MemberCredentials?: MemberCredentialsUncheckedCreateNestedOneWithoutMemberInput
    offers?: OfferUncheckedCreateNestedManyWithoutMemberInput
    offerApprovers?: OfferApproverUncheckedCreateNestedManyWithoutMemberInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutMemberInput
    messageRecipients?: MessageRecipientsUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    roles?: RoleUpdateManyWithoutMemberInput
    shops?: ShopUpdateManyWithoutMemberInput
    ShoppingCart?: ShoppingCartUpdateOneWithoutMemberInput
    MemberCredentials?: MemberCredentialsUpdateOneWithoutMemberInput
    offers?: OfferUpdateManyWithoutMemberInput
    offerApprovers?: OfferApproverUpdateManyWithoutMemberInput
    appointments?: AppointmentUpdateManyWithoutMemberInput
    messageRecipients?: MessageRecipientsUpdateManyWithoutMemberInput
  }

  export type MemberUncheckedUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    roles?: RoleUncheckedUpdateManyWithoutMemberInput
    shops?: ShopUncheckedUpdateManyWithoutMemberInput
    ShoppingCart?: ShoppingCartUncheckedUpdateOneWithoutMemberInput
    MemberCredentials?: MemberCredentialsUncheckedUpdateOneWithoutMemberInput
    offers?: OfferUncheckedUpdateManyWithoutMemberInput
    offerApprovers?: OfferApproverUncheckedUpdateManyWithoutMemberInput
    appointments?: AppointmentUncheckedUpdateManyWithoutMemberInput
    messageRecipients?: MessageRecipientsUncheckedUpdateManyWithoutMemberInput
  }

  export type MemberCreateManyInput = {
    username: string
  }

  export type MemberUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
  }

  export type MemberUncheckedUpdateManyInput = {
    username?: StringFieldUpdateOperationsInput | string
  }

  export type RoleCreateInput = {
    member: MemberCreateNestedOneWithoutRolesInput
    shop: ShopCreateNestedOneWithoutRoleInput
    job_type: JobType
    permissions?: RoleCreatepermissionsInput | Enumerable<Permissions>
    shop_owners?: ShopOwnerCreateNestedManyWithoutRoleInput
    shop_managers?: ShopManagerCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    username: string
    shopId: number
    job_type: JobType
    permissions?: RoleCreatepermissionsInput | Enumerable<Permissions>
    shop_owners?: ShopOwnerUncheckedCreateNestedManyWithoutRoleInput
    shop_managers?: ShopManagerUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    member?: MemberUpdateOneRequiredWithoutRolesInput
    shop?: ShopUpdateOneRequiredWithoutRoleInput
    job_type?: EnumJobTypeFieldUpdateOperationsInput | JobType
    permissions?: RoleUpdatepermissionsInput | Enumerable<Permissions>
    shop_owners?: ShopOwnerUpdateManyWithoutRoleInput
    shop_managers?: ShopManagerUpdateManyWithoutRoleInput
  }

  export type RoleUncheckedUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    shopId?: IntFieldUpdateOperationsInput | number
    job_type?: EnumJobTypeFieldUpdateOperationsInput | JobType
    permissions?: RoleUpdatepermissionsInput | Enumerable<Permissions>
    shop_owners?: ShopOwnerUncheckedUpdateManyWithoutRoleInput
    shop_managers?: ShopManagerUncheckedUpdateManyWithoutRoleInput
  }

  export type RoleCreateManyInput = {
    username: string
    shopId: number
    job_type: JobType
    permissions?: RoleCreatepermissionsInput | Enumerable<Permissions>
  }

  export type RoleUpdateManyMutationInput = {
    job_type?: EnumJobTypeFieldUpdateOperationsInput | JobType
    permissions?: RoleUpdatepermissionsInput | Enumerable<Permissions>
  }

  export type RoleUncheckedUpdateManyInput = {
    username?: StringFieldUpdateOperationsInput | string
    shopId?: IntFieldUpdateOperationsInput | number
    job_type?: EnumJobTypeFieldUpdateOperationsInput | JobType
    permissions?: RoleUpdatepermissionsInput | Enumerable<Permissions>
  }

  export type ProductCreateInput = {
    id: number
    name: string
    shop: ShopCreateNestedOneWithoutProductsInput
    category?: ProductCategory
    rate?: ProductRate
    description?: string | null
    products_in_shop?: ProductInShopCreateNestedManyWithoutProductInput
    products_in_bag?: ProductInBagCreateNestedManyWithoutProductInput
    offers?: OfferCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id: number
    name: string
    shopId: number
    category?: ProductCategory
    rate?: ProductRate
    description?: string | null
    products_in_shop?: ProductInShopUncheckedCreateNestedManyWithoutProductInput
    products_in_bag?: ProductInBagUncheckedCreateNestedManyWithoutProductInput
    offers?: OfferUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shop?: ShopUpdateOneRequiredWithoutProductsInput
    category?: EnumProductCategoryFieldUpdateOperationsInput | ProductCategory
    rate?: EnumProductRateFieldUpdateOperationsInput | ProductRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
    products_in_shop?: ProductInShopUpdateManyWithoutProductInput
    products_in_bag?: ProductInBagUpdateManyWithoutProductInput
    offers?: OfferUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shopId?: IntFieldUpdateOperationsInput | number
    category?: EnumProductCategoryFieldUpdateOperationsInput | ProductCategory
    rate?: EnumProductRateFieldUpdateOperationsInput | ProductRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
    products_in_shop?: ProductInShopUncheckedUpdateManyWithoutProductInput
    products_in_bag?: ProductInBagUncheckedUpdateManyWithoutProductInput
    offers?: OfferUncheckedUpdateManyWithoutProductInput
  }

  export type ProductCreateManyInput = {
    id: number
    name: string
    shopId: number
    category?: ProductCategory
    rate?: ProductRate
    description?: string | null
  }

  export type ProductUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumProductCategoryFieldUpdateOperationsInput | ProductCategory
    rate?: EnumProductRateFieldUpdateOperationsInput | ProductRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shopId?: IntFieldUpdateOperationsInput | number
    category?: EnumProductCategoryFieldUpdateOperationsInput | ProductCategory
    rate?: EnumProductRateFieldUpdateOperationsInput | ProductRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShopCreateInput = {
    id: number
    name: string
    status: ShopStatus
    member: MemberCreateNestedOneWithoutShopsInput
    rate?: ShopRate
    description?: string | null
    role?: RoleCreateNestedManyWithoutShopInput
    products?: ProductCreateNestedManyWithoutShopInput
    products_in_shop?: ProductInShopCreateNestedManyWithoutShopInput
    bags?: ShoppingBagCreateNestedManyWithoutShopInput
    discounts?: DiscountCreateNestedManyWithoutShopInput
    policies?: PolicyCreateNestedManyWithoutShopInput
    offers?: OfferCreateNestedManyWithoutShopInput
    appointments?: AppointmentCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateInput = {
    id: number
    name: string
    status: ShopStatus
    shop_founder: string
    rate?: ShopRate
    description?: string | null
    role?: RoleUncheckedCreateNestedManyWithoutShopInput
    products?: ProductUncheckedCreateNestedManyWithoutShopInput
    products_in_shop?: ProductInShopUncheckedCreateNestedManyWithoutShopInput
    bags?: ShoppingBagUncheckedCreateNestedManyWithoutShopInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutShopInput
    policies?: PolicyUncheckedCreateNestedManyWithoutShopInput
    offers?: OfferUncheckedCreateNestedManyWithoutShopInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | ShopStatus
    member?: MemberUpdateOneRequiredWithoutShopsInput
    rate?: EnumShopRateFieldUpdateOperationsInput | ShopRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
    role?: RoleUpdateManyWithoutShopInput
    products?: ProductUpdateManyWithoutShopInput
    products_in_shop?: ProductInShopUpdateManyWithoutShopInput
    bags?: ShoppingBagUpdateManyWithoutShopInput
    discounts?: DiscountUpdateManyWithoutShopInput
    policies?: PolicyUpdateManyWithoutShopInput
    offers?: OfferUpdateManyWithoutShopInput
    appointments?: AppointmentUpdateManyWithoutShopInput
  }

  export type ShopUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | ShopStatus
    shop_founder?: StringFieldUpdateOperationsInput | string
    rate?: EnumShopRateFieldUpdateOperationsInput | ShopRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
    role?: RoleUncheckedUpdateManyWithoutShopInput
    products?: ProductUncheckedUpdateManyWithoutShopInput
    products_in_shop?: ProductInShopUncheckedUpdateManyWithoutShopInput
    bags?: ShoppingBagUncheckedUpdateManyWithoutShopInput
    discounts?: DiscountUncheckedUpdateManyWithoutShopInput
    policies?: PolicyUncheckedUpdateManyWithoutShopInput
    offers?: OfferUncheckedUpdateManyWithoutShopInput
    appointments?: AppointmentUncheckedUpdateManyWithoutShopInput
  }

  export type ShopCreateManyInput = {
    id: number
    name: string
    status: ShopStatus
    shop_founder: string
    rate?: ShopRate
    description?: string | null
  }

  export type ShopUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | ShopStatus
    rate?: EnumShopRateFieldUpdateOperationsInput | ShopRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShopUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | ShopStatus
    shop_founder?: StringFieldUpdateOperationsInput | string
    rate?: EnumShopRateFieldUpdateOperationsInput | ShopRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShopOwnerCreateInput = {
    role: RoleCreateNestedOneWithoutShop_ownersInput
  }

  export type ShopOwnerUncheckedCreateInput = {
    username: string
    shopId: number
  }

  export type ShopOwnerUpdateInput = {
    role?: RoleUpdateOneRequiredWithoutShop_ownersInput
  }

  export type ShopOwnerUncheckedUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    shopId?: IntFieldUpdateOperationsInput | number
  }

  export type ShopOwnerCreateManyInput = {
    username: string
    shopId: number
  }

  export type ShopOwnerUpdateManyMutationInput = {

  }

  export type ShopOwnerUncheckedUpdateManyInput = {
    username?: StringFieldUpdateOperationsInput | string
    shopId?: IntFieldUpdateOperationsInput | number
  }

  export type ShopManagerCreateInput = {
    role: RoleCreateNestedOneWithoutShop_managersInput
  }

  export type ShopManagerUncheckedCreateInput = {
    username: string
    shopId: number
  }

  export type ShopManagerUpdateInput = {
    role?: RoleUpdateOneRequiredWithoutShop_managersInput
  }

  export type ShopManagerUncheckedUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    shopId?: IntFieldUpdateOperationsInput | number
  }

  export type ShopManagerCreateManyInput = {
    username: string
    shopId: number
  }

  export type ShopManagerUpdateManyMutationInput = {

  }

  export type ShopManagerUncheckedUpdateManyInput = {
    username?: StringFieldUpdateOperationsInput | string
    shopId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductInShopCreateInput = {
    shop: ShopCreateNestedOneWithoutProducts_in_shopInput
    product: ProductCreateNestedOneWithoutProducts_in_shopInput
    product_quantity?: number
  }

  export type ProductInShopUncheckedCreateInput = {
    shopId: number
    productId: number
    product_quantity?: number
  }

  export type ProductInShopUpdateInput = {
    shop?: ShopUpdateOneRequiredWithoutProducts_in_shopInput
    product?: ProductUpdateOneRequiredWithoutProducts_in_shopInput
    product_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ProductInShopUncheckedUpdateInput = {
    shopId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    product_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ProductInShopCreateManyInput = {
    shopId: number
    productId: number
    product_quantity?: number
  }

  export type ProductInShopUpdateManyMutationInput = {
    product_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ProductInShopUncheckedUpdateManyInput = {
    shopId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    product_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ShoppingCartCreateInput = {
    member: MemberCreateNestedOneWithoutShoppingCartInput
    bags?: ShoppingBagCreateNestedManyWithoutShoppingCartInput
  }

  export type ShoppingCartUncheckedCreateInput = {
    username: string
    bags?: ShoppingBagUncheckedCreateNestedManyWithoutShoppingCartInput
  }

  export type ShoppingCartUpdateInput = {
    member?: MemberUpdateOneRequiredWithoutShoppingCartInput
    bags?: ShoppingBagUpdateManyWithoutShoppingCartInput
  }

  export type ShoppingCartUncheckedUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    bags?: ShoppingBagUncheckedUpdateManyWithoutShoppingCartInput
  }

  export type ShoppingCartCreateManyInput = {
    username: string
  }

  export type ShoppingCartUpdateManyMutationInput = {

  }

  export type ShoppingCartUncheckedUpdateManyInput = {
    username?: StringFieldUpdateOperationsInput | string
  }

  export type ShoppingBagCreateInput = {
    shoppingCart: ShoppingCartCreateNestedOneWithoutBagsInput
    shop: ShopCreateNestedOneWithoutBagsInput
    products_in_bag?: ProductInBagCreateNestedManyWithoutShoppingBagInput
  }

  export type ShoppingBagUncheckedCreateInput = {
    username: string
    shopId: number
    products_in_bag?: ProductInBagUncheckedCreateNestedManyWithoutShoppingBagInput
  }

  export type ShoppingBagUpdateInput = {
    shoppingCart?: ShoppingCartUpdateOneRequiredWithoutBagsInput
    shop?: ShopUpdateOneRequiredWithoutBagsInput
    products_in_bag?: ProductInBagUpdateManyWithoutShoppingBagInput
  }

  export type ShoppingBagUncheckedUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    shopId?: IntFieldUpdateOperationsInput | number
    products_in_bag?: ProductInBagUncheckedUpdateManyWithoutShoppingBagInput
  }

  export type ShoppingBagCreateManyInput = {
    username: string
    shopId: number
  }

  export type ShoppingBagUpdateManyMutationInput = {

  }

  export type ShoppingBagUncheckedUpdateManyInput = {
    username?: StringFieldUpdateOperationsInput | string
    shopId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductInBagCreateInput = {
    shoppingBag: ShoppingBagCreateNestedOneWithoutProducts_in_bagInput
    product: ProductCreateNestedOneWithoutProducts_in_bagInput
    product_quantity?: number
  }

  export type ProductInBagUncheckedCreateInput = {
    username: string
    shopId: number
    productId: number
    product_quantity?: number
  }

  export type ProductInBagUpdateInput = {
    shoppingBag?: ShoppingBagUpdateOneRequiredWithoutProducts_in_bagInput
    product?: ProductUpdateOneRequiredWithoutProducts_in_bagInput
    product_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ProductInBagUncheckedUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    shopId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    product_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ProductInBagCreateManyInput = {
    username: string
    shopId: number
    productId: number
    product_quantity?: number
  }

  export type ProductInBagUpdateManyMutationInput = {
    product_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ProductInBagUncheckedUpdateManyInput = {
    username?: StringFieldUpdateOperationsInput | string
    shopId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    product_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type MemberCredentialsCreateInput = {
    member?: MemberCreateNestedOneWithoutMemberCredentialsInput
    password: string
  }

  export type MemberCredentialsUncheckedCreateInput = {
    username: string
    password: string
  }

  export type MemberCredentialsUpdateInput = {
    member?: MemberUpdateOneWithoutMemberCredentialsInput
    password?: StringFieldUpdateOperationsInput | string
  }

  export type MemberCredentialsUncheckedUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type MemberCredentialsCreateManyInput = {
    username: string
    password: string
  }

  export type MemberCredentialsUpdateManyMutationInput = {
    password?: StringFieldUpdateOperationsInput | string
  }

  export type MemberCredentialsUncheckedUpdateManyInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type MessageCreateInput = {
    id: number
    timestamp: number
    isRead: boolean
    messageType: MessageType
    recipients?: MessageRecipientsCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id: number
    timestamp: number
    isRead: boolean
    messageType: MessageType
    recipients?: MessageRecipientsUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: IntFieldUpdateOperationsInput | number
    isRead?: BoolFieldUpdateOperationsInput | boolean
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | MessageType
    recipients?: MessageRecipientsUpdateManyWithoutMessageInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: IntFieldUpdateOperationsInput | number
    isRead?: BoolFieldUpdateOperationsInput | boolean
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | MessageType
    recipients?: MessageRecipientsUncheckedUpdateManyWithoutMessageInput
  }

  export type MessageCreateManyInput = {
    id: number
    timestamp: number
    isRead: boolean
    messageType: MessageType
  }

  export type MessageUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: IntFieldUpdateOperationsInput | number
    isRead?: BoolFieldUpdateOperationsInput | boolean
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | MessageType
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: IntFieldUpdateOperationsInput | number
    isRead?: BoolFieldUpdateOperationsInput | boolean
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | MessageType
  }

  export type MessageRecipientsCreateInput = {
    message: MessageCreateNestedOneWithoutRecipientsInput
    member: MemberCreateNestedOneWithoutMessageRecipientsInput
  }

  export type MessageRecipientsUncheckedCreateInput = {
    messageId: number
    username: string
  }

  export type MessageRecipientsUpdateInput = {
    message?: MessageUpdateOneRequiredWithoutRecipientsInput
    member?: MemberUpdateOneRequiredWithoutMessageRecipientsInput
  }

  export type MessageRecipientsUncheckedUpdateInput = {
    messageId?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
  }

  export type MessageRecipientsCreateManyInput = {
    messageId: number
    username: string
  }

  export type MessageRecipientsUpdateManyMutationInput = {

  }

  export type MessageRecipientsUncheckedUpdateManyInput = {
    messageId?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
  }

  export type DiscountCreateInput = {
    id: number
    shop: ShopCreateNestedOneWithoutDiscountsInput
    kind: DiscountKinds
    simpleDiscount?: SimpleDiscountCreateNestedOneWithoutDiscountInput
    conditionalDiscount?: ConditionalDiscountCreateNestedOneWithoutDiscountInput
    discountContainer?: DiscountContainerCreateNestedOneWithoutDiscountInput
    discountInContainer?: DiscountInContainerCreateNestedOneWithoutDiscountInput
  }

  export type DiscountUncheckedCreateInput = {
    id: number
    shopId: number
    kind: DiscountKinds
    simpleDiscount?: SimpleDiscountUncheckedCreateNestedOneWithoutDiscountInput
    conditionalDiscount?: ConditionalDiscountUncheckedCreateNestedOneWithoutDiscountInput
    discountContainer?: DiscountContainerUncheckedCreateNestedOneWithoutDiscountInput
    discountInContainer?: DiscountInContainerUncheckedCreateNestedOneWithoutDiscountInput
  }

  export type DiscountUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    shop?: ShopUpdateOneRequiredWithoutDiscountsInput
    kind?: EnumDiscountKindsFieldUpdateOperationsInput | DiscountKinds
    simpleDiscount?: SimpleDiscountUpdateOneWithoutDiscountInput
    conditionalDiscount?: ConditionalDiscountUpdateOneWithoutDiscountInput
    discountContainer?: DiscountContainerUpdateOneWithoutDiscountInput
    discountInContainer?: DiscountInContainerUpdateOneWithoutDiscountInput
  }

  export type DiscountUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    kind?: EnumDiscountKindsFieldUpdateOperationsInput | DiscountKinds
    simpleDiscount?: SimpleDiscountUncheckedUpdateOneWithoutDiscountInput
    conditionalDiscount?: ConditionalDiscountUncheckedUpdateOneWithoutDiscountInput
    discountContainer?: DiscountContainerUncheckedUpdateOneWithoutDiscountInput
    discountInContainer?: DiscountInContainerUncheckedUpdateOneWithoutDiscountInput
  }

  export type DiscountCreateManyInput = {
    id: number
    shopId: number
    kind: DiscountKinds
  }

  export type DiscountUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    kind?: EnumDiscountKindsFieldUpdateOperationsInput | DiscountKinds
  }

  export type DiscountUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    kind?: EnumDiscountKindsFieldUpdateOperationsInput | DiscountKinds
  }

  export type SimpleDiscountCreateInput = {
    discount: DiscountCreateNestedOneWithoutSimpleDiscountInput
    discountType: DiscountType
    discountPercent: number
    description: string
    productId?: number | null
    category?: ProductCategory | null
    conditionalDiscount?: ConditionalDiscountCreateNestedOneWithoutSimpleDiscountInput
  }

  export type SimpleDiscountUncheckedCreateInput = {
    id: number
    shopId: number
    discountType: DiscountType
    discountPercent: number
    description: string
    productId?: number | null
    category?: ProductCategory | null
    conditionalDiscount?: ConditionalDiscountUncheckedCreateNestedOneWithoutSimpleDiscountInput
  }

  export type SimpleDiscountUpdateInput = {
    discount?: DiscountUpdateOneRequiredWithoutSimpleDiscountInput
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | DiscountType
    discountPercent?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableEnumProductCategoryFieldUpdateOperationsInput | ProductCategory | null
    conditionalDiscount?: ConditionalDiscountUpdateOneWithoutSimpleDiscountInput
  }

  export type SimpleDiscountUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | DiscountType
    discountPercent?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableEnumProductCategoryFieldUpdateOperationsInput | ProductCategory | null
    conditionalDiscount?: ConditionalDiscountUncheckedUpdateOneWithoutSimpleDiscountInput
  }

  export type SimpleDiscountCreateManyInput = {
    id: number
    shopId: number
    discountType: DiscountType
    discountPercent: number
    description: string
    productId?: number | null
    category?: ProductCategory | null
  }

  export type SimpleDiscountUpdateManyMutationInput = {
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | DiscountType
    discountPercent?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableEnumProductCategoryFieldUpdateOperationsInput | ProductCategory | null
  }

  export type SimpleDiscountUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | DiscountType
    discountPercent?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableEnumProductCategoryFieldUpdateOperationsInput | ProductCategory | null
  }

  export type ConditionalDiscountCreateInput = {
    discount: DiscountCreateNestedOneWithoutConditionalDiscountInput
    simpleDiscount: SimpleDiscountCreateNestedOneWithoutConditionalDiscountInput
    discountPredicate?: DiscountPredicateCreateNestedOneWithoutDiscountInput
  }

  export type ConditionalDiscountUncheckedCreateInput = {
    id: number
    shopId: number
    simpleId: number
    simpleShopId: number
    discountPredicate?: DiscountPredicateUncheckedCreateNestedOneWithoutDiscountInput
  }

  export type ConditionalDiscountUpdateInput = {
    discount?: DiscountUpdateOneRequiredWithoutConditionalDiscountInput
    simpleDiscount?: SimpleDiscountUpdateOneRequiredWithoutConditionalDiscountInput
    discountPredicate?: DiscountPredicateUpdateOneWithoutDiscountInput
  }

  export type ConditionalDiscountUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    simpleId?: IntFieldUpdateOperationsInput | number
    simpleShopId?: IntFieldUpdateOperationsInput | number
    discountPredicate?: DiscountPredicateUncheckedUpdateOneWithoutDiscountInput
  }

  export type ConditionalDiscountCreateManyInput = {
    id: number
    shopId: number
    simpleId: number
    simpleShopId: number
  }

  export type ConditionalDiscountUpdateManyMutationInput = {

  }

  export type ConditionalDiscountUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    simpleId?: IntFieldUpdateOperationsInput | number
    simpleShopId?: IntFieldUpdateOperationsInput | number
  }

  export type DiscountPredicateCreateInput = {
    discount: ConditionalDiscountCreateNestedOneWithoutDiscountPredicateInput
    discountType: DiscountType
    relation: RelationType
    value: number
    description: string
    productId?: number | null
    category?: ProductCategory | null
  }

  export type DiscountPredicateUncheckedCreateInput = {
    discountId: number
    shopId: number
    discountType: DiscountType
    relation: RelationType
    value: number
    description: string
    productId?: number | null
    category?: ProductCategory | null
  }

  export type DiscountPredicateUpdateInput = {
    discount?: ConditionalDiscountUpdateOneRequiredWithoutDiscountPredicateInput
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | DiscountType
    relation?: EnumRelationTypeFieldUpdateOperationsInput | RelationType
    value?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableEnumProductCategoryFieldUpdateOperationsInput | ProductCategory | null
  }

  export type DiscountPredicateUncheckedUpdateInput = {
    discountId?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | DiscountType
    relation?: EnumRelationTypeFieldUpdateOperationsInput | RelationType
    value?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableEnumProductCategoryFieldUpdateOperationsInput | ProductCategory | null
  }

  export type DiscountPredicateCreateManyInput = {
    discountId: number
    shopId: number
    discountType: DiscountType
    relation: RelationType
    value: number
    description: string
    productId?: number | null
    category?: ProductCategory | null
  }

  export type DiscountPredicateUpdateManyMutationInput = {
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | DiscountType
    relation?: EnumRelationTypeFieldUpdateOperationsInput | RelationType
    value?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableEnumProductCategoryFieldUpdateOperationsInput | ProductCategory | null
  }

  export type DiscountPredicateUncheckedUpdateManyInput = {
    discountId?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | DiscountType
    relation?: EnumRelationTypeFieldUpdateOperationsInput | RelationType
    value?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableEnumProductCategoryFieldUpdateOperationsInput | ProductCategory | null
  }

  export type DiscountContainerCreateInput = {
    discount: DiscountCreateNestedOneWithoutDiscountContainerInput
    description: string
    type: DiscountRelation
    discounts?: DiscountInContainerCreateNestedManyWithoutDiscountContainerInput
  }

  export type DiscountContainerUncheckedCreateInput = {
    id: number
    shopId: number
    description: string
    type: DiscountRelation
    discounts?: DiscountInContainerUncheckedCreateNestedManyWithoutDiscountContainerInput
  }

  export type DiscountContainerUpdateInput = {
    discount?: DiscountUpdateOneRequiredWithoutDiscountContainerInput
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountRelationFieldUpdateOperationsInput | DiscountRelation
    discounts?: DiscountInContainerUpdateManyWithoutDiscountContainerInput
  }

  export type DiscountContainerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountRelationFieldUpdateOperationsInput | DiscountRelation
    discounts?: DiscountInContainerUncheckedUpdateManyWithoutDiscountContainerInput
  }

  export type DiscountContainerCreateManyInput = {
    id: number
    shopId: number
    description: string
    type: DiscountRelation
  }

  export type DiscountContainerUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountRelationFieldUpdateOperationsInput | DiscountRelation
  }

  export type DiscountContainerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountRelationFieldUpdateOperationsInput | DiscountRelation
  }

  export type DiscountInContainerCreateInput = {
    discount: DiscountCreateNestedOneWithoutDiscountInContainerInput
    discountContainer: DiscountContainerCreateNestedOneWithoutDiscountsInput
  }

  export type DiscountInContainerUncheckedCreateInput = {
    containedDiscount: number
    shopId: number
    containingDiscount: number
  }

  export type DiscountInContainerUpdateInput = {
    discount?: DiscountUpdateOneRequiredWithoutDiscountInContainerInput
    discountContainer?: DiscountContainerUpdateOneRequiredWithoutDiscountsInput
  }

  export type DiscountInContainerUncheckedUpdateInput = {
    containedDiscount?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    containingDiscount?: IntFieldUpdateOperationsInput | number
  }

  export type DiscountInContainerCreateManyInput = {
    containedDiscount: number
    shopId: number
    containingDiscount: number
  }

  export type DiscountInContainerUpdateManyMutationInput = {

  }

  export type DiscountInContainerUncheckedUpdateManyInput = {
    containedDiscount?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    containingDiscount?: IntFieldUpdateOperationsInput | number
  }

  export type PolicyCreateInput = {
    id: number
    shop: ShopCreateNestedOneWithoutPoliciesInput
    simplePolicy?: SimplePolicyCreateNestedOneWithoutPolicyInput
    conditionalPolicy?: ConditionalPolicyCreateNestedOneWithoutPolicyInput
    logicalPolicy?: LogicalPolicyCreateNestedOneWithoutPolicyInput
    policyInContainer?: PolicyInContainerCreateNestedOneWithoutPolicyInput
  }

  export type PolicyUncheckedCreateInput = {
    id: number
    shopId: number
    simplePolicy?: SimplePolicyUncheckedCreateNestedOneWithoutPolicyInput
    conditionalPolicy?: ConditionalPolicyUncheckedCreateNestedOneWithoutPolicyInput
    logicalPolicy?: LogicalPolicyUncheckedCreateNestedOneWithoutPolicyInput
    policyInContainer?: PolicyInContainerUncheckedCreateNestedOneWithoutPolicyInput
  }

  export type PolicyUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    shop?: ShopUpdateOneRequiredWithoutPoliciesInput
    simplePolicy?: SimplePolicyUpdateOneWithoutPolicyInput
    conditionalPolicy?: ConditionalPolicyUpdateOneWithoutPolicyInput
    logicalPolicy?: LogicalPolicyUpdateOneWithoutPolicyInput
    policyInContainer?: PolicyInContainerUpdateOneWithoutPolicyInput
  }

  export type PolicyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    simplePolicy?: SimplePolicyUncheckedUpdateOneWithoutPolicyInput
    conditionalPolicy?: ConditionalPolicyUncheckedUpdateOneWithoutPolicyInput
    logicalPolicy?: LogicalPolicyUncheckedUpdateOneWithoutPolicyInput
    policyInContainer?: PolicyInContainerUncheckedUpdateOneWithoutPolicyInput
  }

  export type PolicyCreateManyInput = {
    id: number
    shopId: number
  }

  export type PolicyUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type PolicyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
  }

  export type SimplePolicyCreateInput = {
    policy: PolicyCreateNestedOneWithoutSimplePolicyInput
    okay: boolean
    message: string
  }

  export type SimplePolicyUncheckedCreateInput = {
    id: number
    shopId: number
    okay: boolean
    message: string
  }

  export type SimplePolicyUpdateInput = {
    policy?: PolicyUpdateOneRequiredWithoutSimplePolicyInput
    okay?: BoolFieldUpdateOperationsInput | boolean
    message?: StringFieldUpdateOperationsInput | string
  }

  export type SimplePolicyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    okay?: BoolFieldUpdateOperationsInput | boolean
    message?: StringFieldUpdateOperationsInput | string
  }

  export type SimplePolicyCreateManyInput = {
    id: number
    shopId: number
    okay: boolean
    message: string
  }

  export type SimplePolicyUpdateManyMutationInput = {
    okay?: BoolFieldUpdateOperationsInput | boolean
    message?: StringFieldUpdateOperationsInput | string
  }

  export type SimplePolicyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    okay?: BoolFieldUpdateOperationsInput | boolean
    message?: StringFieldUpdateOperationsInput | string
  }

  export type ConditionalPolicyCreateInput = {
    policy: PolicyCreateNestedOneWithoutConditionalPolicyInput
    dependent: number
    dependentShopId: number
    dependentOn: number
    dependentOnShopId: number
    description: string
    policyPredicate?: PolicyPredicateCreateNestedOneWithoutPolicyInput
  }

  export type ConditionalPolicyUncheckedCreateInput = {
    id: number
    shopId: number
    dependent: number
    dependentShopId: number
    dependentOn: number
    dependentOnShopId: number
    description: string
    policyPredicate?: PolicyPredicateUncheckedCreateNestedOneWithoutPolicyInput
  }

  export type ConditionalPolicyUpdateInput = {
    policy?: PolicyUpdateOneRequiredWithoutConditionalPolicyInput
    dependent?: IntFieldUpdateOperationsInput | number
    dependentShopId?: IntFieldUpdateOperationsInput | number
    dependentOn?: IntFieldUpdateOperationsInput | number
    dependentOnShopId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    policyPredicate?: PolicyPredicateUpdateOneWithoutPolicyInput
  }

  export type ConditionalPolicyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    dependent?: IntFieldUpdateOperationsInput | number
    dependentShopId?: IntFieldUpdateOperationsInput | number
    dependentOn?: IntFieldUpdateOperationsInput | number
    dependentOnShopId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    policyPredicate?: PolicyPredicateUncheckedUpdateOneWithoutPolicyInput
  }

  export type ConditionalPolicyCreateManyInput = {
    id: number
    shopId: number
    dependent: number
    dependentShopId: number
    dependentOn: number
    dependentOnShopId: number
    description: string
  }

  export type ConditionalPolicyUpdateManyMutationInput = {
    dependent?: IntFieldUpdateOperationsInput | number
    dependentShopId?: IntFieldUpdateOperationsInput | number
    dependentOn?: IntFieldUpdateOperationsInput | number
    dependentOnShopId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ConditionalPolicyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    dependent?: IntFieldUpdateOperationsInput | number
    dependentShopId?: IntFieldUpdateOperationsInput | number
    dependentOn?: IntFieldUpdateOperationsInput | number
    dependentOnShopId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
  }

  export type PolicyPredicateCreateInput = {
    policy: ConditionalPolicyCreateNestedOneWithoutPolicyPredicateInput
    policyType: SimplePolicyType
    relation: RelationType
    value: number
    description: string
    productId?: number | null
    productCategory?: ProductCategory | null
    guest?: string | null
  }

  export type PolicyPredicateUncheckedCreateInput = {
    policyId: number
    shopId: number
    policyType: SimplePolicyType
    relation: RelationType
    value: number
    description: string
    productId?: number | null
    productCategory?: ProductCategory | null
    guest?: string | null
  }

  export type PolicyPredicateUpdateInput = {
    policy?: ConditionalPolicyUpdateOneRequiredWithoutPolicyPredicateInput
    policyType?: EnumSimplePolicyTypeFieldUpdateOperationsInput | SimplePolicyType
    relation?: EnumRelationTypeFieldUpdateOperationsInput | RelationType
    value?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    productCategory?: NullableEnumProductCategoryFieldUpdateOperationsInput | ProductCategory | null
    guest?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PolicyPredicateUncheckedUpdateInput = {
    policyId?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    policyType?: EnumSimplePolicyTypeFieldUpdateOperationsInput | SimplePolicyType
    relation?: EnumRelationTypeFieldUpdateOperationsInput | RelationType
    value?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    productCategory?: NullableEnumProductCategoryFieldUpdateOperationsInput | ProductCategory | null
    guest?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PolicyPredicateCreateManyInput = {
    policyId: number
    shopId: number
    policyType: SimplePolicyType
    relation: RelationType
    value: number
    description: string
    productId?: number | null
    productCategory?: ProductCategory | null
    guest?: string | null
  }

  export type PolicyPredicateUpdateManyMutationInput = {
    policyType?: EnumSimplePolicyTypeFieldUpdateOperationsInput | SimplePolicyType
    relation?: EnumRelationTypeFieldUpdateOperationsInput | RelationType
    value?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    productCategory?: NullableEnumProductCategoryFieldUpdateOperationsInput | ProductCategory | null
    guest?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PolicyPredicateUncheckedUpdateManyInput = {
    policyId?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    policyType?: EnumSimplePolicyTypeFieldUpdateOperationsInput | SimplePolicyType
    relation?: EnumRelationTypeFieldUpdateOperationsInput | RelationType
    value?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    productCategory?: NullableEnumProductCategoryFieldUpdateOperationsInput | ProductCategory | null
    guest?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogicalPolicyCreateInput = {
    policy: PolicyCreateNestedOneWithoutLogicalPolicyInput
    description: string
    purchasePoliciesRelation: PurchasePoliciesRelation
    policies?: PolicyInContainerCreateNestedManyWithoutPolicyContainerInput
  }

  export type LogicalPolicyUncheckedCreateInput = {
    id: number
    shopId: number
    description: string
    purchasePoliciesRelation: PurchasePoliciesRelation
    policies?: PolicyInContainerUncheckedCreateNestedManyWithoutPolicyContainerInput
  }

  export type LogicalPolicyUpdateInput = {
    policy?: PolicyUpdateOneRequiredWithoutLogicalPolicyInput
    description?: StringFieldUpdateOperationsInput | string
    purchasePoliciesRelation?: EnumPurchasePoliciesRelationFieldUpdateOperationsInput | PurchasePoliciesRelation
    policies?: PolicyInContainerUpdateManyWithoutPolicyContainerInput
  }

  export type LogicalPolicyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    purchasePoliciesRelation?: EnumPurchasePoliciesRelationFieldUpdateOperationsInput | PurchasePoliciesRelation
    policies?: PolicyInContainerUncheckedUpdateManyWithoutPolicyContainerInput
  }

  export type LogicalPolicyCreateManyInput = {
    id: number
    shopId: number
    description: string
    purchasePoliciesRelation: PurchasePoliciesRelation
  }

  export type LogicalPolicyUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    purchasePoliciesRelation?: EnumPurchasePoliciesRelationFieldUpdateOperationsInput | PurchasePoliciesRelation
  }

  export type LogicalPolicyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    purchasePoliciesRelation?: EnumPurchasePoliciesRelationFieldUpdateOperationsInput | PurchasePoliciesRelation
  }

  export type PolicyInContainerCreateInput = {
    policy: PolicyCreateNestedOneWithoutPolicyInContainerInput
    policyContainer: LogicalPolicyCreateNestedOneWithoutPoliciesInput
  }

  export type PolicyInContainerUncheckedCreateInput = {
    containedPolicy: number
    shopId: number
    containingPolicy: number
  }

  export type PolicyInContainerUpdateInput = {
    policy?: PolicyUpdateOneRequiredWithoutPolicyInContainerInput
    policyContainer?: LogicalPolicyUpdateOneRequiredWithoutPoliciesInput
  }

  export type PolicyInContainerUncheckedUpdateInput = {
    containedPolicy?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    containingPolicy?: IntFieldUpdateOperationsInput | number
  }

  export type PolicyInContainerCreateManyInput = {
    containedPolicy: number
    shopId: number
    containingPolicy: number
  }

  export type PolicyInContainerUpdateManyMutationInput = {

  }

  export type PolicyInContainerUncheckedUpdateManyInput = {
    containedPolicy?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    containingPolicy?: IntFieldUpdateOperationsInput | number
  }

  export type OfferCreateInput = {
    id: number
    member: MemberCreateNestedOneWithoutOffersInput
    shop: ShopCreateNestedOneWithoutOffersInput
    product: ProductCreateNestedOneWithoutOffersInput
    price: number
    offerApprover?: OfferApproverCreateNestedManyWithoutOfferInput
  }

  export type OfferUncheckedCreateInput = {
    id: number
    username: string
    shopId: number
    productId: number
    price: number
    offerApprover?: OfferApproverUncheckedCreateNestedManyWithoutOfferInput
  }

  export type OfferUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    member?: MemberUpdateOneRequiredWithoutOffersInput
    shop?: ShopUpdateOneRequiredWithoutOffersInput
    product?: ProductUpdateOneRequiredWithoutOffersInput
    price?: FloatFieldUpdateOperationsInput | number
    offerApprover?: OfferApproverUpdateManyWithoutOfferInput
  }

  export type OfferUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    shopId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    offerApprover?: OfferApproverUncheckedUpdateManyWithoutOfferInput
  }

  export type OfferCreateManyInput = {
    id: number
    username: string
    shopId: number
    productId: number
    price: number
  }

  export type OfferUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type OfferUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    shopId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type OfferApproverCreateInput = {
    member: MemberCreateNestedOneWithoutOfferApproversInput
    offer: OfferCreateNestedOneWithoutOfferApproverInput
    answered?: boolean
    approved?: boolean
  }

  export type OfferApproverUncheckedCreateInput = {
    username: string
    offerId: number
    answered?: boolean
    approved?: boolean
  }

  export type OfferApproverUpdateInput = {
    member?: MemberUpdateOneRequiredWithoutOfferApproversInput
    offer?: OfferUpdateOneRequiredWithoutOfferApproverInput
    answered?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OfferApproverUncheckedUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    offerId?: IntFieldUpdateOperationsInput | number
    answered?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OfferApproverCreateManyInput = {
    username: string
    offerId: number
    answered?: boolean
    approved?: boolean
  }

  export type OfferApproverUpdateManyMutationInput = {
    answered?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OfferApproverUncheckedUpdateManyInput = {
    username?: StringFieldUpdateOperationsInput | string
    offerId?: IntFieldUpdateOperationsInput | number
    answered?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AppointmentCreateInput = {
    member: MemberCreateNestedOneWithoutAppointmentsInput
    shop: ShopCreateNestedOneWithoutAppointmentsInput
    assigner: string
    appointmentAgreements?: AppointmentAgreementCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateInput = {
    username: string
    shopId: number
    assigner: string
    appointmentAgreements?: AppointmentAgreementUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUpdateInput = {
    member?: MemberUpdateOneRequiredWithoutAppointmentsInput
    shop?: ShopUpdateOneRequiredWithoutAppointmentsInput
    assigner?: StringFieldUpdateOperationsInput | string
    appointmentAgreements?: AppointmentAgreementUpdateManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    shopId?: IntFieldUpdateOperationsInput | number
    assigner?: StringFieldUpdateOperationsInput | string
    appointmentAgreements?: AppointmentAgreementUncheckedUpdateManyWithoutAppointmentInput
  }

  export type AppointmentCreateManyInput = {
    username: string
    shopId: number
    assigner: string
  }

  export type AppointmentUpdateManyMutationInput = {
    assigner?: StringFieldUpdateOperationsInput | string
  }

  export type AppointmentUncheckedUpdateManyInput = {
    username?: StringFieldUpdateOperationsInput | string
    shopId?: IntFieldUpdateOperationsInput | number
    assigner?: StringFieldUpdateOperationsInput | string
  }

  export type AppointmentAgreementCreateInput = {
    appointment: AppointmentCreateNestedOneWithoutAppointmentAgreementsInput
    approver: string
    answered?: boolean
    approved?: boolean
  }

  export type AppointmentAgreementUncheckedCreateInput = {
    username: string
    shopId: number
    approver: string
    answered?: boolean
    approved?: boolean
  }

  export type AppointmentAgreementUpdateInput = {
    appointment?: AppointmentUpdateOneRequiredWithoutAppointmentAgreementsInput
    approver?: StringFieldUpdateOperationsInput | string
    answered?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AppointmentAgreementUncheckedUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    shopId?: IntFieldUpdateOperationsInput | number
    approver?: StringFieldUpdateOperationsInput | string
    answered?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AppointmentAgreementCreateManyInput = {
    username: string
    shopId: number
    approver: string
    answered?: boolean
    approved?: boolean
  }

  export type AppointmentAgreementUpdateManyMutationInput = {
    approver?: StringFieldUpdateOperationsInput | string
    answered?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AppointmentAgreementUncheckedUpdateManyInput = {
    username?: StringFieldUpdateOperationsInput | string
    shopId?: IntFieldUpdateOperationsInput | number
    approver?: StringFieldUpdateOperationsInput | string
    answered?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type RoleListRelationFilter = {
    every?: RoleWhereInput
    some?: RoleWhereInput
    none?: RoleWhereInput
  }

  export type ShopListRelationFilter = {
    every?: ShopWhereInput
    some?: ShopWhereInput
    none?: ShopWhereInput
  }

  export type ShoppingCartRelationFilter = {
    is?: ShoppingCartWhereInput
    isNot?: ShoppingCartWhereInput
  }

  export type MemberCredentialsRelationFilter = {
    is?: MemberCredentialsWhereInput | null
    isNot?: MemberCredentialsWhereInput | null
  }

  export type OfferListRelationFilter = {
    every?: OfferWhereInput
    some?: OfferWhereInput
    none?: OfferWhereInput
  }

  export type OfferApproverListRelationFilter = {
    every?: OfferApproverWhereInput
    some?: OfferApproverWhereInput
    none?: OfferApproverWhereInput
  }

  export type AppointmentListRelationFilter = {
    every?: AppointmentWhereInput
    some?: AppointmentWhereInput
    none?: AppointmentWhereInput
  }

  export type MessageRecipientsListRelationFilter = {
    every?: MessageRecipientsWhereInput
    some?: MessageRecipientsWhereInput
    none?: MessageRecipientsWhereInput
  }

  export type RoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShopOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OfferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OfferApproverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageRecipientsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberCountOrderByAggregateInput = {
    username?: SortOrder
  }

  export type MemberMaxOrderByAggregateInput = {
    username?: SortOrder
  }

  export type MemberMinOrderByAggregateInput = {
    username?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type MemberRelationFilter = {
    is?: MemberWhereInput
    isNot?: MemberWhereInput
  }

  export type ShopRelationFilter = {
    is?: ShopWhereInput
    isNot?: ShopWhereInput
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type EnumJobTypeFilter = {
    equals?: JobType
    in?: Enumerable<JobType>
    notIn?: Enumerable<JobType>
    not?: NestedEnumJobTypeFilter | JobType
  }

  export type EnumPermissionsNullableListFilter = {
    equals?: Enumerable<Permissions> | null
    has?: Permissions | null
    hasEvery?: Enumerable<Permissions>
    hasSome?: Enumerable<Permissions>
    isEmpty?: boolean
  }

  export type ShopOwnerListRelationFilter = {
    every?: ShopOwnerWhereInput
    some?: ShopOwnerWhereInput
    none?: ShopOwnerWhereInput
  }

  export type ShopManagerListRelationFilter = {
    every?: ShopManagerWhereInput
    some?: ShopManagerWhereInput
    none?: ShopManagerWhereInput
  }

  export type ShopOwnerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShopManagerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleUsernameShopIdCompoundUniqueInput = {
    username: string
    shopId: number
  }

  export type RoleCountOrderByAggregateInput = {
    username?: SortOrder
    shopId?: SortOrder
    job_type?: SortOrder
    permissions?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    shopId?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    username?: SortOrder
    shopId?: SortOrder
    job_type?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    username?: SortOrder
    shopId?: SortOrder
    job_type?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    shopId?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type EnumJobTypeWithAggregatesFilter = {
    equals?: JobType
    in?: Enumerable<JobType>
    notIn?: Enumerable<JobType>
    not?: NestedEnumJobTypeWithAggregatesFilter | JobType
    _count?: NestedIntFilter
    _min?: NestedEnumJobTypeFilter
    _max?: NestedEnumJobTypeFilter
  }

  export type EnumProductCategoryFilter = {
    equals?: ProductCategory
    in?: Enumerable<ProductCategory>
    notIn?: Enumerable<ProductCategory>
    not?: NestedEnumProductCategoryFilter | ProductCategory
  }

  export type EnumProductRateFilter = {
    equals?: ProductRate
    in?: Enumerable<ProductRate>
    notIn?: Enumerable<ProductRate>
    not?: NestedEnumProductRateFilter | ProductRate
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type ProductInShopListRelationFilter = {
    every?: ProductInShopWhereInput
    some?: ProductInShopWhereInput
    none?: ProductInShopWhereInput
  }

  export type ProductInBagListRelationFilter = {
    every?: ProductInBagWhereInput
    some?: ProductInBagWhereInput
    none?: ProductInBagWhereInput
  }

  export type ProductInShopOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductInBagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shopId?: SortOrder
    category?: SortOrder
    rate?: SortOrder
    description?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shopId?: SortOrder
    category?: SortOrder
    rate?: SortOrder
    description?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shopId?: SortOrder
    category?: SortOrder
    rate?: SortOrder
    description?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
  }

  export type EnumProductCategoryWithAggregatesFilter = {
    equals?: ProductCategory
    in?: Enumerable<ProductCategory>
    notIn?: Enumerable<ProductCategory>
    not?: NestedEnumProductCategoryWithAggregatesFilter | ProductCategory
    _count?: NestedIntFilter
    _min?: NestedEnumProductCategoryFilter
    _max?: NestedEnumProductCategoryFilter
  }

  export type EnumProductRateWithAggregatesFilter = {
    equals?: ProductRate
    in?: Enumerable<ProductRate>
    notIn?: Enumerable<ProductRate>
    not?: NestedEnumProductRateWithAggregatesFilter | ProductRate
    _count?: NestedIntFilter
    _min?: NestedEnumProductRateFilter
    _max?: NestedEnumProductRateFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type EnumShopStatusFilter = {
    equals?: ShopStatus
    in?: Enumerable<ShopStatus>
    notIn?: Enumerable<ShopStatus>
    not?: NestedEnumShopStatusFilter | ShopStatus
  }

  export type EnumShopRateFilter = {
    equals?: ShopRate
    in?: Enumerable<ShopRate>
    notIn?: Enumerable<ShopRate>
    not?: NestedEnumShopRateFilter | ShopRate
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ShoppingBagListRelationFilter = {
    every?: ShoppingBagWhereInput
    some?: ShoppingBagWhereInput
    none?: ShoppingBagWhereInput
  }

  export type DiscountListRelationFilter = {
    every?: DiscountWhereInput
    some?: DiscountWhereInput
    none?: DiscountWhereInput
  }

  export type PolicyListRelationFilter = {
    every?: PolicyWhereInput
    some?: PolicyWhereInput
    none?: PolicyWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShoppingBagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DiscountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PolicyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShopCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    shop_founder?: SortOrder
    rate?: SortOrder
    description?: SortOrder
  }

  export type ShopAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ShopMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    shop_founder?: SortOrder
    rate?: SortOrder
    description?: SortOrder
  }

  export type ShopMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    shop_founder?: SortOrder
    rate?: SortOrder
    description?: SortOrder
  }

  export type ShopSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumShopStatusWithAggregatesFilter = {
    equals?: ShopStatus
    in?: Enumerable<ShopStatus>
    notIn?: Enumerable<ShopStatus>
    not?: NestedEnumShopStatusWithAggregatesFilter | ShopStatus
    _count?: NestedIntFilter
    _min?: NestedEnumShopStatusFilter
    _max?: NestedEnumShopStatusFilter
  }

  export type EnumShopRateWithAggregatesFilter = {
    equals?: ShopRate
    in?: Enumerable<ShopRate>
    notIn?: Enumerable<ShopRate>
    not?: NestedEnumShopRateWithAggregatesFilter | ShopRate
    _count?: NestedIntFilter
    _min?: NestedEnumShopRateFilter
    _max?: NestedEnumShopRateFilter
  }

  export type RoleRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type ShopOwnerUsernameShopIdCompoundUniqueInput = {
    username: string
    shopId: number
  }

  export type ShopOwnerCountOrderByAggregateInput = {
    username?: SortOrder
    shopId?: SortOrder
  }

  export type ShopOwnerAvgOrderByAggregateInput = {
    shopId?: SortOrder
  }

  export type ShopOwnerMaxOrderByAggregateInput = {
    username?: SortOrder
    shopId?: SortOrder
  }

  export type ShopOwnerMinOrderByAggregateInput = {
    username?: SortOrder
    shopId?: SortOrder
  }

  export type ShopOwnerSumOrderByAggregateInput = {
    shopId?: SortOrder
  }

  export type ShopManagerUsernameShopIdCompoundUniqueInput = {
    username: string
    shopId: number
  }

  export type ShopManagerCountOrderByAggregateInput = {
    username?: SortOrder
    shopId?: SortOrder
  }

  export type ShopManagerAvgOrderByAggregateInput = {
    shopId?: SortOrder
  }

  export type ShopManagerMaxOrderByAggregateInput = {
    username?: SortOrder
    shopId?: SortOrder
  }

  export type ShopManagerMinOrderByAggregateInput = {
    username?: SortOrder
    shopId?: SortOrder
  }

  export type ShopManagerSumOrderByAggregateInput = {
    shopId?: SortOrder
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type ProductInShopShopIdProductIdCompoundUniqueInput = {
    shopId: number
    productId: number
  }

  export type ProductInShopCountOrderByAggregateInput = {
    shopId?: SortOrder
    productId?: SortOrder
    product_quantity?: SortOrder
  }

  export type ProductInShopAvgOrderByAggregateInput = {
    shopId?: SortOrder
    productId?: SortOrder
    product_quantity?: SortOrder
  }

  export type ProductInShopMaxOrderByAggregateInput = {
    shopId?: SortOrder
    productId?: SortOrder
    product_quantity?: SortOrder
  }

  export type ProductInShopMinOrderByAggregateInput = {
    shopId?: SortOrder
    productId?: SortOrder
    product_quantity?: SortOrder
  }

  export type ProductInShopSumOrderByAggregateInput = {
    shopId?: SortOrder
    productId?: SortOrder
    product_quantity?: SortOrder
  }

  export type ShoppingCartCountOrderByAggregateInput = {
    username?: SortOrder
  }

  export type ShoppingCartMaxOrderByAggregateInput = {
    username?: SortOrder
  }

  export type ShoppingCartMinOrderByAggregateInput = {
    username?: SortOrder
  }

  export type ShoppingBagUsernameShopIdCompoundUniqueInput = {
    username: string
    shopId: number
  }

  export type ShoppingBagCountOrderByAggregateInput = {
    username?: SortOrder
    shopId?: SortOrder
  }

  export type ShoppingBagAvgOrderByAggregateInput = {
    shopId?: SortOrder
  }

  export type ShoppingBagMaxOrderByAggregateInput = {
    username?: SortOrder
    shopId?: SortOrder
  }

  export type ShoppingBagMinOrderByAggregateInput = {
    username?: SortOrder
    shopId?: SortOrder
  }

  export type ShoppingBagSumOrderByAggregateInput = {
    shopId?: SortOrder
  }

  export type ShoppingBagRelationFilter = {
    is?: ShoppingBagWhereInput
    isNot?: ShoppingBagWhereInput
  }

  export type ProductInBagUsernameShopIdProductIdCompoundUniqueInput = {
    username: string
    shopId: number
    productId: number
  }

  export type ProductInBagCountOrderByAggregateInput = {
    username?: SortOrder
    shopId?: SortOrder
    productId?: SortOrder
    product_quantity?: SortOrder
  }

  export type ProductInBagAvgOrderByAggregateInput = {
    shopId?: SortOrder
    productId?: SortOrder
    product_quantity?: SortOrder
  }

  export type ProductInBagMaxOrderByAggregateInput = {
    username?: SortOrder
    shopId?: SortOrder
    productId?: SortOrder
    product_quantity?: SortOrder
  }

  export type ProductInBagMinOrderByAggregateInput = {
    username?: SortOrder
    shopId?: SortOrder
    productId?: SortOrder
    product_quantity?: SortOrder
  }

  export type ProductInBagSumOrderByAggregateInput = {
    shopId?: SortOrder
    productId?: SortOrder
    product_quantity?: SortOrder
  }

  export type MemberCredentialsCountOrderByAggregateInput = {
    username?: SortOrder
    password?: SortOrder
  }

  export type MemberCredentialsMaxOrderByAggregateInput = {
    username?: SortOrder
    password?: SortOrder
  }

  export type MemberCredentialsMinOrderByAggregateInput = {
    username?: SortOrder
    password?: SortOrder
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type EnumMessageTypeFilter = {
    equals?: MessageType
    in?: Enumerable<MessageType>
    notIn?: Enumerable<MessageType>
    not?: NestedEnumMessageTypeFilter | MessageType
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    isRead?: SortOrder
    messageType?: SortOrder
  }

  export type MessageAvgOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    isRead?: SortOrder
    messageType?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    isRead?: SortOrder
    messageType?: SortOrder
  }

  export type MessageSumOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type EnumMessageTypeWithAggregatesFilter = {
    equals?: MessageType
    in?: Enumerable<MessageType>
    notIn?: Enumerable<MessageType>
    not?: NestedEnumMessageTypeWithAggregatesFilter | MessageType
    _count?: NestedIntFilter
    _min?: NestedEnumMessageTypeFilter
    _max?: NestedEnumMessageTypeFilter
  }

  export type MessageRelationFilter = {
    is?: MessageWhereInput
    isNot?: MessageWhereInput
  }

  export type MessageRecipientsMessageIdUsernameCompoundUniqueInput = {
    messageId: number
    username: string
  }

  export type MessageRecipientsCountOrderByAggregateInput = {
    messageId?: SortOrder
    username?: SortOrder
  }

  export type MessageRecipientsAvgOrderByAggregateInput = {
    messageId?: SortOrder
  }

  export type MessageRecipientsMaxOrderByAggregateInput = {
    messageId?: SortOrder
    username?: SortOrder
  }

  export type MessageRecipientsMinOrderByAggregateInput = {
    messageId?: SortOrder
    username?: SortOrder
  }

  export type MessageRecipientsSumOrderByAggregateInput = {
    messageId?: SortOrder
  }

  export type EnumDiscountKindsFilter = {
    equals?: DiscountKinds
    in?: Enumerable<DiscountKinds>
    notIn?: Enumerable<DiscountKinds>
    not?: NestedEnumDiscountKindsFilter | DiscountKinds
  }

  export type SimpleDiscountRelationFilter = {
    is?: SimpleDiscountWhereInput
    isNot?: SimpleDiscountWhereInput
  }

  export type ConditionalDiscountRelationFilter = {
    is?: ConditionalDiscountWhereInput
    isNot?: ConditionalDiscountWhereInput
  }

  export type DiscountContainerRelationFilter = {
    is?: DiscountContainerWhereInput
    isNot?: DiscountContainerWhereInput
  }

  export type DiscountInContainerRelationFilter = {
    is?: DiscountInContainerWhereInput | null
    isNot?: DiscountInContainerWhereInput | null
  }

  export type DiscountIdShopIdCompoundUniqueInput = {
    id: number
    shopId: number
  }

  export type DiscountCountOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    kind?: SortOrder
  }

  export type DiscountAvgOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
  }

  export type DiscountMaxOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    kind?: SortOrder
  }

  export type DiscountMinOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    kind?: SortOrder
  }

  export type DiscountSumOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
  }

  export type EnumDiscountKindsWithAggregatesFilter = {
    equals?: DiscountKinds
    in?: Enumerable<DiscountKinds>
    notIn?: Enumerable<DiscountKinds>
    not?: NestedEnumDiscountKindsWithAggregatesFilter | DiscountKinds
    _count?: NestedIntFilter
    _min?: NestedEnumDiscountKindsFilter
    _max?: NestedEnumDiscountKindsFilter
  }

  export type DiscountRelationFilter = {
    is?: DiscountWhereInput
    isNot?: DiscountWhereInput
  }

  export type EnumDiscountTypeFilter = {
    equals?: DiscountType
    in?: Enumerable<DiscountType>
    notIn?: Enumerable<DiscountType>
    not?: NestedEnumDiscountTypeFilter | DiscountType
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type EnumProductCategoryNullableFilter = {
    equals?: ProductCategory | null
    in?: Enumerable<ProductCategory> | null
    notIn?: Enumerable<ProductCategory> | null
    not?: NestedEnumProductCategoryNullableFilter | ProductCategory | null
  }

  export type SimpleDiscountIdShopIdCompoundUniqueInput = {
    id: number
    shopId: number
  }

  export type SimpleDiscountCountOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    discountType?: SortOrder
    discountPercent?: SortOrder
    description?: SortOrder
    productId?: SortOrder
    category?: SortOrder
  }

  export type SimpleDiscountAvgOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    discountPercent?: SortOrder
    productId?: SortOrder
  }

  export type SimpleDiscountMaxOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    discountType?: SortOrder
    discountPercent?: SortOrder
    description?: SortOrder
    productId?: SortOrder
    category?: SortOrder
  }

  export type SimpleDiscountMinOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    discountType?: SortOrder
    discountPercent?: SortOrder
    description?: SortOrder
    productId?: SortOrder
    category?: SortOrder
  }

  export type SimpleDiscountSumOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    discountPercent?: SortOrder
    productId?: SortOrder
  }

  export type EnumDiscountTypeWithAggregatesFilter = {
    equals?: DiscountType
    in?: Enumerable<DiscountType>
    notIn?: Enumerable<DiscountType>
    not?: NestedEnumDiscountTypeWithAggregatesFilter | DiscountType
    _count?: NestedIntFilter
    _min?: NestedEnumDiscountTypeFilter
    _max?: NestedEnumDiscountTypeFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type EnumProductCategoryNullableWithAggregatesFilter = {
    equals?: ProductCategory | null
    in?: Enumerable<ProductCategory> | null
    notIn?: Enumerable<ProductCategory> | null
    not?: NestedEnumProductCategoryNullableWithAggregatesFilter | ProductCategory | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumProductCategoryNullableFilter
    _max?: NestedEnumProductCategoryNullableFilter
  }

  export type DiscountPredicateRelationFilter = {
    is?: DiscountPredicateWhereInput | null
    isNot?: DiscountPredicateWhereInput | null
  }

  export type ConditionalDiscountSimpleIdSimpleShopIdCompoundUniqueInput = {
    simpleId: number
    simpleShopId: number
  }

  export type ConditionalDiscountIdShopIdCompoundUniqueInput = {
    id: number
    shopId: number
  }

  export type ConditionalDiscountCountOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    simpleId?: SortOrder
    simpleShopId?: SortOrder
  }

  export type ConditionalDiscountAvgOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    simpleId?: SortOrder
    simpleShopId?: SortOrder
  }

  export type ConditionalDiscountMaxOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    simpleId?: SortOrder
    simpleShopId?: SortOrder
  }

  export type ConditionalDiscountMinOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    simpleId?: SortOrder
    simpleShopId?: SortOrder
  }

  export type ConditionalDiscountSumOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    simpleId?: SortOrder
    simpleShopId?: SortOrder
  }

  export type EnumRelationTypeFilter = {
    equals?: RelationType
    in?: Enumerable<RelationType>
    notIn?: Enumerable<RelationType>
    not?: NestedEnumRelationTypeFilter | RelationType
  }

  export type DiscountPredicateDiscountIdShopIdCompoundUniqueInput = {
    discountId: number
    shopId: number
  }

  export type DiscountPredicateCountOrderByAggregateInput = {
    discountId?: SortOrder
    shopId?: SortOrder
    discountType?: SortOrder
    relation?: SortOrder
    value?: SortOrder
    description?: SortOrder
    productId?: SortOrder
    category?: SortOrder
  }

  export type DiscountPredicateAvgOrderByAggregateInput = {
    discountId?: SortOrder
    shopId?: SortOrder
    value?: SortOrder
    productId?: SortOrder
  }

  export type DiscountPredicateMaxOrderByAggregateInput = {
    discountId?: SortOrder
    shopId?: SortOrder
    discountType?: SortOrder
    relation?: SortOrder
    value?: SortOrder
    description?: SortOrder
    productId?: SortOrder
    category?: SortOrder
  }

  export type DiscountPredicateMinOrderByAggregateInput = {
    discountId?: SortOrder
    shopId?: SortOrder
    discountType?: SortOrder
    relation?: SortOrder
    value?: SortOrder
    description?: SortOrder
    productId?: SortOrder
    category?: SortOrder
  }

  export type DiscountPredicateSumOrderByAggregateInput = {
    discountId?: SortOrder
    shopId?: SortOrder
    value?: SortOrder
    productId?: SortOrder
  }

  export type EnumRelationTypeWithAggregatesFilter = {
    equals?: RelationType
    in?: Enumerable<RelationType>
    notIn?: Enumerable<RelationType>
    not?: NestedEnumRelationTypeWithAggregatesFilter | RelationType
    _count?: NestedIntFilter
    _min?: NestedEnumRelationTypeFilter
    _max?: NestedEnumRelationTypeFilter
  }

  export type EnumDiscountRelationFilter = {
    equals?: DiscountRelation
    in?: Enumerable<DiscountRelation>
    notIn?: Enumerable<DiscountRelation>
    not?: NestedEnumDiscountRelationFilter | DiscountRelation
  }

  export type DiscountInContainerListRelationFilter = {
    every?: DiscountInContainerWhereInput
    some?: DiscountInContainerWhereInput
    none?: DiscountInContainerWhereInput
  }

  export type DiscountInContainerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DiscountContainerIdShopIdCompoundUniqueInput = {
    id: number
    shopId: number
  }

  export type DiscountContainerCountOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    description?: SortOrder
    type?: SortOrder
  }

  export type DiscountContainerAvgOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
  }

  export type DiscountContainerMaxOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    description?: SortOrder
    type?: SortOrder
  }

  export type DiscountContainerMinOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    description?: SortOrder
    type?: SortOrder
  }

  export type DiscountContainerSumOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
  }

  export type EnumDiscountRelationWithAggregatesFilter = {
    equals?: DiscountRelation
    in?: Enumerable<DiscountRelation>
    notIn?: Enumerable<DiscountRelation>
    not?: NestedEnumDiscountRelationWithAggregatesFilter | DiscountRelation
    _count?: NestedIntFilter
    _min?: NestedEnumDiscountRelationFilter
    _max?: NestedEnumDiscountRelationFilter
  }

  export type DiscountInContainerContainedDiscountShopIdCompoundUniqueInput = {
    containedDiscount: number
    shopId: number
  }

  export type DiscountInContainerContainedDiscountContainingDiscountShopIdCompoundUniqueInput = {
    containedDiscount: number
    containingDiscount: number
    shopId: number
  }

  export type DiscountInContainerCountOrderByAggregateInput = {
    containedDiscount?: SortOrder
    shopId?: SortOrder
    containingDiscount?: SortOrder
  }

  export type DiscountInContainerAvgOrderByAggregateInput = {
    containedDiscount?: SortOrder
    shopId?: SortOrder
    containingDiscount?: SortOrder
  }

  export type DiscountInContainerMaxOrderByAggregateInput = {
    containedDiscount?: SortOrder
    shopId?: SortOrder
    containingDiscount?: SortOrder
  }

  export type DiscountInContainerMinOrderByAggregateInput = {
    containedDiscount?: SortOrder
    shopId?: SortOrder
    containingDiscount?: SortOrder
  }

  export type DiscountInContainerSumOrderByAggregateInput = {
    containedDiscount?: SortOrder
    shopId?: SortOrder
    containingDiscount?: SortOrder
  }

  export type SimplePolicyRelationFilter = {
    is?: SimplePolicyWhereInput | null
    isNot?: SimplePolicyWhereInput | null
  }

  export type ConditionalPolicyRelationFilter = {
    is?: ConditionalPolicyWhereInput
    isNot?: ConditionalPolicyWhereInput
  }

  export type LogicalPolicyRelationFilter = {
    is?: LogicalPolicyWhereInput
    isNot?: LogicalPolicyWhereInput
  }

  export type PolicyInContainerRelationFilter = {
    is?: PolicyInContainerWhereInput | null
    isNot?: PolicyInContainerWhereInput | null
  }

  export type PolicyIdShopIdCompoundUniqueInput = {
    id: number
    shopId: number
  }

  export type PolicyCountOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
  }

  export type PolicyAvgOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
  }

  export type PolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
  }

  export type PolicyMinOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
  }

  export type PolicySumOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
  }

  export type PolicyRelationFilter = {
    is?: PolicyWhereInput
    isNot?: PolicyWhereInput
  }

  export type SimplePolicyIdShopIdCompoundUniqueInput = {
    id: number
    shopId: number
  }

  export type SimplePolicyCountOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    okay?: SortOrder
    message?: SortOrder
  }

  export type SimplePolicyAvgOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
  }

  export type SimplePolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    okay?: SortOrder
    message?: SortOrder
  }

  export type SimplePolicyMinOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    okay?: SortOrder
    message?: SortOrder
  }

  export type SimplePolicySumOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
  }

  export type PolicyPredicateRelationFilter = {
    is?: PolicyPredicateWhereInput | null
    isNot?: PolicyPredicateWhereInput | null
  }

  export type ConditionalPolicyIdShopIdCompoundUniqueInput = {
    id: number
    shopId: number
  }

  export type ConditionalPolicyCountOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    dependent?: SortOrder
    dependentShopId?: SortOrder
    dependentOn?: SortOrder
    dependentOnShopId?: SortOrder
    description?: SortOrder
  }

  export type ConditionalPolicyAvgOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    dependent?: SortOrder
    dependentShopId?: SortOrder
    dependentOn?: SortOrder
    dependentOnShopId?: SortOrder
  }

  export type ConditionalPolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    dependent?: SortOrder
    dependentShopId?: SortOrder
    dependentOn?: SortOrder
    dependentOnShopId?: SortOrder
    description?: SortOrder
  }

  export type ConditionalPolicyMinOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    dependent?: SortOrder
    dependentShopId?: SortOrder
    dependentOn?: SortOrder
    dependentOnShopId?: SortOrder
    description?: SortOrder
  }

  export type ConditionalPolicySumOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    dependent?: SortOrder
    dependentShopId?: SortOrder
    dependentOn?: SortOrder
    dependentOnShopId?: SortOrder
  }

  export type EnumSimplePolicyTypeFilter = {
    equals?: SimplePolicyType
    in?: Enumerable<SimplePolicyType>
    notIn?: Enumerable<SimplePolicyType>
    not?: NestedEnumSimplePolicyTypeFilter | SimplePolicyType
  }

  export type PolicyPredicatePolicyIdShopIdCompoundUniqueInput = {
    policyId: number
    shopId: number
  }

  export type PolicyPredicateCountOrderByAggregateInput = {
    policyId?: SortOrder
    shopId?: SortOrder
    policyType?: SortOrder
    relation?: SortOrder
    value?: SortOrder
    description?: SortOrder
    productId?: SortOrder
    productCategory?: SortOrder
    guest?: SortOrder
  }

  export type PolicyPredicateAvgOrderByAggregateInput = {
    policyId?: SortOrder
    shopId?: SortOrder
    value?: SortOrder
    productId?: SortOrder
  }

  export type PolicyPredicateMaxOrderByAggregateInput = {
    policyId?: SortOrder
    shopId?: SortOrder
    policyType?: SortOrder
    relation?: SortOrder
    value?: SortOrder
    description?: SortOrder
    productId?: SortOrder
    productCategory?: SortOrder
    guest?: SortOrder
  }

  export type PolicyPredicateMinOrderByAggregateInput = {
    policyId?: SortOrder
    shopId?: SortOrder
    policyType?: SortOrder
    relation?: SortOrder
    value?: SortOrder
    description?: SortOrder
    productId?: SortOrder
    productCategory?: SortOrder
    guest?: SortOrder
  }

  export type PolicyPredicateSumOrderByAggregateInput = {
    policyId?: SortOrder
    shopId?: SortOrder
    value?: SortOrder
    productId?: SortOrder
  }

  export type EnumSimplePolicyTypeWithAggregatesFilter = {
    equals?: SimplePolicyType
    in?: Enumerable<SimplePolicyType>
    notIn?: Enumerable<SimplePolicyType>
    not?: NestedEnumSimplePolicyTypeWithAggregatesFilter | SimplePolicyType
    _count?: NestedIntFilter
    _min?: NestedEnumSimplePolicyTypeFilter
    _max?: NestedEnumSimplePolicyTypeFilter
  }

  export type EnumPurchasePoliciesRelationFilter = {
    equals?: PurchasePoliciesRelation
    in?: Enumerable<PurchasePoliciesRelation>
    notIn?: Enumerable<PurchasePoliciesRelation>
    not?: NestedEnumPurchasePoliciesRelationFilter | PurchasePoliciesRelation
  }

  export type PolicyInContainerListRelationFilter = {
    every?: PolicyInContainerWhereInput
    some?: PolicyInContainerWhereInput
    none?: PolicyInContainerWhereInput
  }

  export type PolicyInContainerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LogicalPolicyIdShopIdCompoundUniqueInput = {
    id: number
    shopId: number
  }

  export type LogicalPolicyCountOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    description?: SortOrder
    purchasePoliciesRelation?: SortOrder
  }

  export type LogicalPolicyAvgOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
  }

  export type LogicalPolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    description?: SortOrder
    purchasePoliciesRelation?: SortOrder
  }

  export type LogicalPolicyMinOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    description?: SortOrder
    purchasePoliciesRelation?: SortOrder
  }

  export type LogicalPolicySumOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
  }

  export type EnumPurchasePoliciesRelationWithAggregatesFilter = {
    equals?: PurchasePoliciesRelation
    in?: Enumerable<PurchasePoliciesRelation>
    notIn?: Enumerable<PurchasePoliciesRelation>
    not?: NestedEnumPurchasePoliciesRelationWithAggregatesFilter | PurchasePoliciesRelation
    _count?: NestedIntFilter
    _min?: NestedEnumPurchasePoliciesRelationFilter
    _max?: NestedEnumPurchasePoliciesRelationFilter
  }

  export type PolicyInContainerContainedPolicyShopIdCompoundUniqueInput = {
    containedPolicy: number
    shopId: number
  }

  export type PolicyInContainerContainedPolicyContainingPolicyShopIdCompoundUniqueInput = {
    containedPolicy: number
    containingPolicy: number
    shopId: number
  }

  export type PolicyInContainerCountOrderByAggregateInput = {
    containedPolicy?: SortOrder
    shopId?: SortOrder
    containingPolicy?: SortOrder
  }

  export type PolicyInContainerAvgOrderByAggregateInput = {
    containedPolicy?: SortOrder
    shopId?: SortOrder
    containingPolicy?: SortOrder
  }

  export type PolicyInContainerMaxOrderByAggregateInput = {
    containedPolicy?: SortOrder
    shopId?: SortOrder
    containingPolicy?: SortOrder
  }

  export type PolicyInContainerMinOrderByAggregateInput = {
    containedPolicy?: SortOrder
    shopId?: SortOrder
    containingPolicy?: SortOrder
  }

  export type PolicyInContainerSumOrderByAggregateInput = {
    containedPolicy?: SortOrder
    shopId?: SortOrder
    containingPolicy?: SortOrder
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type OfferCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    shopId?: SortOrder
    productId?: SortOrder
    price?: SortOrder
  }

  export type OfferAvgOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    productId?: SortOrder
    price?: SortOrder
  }

  export type OfferMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    shopId?: SortOrder
    productId?: SortOrder
    price?: SortOrder
  }

  export type OfferMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    shopId?: SortOrder
    productId?: SortOrder
    price?: SortOrder
  }

  export type OfferSumOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    productId?: SortOrder
    price?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type OfferRelationFilter = {
    is?: OfferWhereInput
    isNot?: OfferWhereInput
  }

  export type OfferApproverCountOrderByAggregateInput = {
    username?: SortOrder
    offerId?: SortOrder
    answered?: SortOrder
    approved?: SortOrder
  }

  export type OfferApproverAvgOrderByAggregateInput = {
    offerId?: SortOrder
  }

  export type OfferApproverMaxOrderByAggregateInput = {
    username?: SortOrder
    offerId?: SortOrder
    answered?: SortOrder
    approved?: SortOrder
  }

  export type OfferApproverMinOrderByAggregateInput = {
    username?: SortOrder
    offerId?: SortOrder
    answered?: SortOrder
    approved?: SortOrder
  }

  export type OfferApproverSumOrderByAggregateInput = {
    offerId?: SortOrder
  }

  export type AppointmentAgreementListRelationFilter = {
    every?: AppointmentAgreementWhereInput
    some?: AppointmentAgreementWhereInput
    none?: AppointmentAgreementWhereInput
  }

  export type AppointmentAgreementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppointmentUsernameShopIdCompoundUniqueInput = {
    username: string
    shopId: number
  }

  export type AppointmentCountOrderByAggregateInput = {
    username?: SortOrder
    shopId?: SortOrder
    assigner?: SortOrder
  }

  export type AppointmentAvgOrderByAggregateInput = {
    shopId?: SortOrder
  }

  export type AppointmentMaxOrderByAggregateInput = {
    username?: SortOrder
    shopId?: SortOrder
    assigner?: SortOrder
  }

  export type AppointmentMinOrderByAggregateInput = {
    username?: SortOrder
    shopId?: SortOrder
    assigner?: SortOrder
  }

  export type AppointmentSumOrderByAggregateInput = {
    shopId?: SortOrder
  }

  export type AppointmentRelationFilter = {
    is?: AppointmentWhereInput
    isNot?: AppointmentWhereInput
  }

  export type AppointmentAgreementUsernameShopIdCompoundUniqueInput = {
    username: string
    shopId: number
  }

  export type AppointmentAgreementCountOrderByAggregateInput = {
    username?: SortOrder
    shopId?: SortOrder
    approver?: SortOrder
    answered?: SortOrder
    approved?: SortOrder
  }

  export type AppointmentAgreementAvgOrderByAggregateInput = {
    shopId?: SortOrder
  }

  export type AppointmentAgreementMaxOrderByAggregateInput = {
    username?: SortOrder
    shopId?: SortOrder
    approver?: SortOrder
    answered?: SortOrder
    approved?: SortOrder
  }

  export type AppointmentAgreementMinOrderByAggregateInput = {
    username?: SortOrder
    shopId?: SortOrder
    approver?: SortOrder
    answered?: SortOrder
    approved?: SortOrder
  }

  export type AppointmentAgreementSumOrderByAggregateInput = {
    shopId?: SortOrder
  }

  export type RoleCreateNestedManyWithoutMemberInput = {
    create?: XOR<Enumerable<RoleCreateWithoutMemberInput>, Enumerable<RoleUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutMemberInput>
    createMany?: RoleCreateManyMemberInputEnvelope
    connect?: Enumerable<RoleWhereUniqueInput>
  }

  export type ShopCreateNestedManyWithoutMemberInput = {
    create?: XOR<Enumerable<ShopCreateWithoutMemberInput>, Enumerable<ShopUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<ShopCreateOrConnectWithoutMemberInput>
    createMany?: ShopCreateManyMemberInputEnvelope
    connect?: Enumerable<ShopWhereUniqueInput>
  }

  export type ShoppingCartCreateNestedOneWithoutMemberInput = {
    create?: XOR<ShoppingCartCreateWithoutMemberInput, ShoppingCartUncheckedCreateWithoutMemberInput>
    connectOrCreate?: ShoppingCartCreateOrConnectWithoutMemberInput
    connect?: ShoppingCartWhereUniqueInput
  }

  export type MemberCredentialsCreateNestedOneWithoutMemberInput = {
    create?: XOR<MemberCredentialsCreateWithoutMemberInput, MemberCredentialsUncheckedCreateWithoutMemberInput>
    connectOrCreate?: MemberCredentialsCreateOrConnectWithoutMemberInput
    connect?: MemberCredentialsWhereUniqueInput
  }

  export type OfferCreateNestedManyWithoutMemberInput = {
    create?: XOR<Enumerable<OfferCreateWithoutMemberInput>, Enumerable<OfferUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<OfferCreateOrConnectWithoutMemberInput>
    createMany?: OfferCreateManyMemberInputEnvelope
    connect?: Enumerable<OfferWhereUniqueInput>
  }

  export type OfferApproverCreateNestedManyWithoutMemberInput = {
    create?: XOR<Enumerable<OfferApproverCreateWithoutMemberInput>, Enumerable<OfferApproverUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<OfferApproverCreateOrConnectWithoutMemberInput>
    createMany?: OfferApproverCreateManyMemberInputEnvelope
    connect?: Enumerable<OfferApproverWhereUniqueInput>
  }

  export type AppointmentCreateNestedManyWithoutMemberInput = {
    create?: XOR<Enumerable<AppointmentCreateWithoutMemberInput>, Enumerable<AppointmentUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<AppointmentCreateOrConnectWithoutMemberInput>
    createMany?: AppointmentCreateManyMemberInputEnvelope
    connect?: Enumerable<AppointmentWhereUniqueInput>
  }

  export type MessageRecipientsCreateNestedManyWithoutMemberInput = {
    create?: XOR<Enumerable<MessageRecipientsCreateWithoutMemberInput>, Enumerable<MessageRecipientsUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<MessageRecipientsCreateOrConnectWithoutMemberInput>
    createMany?: MessageRecipientsCreateManyMemberInputEnvelope
    connect?: Enumerable<MessageRecipientsWhereUniqueInput>
  }

  export type RoleUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<Enumerable<RoleCreateWithoutMemberInput>, Enumerable<RoleUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutMemberInput>
    createMany?: RoleCreateManyMemberInputEnvelope
    connect?: Enumerable<RoleWhereUniqueInput>
  }

  export type ShopUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<Enumerable<ShopCreateWithoutMemberInput>, Enumerable<ShopUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<ShopCreateOrConnectWithoutMemberInput>
    createMany?: ShopCreateManyMemberInputEnvelope
    connect?: Enumerable<ShopWhereUniqueInput>
  }

  export type ShoppingCartUncheckedCreateNestedOneWithoutMemberInput = {
    create?: XOR<ShoppingCartCreateWithoutMemberInput, ShoppingCartUncheckedCreateWithoutMemberInput>
    connectOrCreate?: ShoppingCartCreateOrConnectWithoutMemberInput
    connect?: ShoppingCartWhereUniqueInput
  }

  export type MemberCredentialsUncheckedCreateNestedOneWithoutMemberInput = {
    create?: XOR<MemberCredentialsCreateWithoutMemberInput, MemberCredentialsUncheckedCreateWithoutMemberInput>
    connectOrCreate?: MemberCredentialsCreateOrConnectWithoutMemberInput
    connect?: MemberCredentialsWhereUniqueInput
  }

  export type OfferUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<Enumerable<OfferCreateWithoutMemberInput>, Enumerable<OfferUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<OfferCreateOrConnectWithoutMemberInput>
    createMany?: OfferCreateManyMemberInputEnvelope
    connect?: Enumerable<OfferWhereUniqueInput>
  }

  export type OfferApproverUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<Enumerable<OfferApproverCreateWithoutMemberInput>, Enumerable<OfferApproverUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<OfferApproverCreateOrConnectWithoutMemberInput>
    createMany?: OfferApproverCreateManyMemberInputEnvelope
    connect?: Enumerable<OfferApproverWhereUniqueInput>
  }

  export type AppointmentUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<Enumerable<AppointmentCreateWithoutMemberInput>, Enumerable<AppointmentUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<AppointmentCreateOrConnectWithoutMemberInput>
    createMany?: AppointmentCreateManyMemberInputEnvelope
    connect?: Enumerable<AppointmentWhereUniqueInput>
  }

  export type MessageRecipientsUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<Enumerable<MessageRecipientsCreateWithoutMemberInput>, Enumerable<MessageRecipientsUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<MessageRecipientsCreateOrConnectWithoutMemberInput>
    createMany?: MessageRecipientsCreateManyMemberInputEnvelope
    connect?: Enumerable<MessageRecipientsWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type RoleUpdateManyWithoutMemberInput = {
    create?: XOR<Enumerable<RoleCreateWithoutMemberInput>, Enumerable<RoleUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutMemberInput>
    upsert?: Enumerable<RoleUpsertWithWhereUniqueWithoutMemberInput>
    createMany?: RoleCreateManyMemberInputEnvelope
    set?: Enumerable<RoleWhereUniqueInput>
    disconnect?: Enumerable<RoleWhereUniqueInput>
    delete?: Enumerable<RoleWhereUniqueInput>
    connect?: Enumerable<RoleWhereUniqueInput>
    update?: Enumerable<RoleUpdateWithWhereUniqueWithoutMemberInput>
    updateMany?: Enumerable<RoleUpdateManyWithWhereWithoutMemberInput>
    deleteMany?: Enumerable<RoleScalarWhereInput>
  }

  export type ShopUpdateManyWithoutMemberInput = {
    create?: XOR<Enumerable<ShopCreateWithoutMemberInput>, Enumerable<ShopUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<ShopCreateOrConnectWithoutMemberInput>
    upsert?: Enumerable<ShopUpsertWithWhereUniqueWithoutMemberInput>
    createMany?: ShopCreateManyMemberInputEnvelope
    set?: Enumerable<ShopWhereUniqueInput>
    disconnect?: Enumerable<ShopWhereUniqueInput>
    delete?: Enumerable<ShopWhereUniqueInput>
    connect?: Enumerable<ShopWhereUniqueInput>
    update?: Enumerable<ShopUpdateWithWhereUniqueWithoutMemberInput>
    updateMany?: Enumerable<ShopUpdateManyWithWhereWithoutMemberInput>
    deleteMany?: Enumerable<ShopScalarWhereInput>
  }

  export type ShoppingCartUpdateOneWithoutMemberInput = {
    create?: XOR<ShoppingCartCreateWithoutMemberInput, ShoppingCartUncheckedCreateWithoutMemberInput>
    connectOrCreate?: ShoppingCartCreateOrConnectWithoutMemberInput
    upsert?: ShoppingCartUpsertWithoutMemberInput
    disconnect?: boolean
    delete?: boolean
    connect?: ShoppingCartWhereUniqueInput
    update?: XOR<ShoppingCartUpdateWithoutMemberInput, ShoppingCartUncheckedUpdateWithoutMemberInput>
  }

  export type MemberCredentialsUpdateOneWithoutMemberInput = {
    create?: XOR<MemberCredentialsCreateWithoutMemberInput, MemberCredentialsUncheckedCreateWithoutMemberInput>
    connectOrCreate?: MemberCredentialsCreateOrConnectWithoutMemberInput
    upsert?: MemberCredentialsUpsertWithoutMemberInput
    disconnect?: boolean
    delete?: boolean
    connect?: MemberCredentialsWhereUniqueInput
    update?: XOR<MemberCredentialsUpdateWithoutMemberInput, MemberCredentialsUncheckedUpdateWithoutMemberInput>
  }

  export type OfferUpdateManyWithoutMemberInput = {
    create?: XOR<Enumerable<OfferCreateWithoutMemberInput>, Enumerable<OfferUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<OfferCreateOrConnectWithoutMemberInput>
    upsert?: Enumerable<OfferUpsertWithWhereUniqueWithoutMemberInput>
    createMany?: OfferCreateManyMemberInputEnvelope
    set?: Enumerable<OfferWhereUniqueInput>
    disconnect?: Enumerable<OfferWhereUniqueInput>
    delete?: Enumerable<OfferWhereUniqueInput>
    connect?: Enumerable<OfferWhereUniqueInput>
    update?: Enumerable<OfferUpdateWithWhereUniqueWithoutMemberInput>
    updateMany?: Enumerable<OfferUpdateManyWithWhereWithoutMemberInput>
    deleteMany?: Enumerable<OfferScalarWhereInput>
  }

  export type OfferApproverUpdateManyWithoutMemberInput = {
    create?: XOR<Enumerable<OfferApproverCreateWithoutMemberInput>, Enumerable<OfferApproverUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<OfferApproverCreateOrConnectWithoutMemberInput>
    upsert?: Enumerable<OfferApproverUpsertWithWhereUniqueWithoutMemberInput>
    createMany?: OfferApproverCreateManyMemberInputEnvelope
    set?: Enumerable<OfferApproverWhereUniqueInput>
    disconnect?: Enumerable<OfferApproverWhereUniqueInput>
    delete?: Enumerable<OfferApproverWhereUniqueInput>
    connect?: Enumerable<OfferApproverWhereUniqueInput>
    update?: Enumerable<OfferApproverUpdateWithWhereUniqueWithoutMemberInput>
    updateMany?: Enumerable<OfferApproverUpdateManyWithWhereWithoutMemberInput>
    deleteMany?: Enumerable<OfferApproverScalarWhereInput>
  }

  export type AppointmentUpdateManyWithoutMemberInput = {
    create?: XOR<Enumerable<AppointmentCreateWithoutMemberInput>, Enumerable<AppointmentUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<AppointmentCreateOrConnectWithoutMemberInput>
    upsert?: Enumerable<AppointmentUpsertWithWhereUniqueWithoutMemberInput>
    createMany?: AppointmentCreateManyMemberInputEnvelope
    set?: Enumerable<AppointmentWhereUniqueInput>
    disconnect?: Enumerable<AppointmentWhereUniqueInput>
    delete?: Enumerable<AppointmentWhereUniqueInput>
    connect?: Enumerable<AppointmentWhereUniqueInput>
    update?: Enumerable<AppointmentUpdateWithWhereUniqueWithoutMemberInput>
    updateMany?: Enumerable<AppointmentUpdateManyWithWhereWithoutMemberInput>
    deleteMany?: Enumerable<AppointmentScalarWhereInput>
  }

  export type MessageRecipientsUpdateManyWithoutMemberInput = {
    create?: XOR<Enumerable<MessageRecipientsCreateWithoutMemberInput>, Enumerable<MessageRecipientsUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<MessageRecipientsCreateOrConnectWithoutMemberInput>
    upsert?: Enumerable<MessageRecipientsUpsertWithWhereUniqueWithoutMemberInput>
    createMany?: MessageRecipientsCreateManyMemberInputEnvelope
    set?: Enumerable<MessageRecipientsWhereUniqueInput>
    disconnect?: Enumerable<MessageRecipientsWhereUniqueInput>
    delete?: Enumerable<MessageRecipientsWhereUniqueInput>
    connect?: Enumerable<MessageRecipientsWhereUniqueInput>
    update?: Enumerable<MessageRecipientsUpdateWithWhereUniqueWithoutMemberInput>
    updateMany?: Enumerable<MessageRecipientsUpdateManyWithWhereWithoutMemberInput>
    deleteMany?: Enumerable<MessageRecipientsScalarWhereInput>
  }

  export type RoleUncheckedUpdateManyWithoutMemberInput = {
    create?: XOR<Enumerable<RoleCreateWithoutMemberInput>, Enumerable<RoleUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutMemberInput>
    upsert?: Enumerable<RoleUpsertWithWhereUniqueWithoutMemberInput>
    createMany?: RoleCreateManyMemberInputEnvelope
    set?: Enumerable<RoleWhereUniqueInput>
    disconnect?: Enumerable<RoleWhereUniqueInput>
    delete?: Enumerable<RoleWhereUniqueInput>
    connect?: Enumerable<RoleWhereUniqueInput>
    update?: Enumerable<RoleUpdateWithWhereUniqueWithoutMemberInput>
    updateMany?: Enumerable<RoleUpdateManyWithWhereWithoutMemberInput>
    deleteMany?: Enumerable<RoleScalarWhereInput>
  }

  export type ShopUncheckedUpdateManyWithoutMemberInput = {
    create?: XOR<Enumerable<ShopCreateWithoutMemberInput>, Enumerable<ShopUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<ShopCreateOrConnectWithoutMemberInput>
    upsert?: Enumerable<ShopUpsertWithWhereUniqueWithoutMemberInput>
    createMany?: ShopCreateManyMemberInputEnvelope
    set?: Enumerable<ShopWhereUniqueInput>
    disconnect?: Enumerable<ShopWhereUniqueInput>
    delete?: Enumerable<ShopWhereUniqueInput>
    connect?: Enumerable<ShopWhereUniqueInput>
    update?: Enumerable<ShopUpdateWithWhereUniqueWithoutMemberInput>
    updateMany?: Enumerable<ShopUpdateManyWithWhereWithoutMemberInput>
    deleteMany?: Enumerable<ShopScalarWhereInput>
  }

  export type ShoppingCartUncheckedUpdateOneWithoutMemberInput = {
    create?: XOR<ShoppingCartCreateWithoutMemberInput, ShoppingCartUncheckedCreateWithoutMemberInput>
    connectOrCreate?: ShoppingCartCreateOrConnectWithoutMemberInput
    upsert?: ShoppingCartUpsertWithoutMemberInput
    disconnect?: boolean
    delete?: boolean
    connect?: ShoppingCartWhereUniqueInput
    update?: XOR<ShoppingCartUpdateWithoutMemberInput, ShoppingCartUncheckedUpdateWithoutMemberInput>
  }

  export type MemberCredentialsUncheckedUpdateOneWithoutMemberInput = {
    create?: XOR<MemberCredentialsCreateWithoutMemberInput, MemberCredentialsUncheckedCreateWithoutMemberInput>
    connectOrCreate?: MemberCredentialsCreateOrConnectWithoutMemberInput
    upsert?: MemberCredentialsUpsertWithoutMemberInput
    disconnect?: boolean
    delete?: boolean
    connect?: MemberCredentialsWhereUniqueInput
    update?: XOR<MemberCredentialsUpdateWithoutMemberInput, MemberCredentialsUncheckedUpdateWithoutMemberInput>
  }

  export type OfferUncheckedUpdateManyWithoutMemberInput = {
    create?: XOR<Enumerable<OfferCreateWithoutMemberInput>, Enumerable<OfferUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<OfferCreateOrConnectWithoutMemberInput>
    upsert?: Enumerable<OfferUpsertWithWhereUniqueWithoutMemberInput>
    createMany?: OfferCreateManyMemberInputEnvelope
    set?: Enumerable<OfferWhereUniqueInput>
    disconnect?: Enumerable<OfferWhereUniqueInput>
    delete?: Enumerable<OfferWhereUniqueInput>
    connect?: Enumerable<OfferWhereUniqueInput>
    update?: Enumerable<OfferUpdateWithWhereUniqueWithoutMemberInput>
    updateMany?: Enumerable<OfferUpdateManyWithWhereWithoutMemberInput>
    deleteMany?: Enumerable<OfferScalarWhereInput>
  }

  export type OfferApproverUncheckedUpdateManyWithoutMemberInput = {
    create?: XOR<Enumerable<OfferApproverCreateWithoutMemberInput>, Enumerable<OfferApproverUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<OfferApproverCreateOrConnectWithoutMemberInput>
    upsert?: Enumerable<OfferApproverUpsertWithWhereUniqueWithoutMemberInput>
    createMany?: OfferApproverCreateManyMemberInputEnvelope
    set?: Enumerable<OfferApproverWhereUniqueInput>
    disconnect?: Enumerable<OfferApproverWhereUniqueInput>
    delete?: Enumerable<OfferApproverWhereUniqueInput>
    connect?: Enumerable<OfferApproverWhereUniqueInput>
    update?: Enumerable<OfferApproverUpdateWithWhereUniqueWithoutMemberInput>
    updateMany?: Enumerable<OfferApproverUpdateManyWithWhereWithoutMemberInput>
    deleteMany?: Enumerable<OfferApproverScalarWhereInput>
  }

  export type AppointmentUncheckedUpdateManyWithoutMemberInput = {
    create?: XOR<Enumerable<AppointmentCreateWithoutMemberInput>, Enumerable<AppointmentUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<AppointmentCreateOrConnectWithoutMemberInput>
    upsert?: Enumerable<AppointmentUpsertWithWhereUniqueWithoutMemberInput>
    createMany?: AppointmentCreateManyMemberInputEnvelope
    set?: Enumerable<AppointmentWhereUniqueInput>
    disconnect?: Enumerable<AppointmentWhereUniqueInput>
    delete?: Enumerable<AppointmentWhereUniqueInput>
    connect?: Enumerable<AppointmentWhereUniqueInput>
    update?: Enumerable<AppointmentUpdateWithWhereUniqueWithoutMemberInput>
    updateMany?: Enumerable<AppointmentUpdateManyWithWhereWithoutMemberInput>
    deleteMany?: Enumerable<AppointmentScalarWhereInput>
  }

  export type MessageRecipientsUncheckedUpdateManyWithoutMemberInput = {
    create?: XOR<Enumerable<MessageRecipientsCreateWithoutMemberInput>, Enumerable<MessageRecipientsUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<MessageRecipientsCreateOrConnectWithoutMemberInput>
    upsert?: Enumerable<MessageRecipientsUpsertWithWhereUniqueWithoutMemberInput>
    createMany?: MessageRecipientsCreateManyMemberInputEnvelope
    set?: Enumerable<MessageRecipientsWhereUniqueInput>
    disconnect?: Enumerable<MessageRecipientsWhereUniqueInput>
    delete?: Enumerable<MessageRecipientsWhereUniqueInput>
    connect?: Enumerable<MessageRecipientsWhereUniqueInput>
    update?: Enumerable<MessageRecipientsUpdateWithWhereUniqueWithoutMemberInput>
    updateMany?: Enumerable<MessageRecipientsUpdateManyWithWhereWithoutMemberInput>
    deleteMany?: Enumerable<MessageRecipientsScalarWhereInput>
  }

  export type MemberCreateNestedOneWithoutRolesInput = {
    create?: XOR<MemberCreateWithoutRolesInput, MemberUncheckedCreateWithoutRolesInput>
    connectOrCreate?: MemberCreateOrConnectWithoutRolesInput
    connect?: MemberWhereUniqueInput
  }

  export type ShopCreateNestedOneWithoutRoleInput = {
    create?: XOR<ShopCreateWithoutRoleInput, ShopUncheckedCreateWithoutRoleInput>
    connectOrCreate?: ShopCreateOrConnectWithoutRoleInput
    connect?: ShopWhereUniqueInput
  }

  export type RoleCreatepermissionsInput = {
    set: Enumerable<Permissions>
  }

  export type ShopOwnerCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<ShopOwnerCreateWithoutRoleInput>, Enumerable<ShopOwnerUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<ShopOwnerCreateOrConnectWithoutRoleInput>
    createMany?: ShopOwnerCreateManyRoleInputEnvelope
    connect?: Enumerable<ShopOwnerWhereUniqueInput>
  }

  export type ShopManagerCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<ShopManagerCreateWithoutRoleInput>, Enumerable<ShopManagerUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<ShopManagerCreateOrConnectWithoutRoleInput>
    createMany?: ShopManagerCreateManyRoleInputEnvelope
    connect?: Enumerable<ShopManagerWhereUniqueInput>
  }

  export type ShopOwnerUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<ShopOwnerCreateWithoutRoleInput>, Enumerable<ShopOwnerUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<ShopOwnerCreateOrConnectWithoutRoleInput>
    createMany?: ShopOwnerCreateManyRoleInputEnvelope
    connect?: Enumerable<ShopOwnerWhereUniqueInput>
  }

  export type ShopManagerUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<ShopManagerCreateWithoutRoleInput>, Enumerable<ShopManagerUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<ShopManagerCreateOrConnectWithoutRoleInput>
    createMany?: ShopManagerCreateManyRoleInputEnvelope
    connect?: Enumerable<ShopManagerWhereUniqueInput>
  }

  export type MemberUpdateOneRequiredWithoutRolesInput = {
    create?: XOR<MemberCreateWithoutRolesInput, MemberUncheckedCreateWithoutRolesInput>
    connectOrCreate?: MemberCreateOrConnectWithoutRolesInput
    upsert?: MemberUpsertWithoutRolesInput
    connect?: MemberWhereUniqueInput
    update?: XOR<MemberUpdateWithoutRolesInput, MemberUncheckedUpdateWithoutRolesInput>
  }

  export type ShopUpdateOneRequiredWithoutRoleInput = {
    create?: XOR<ShopCreateWithoutRoleInput, ShopUncheckedCreateWithoutRoleInput>
    connectOrCreate?: ShopCreateOrConnectWithoutRoleInput
    upsert?: ShopUpsertWithoutRoleInput
    connect?: ShopWhereUniqueInput
    update?: XOR<ShopUpdateWithoutRoleInput, ShopUncheckedUpdateWithoutRoleInput>
  }

  export type EnumJobTypeFieldUpdateOperationsInput = {
    set?: JobType
  }

  export type RoleUpdatepermissionsInput = {
    set?: Enumerable<Permissions>
    push?: Enumerable<Permissions>
  }

  export type ShopOwnerUpdateManyWithoutRoleInput = {
    create?: XOR<Enumerable<ShopOwnerCreateWithoutRoleInput>, Enumerable<ShopOwnerUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<ShopOwnerCreateOrConnectWithoutRoleInput>
    createMany?: ShopOwnerCreateManyRoleInputEnvelope
    set?: Enumerable<ShopOwnerWhereUniqueInput>
    disconnect?: Enumerable<ShopOwnerWhereUniqueInput>
    delete?: Enumerable<ShopOwnerWhereUniqueInput>
    connect?: Enumerable<ShopOwnerWhereUniqueInput>
    update?: Enumerable<ShopOwnerUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<ShopOwnerUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<ShopOwnerScalarWhereInput>
  }

  export type ShopManagerUpdateManyWithoutRoleInput = {
    create?: XOR<Enumerable<ShopManagerCreateWithoutRoleInput>, Enumerable<ShopManagerUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<ShopManagerCreateOrConnectWithoutRoleInput>
    createMany?: ShopManagerCreateManyRoleInputEnvelope
    set?: Enumerable<ShopManagerWhereUniqueInput>
    disconnect?: Enumerable<ShopManagerWhereUniqueInput>
    delete?: Enumerable<ShopManagerWhereUniqueInput>
    connect?: Enumerable<ShopManagerWhereUniqueInput>
    update?: Enumerable<ShopManagerUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<ShopManagerUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<ShopManagerScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ShopOwnerUncheckedUpdateManyWithoutRoleInput = {
    create?: XOR<Enumerable<ShopOwnerCreateWithoutRoleInput>, Enumerable<ShopOwnerUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<ShopOwnerCreateOrConnectWithoutRoleInput>
    createMany?: ShopOwnerCreateManyRoleInputEnvelope
    set?: Enumerable<ShopOwnerWhereUniqueInput>
    disconnect?: Enumerable<ShopOwnerWhereUniqueInput>
    delete?: Enumerable<ShopOwnerWhereUniqueInput>
    connect?: Enumerable<ShopOwnerWhereUniqueInput>
    update?: Enumerable<ShopOwnerUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<ShopOwnerUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<ShopOwnerScalarWhereInput>
  }

  export type ShopManagerUncheckedUpdateManyWithoutRoleInput = {
    create?: XOR<Enumerable<ShopManagerCreateWithoutRoleInput>, Enumerable<ShopManagerUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<ShopManagerCreateOrConnectWithoutRoleInput>
    createMany?: ShopManagerCreateManyRoleInputEnvelope
    set?: Enumerable<ShopManagerWhereUniqueInput>
    disconnect?: Enumerable<ShopManagerWhereUniqueInput>
    delete?: Enumerable<ShopManagerWhereUniqueInput>
    connect?: Enumerable<ShopManagerWhereUniqueInput>
    update?: Enumerable<ShopManagerUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<ShopManagerUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<ShopManagerScalarWhereInput>
  }

  export type ShopCreateNestedOneWithoutProductsInput = {
    create?: XOR<ShopCreateWithoutProductsInput, ShopUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutProductsInput
    connect?: ShopWhereUniqueInput
  }

  export type ProductInShopCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ProductInShopCreateWithoutProductInput>, Enumerable<ProductInShopUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductInShopCreateOrConnectWithoutProductInput>
    createMany?: ProductInShopCreateManyProductInputEnvelope
    connect?: Enumerable<ProductInShopWhereUniqueInput>
  }

  export type ProductInBagCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ProductInBagCreateWithoutProductInput>, Enumerable<ProductInBagUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductInBagCreateOrConnectWithoutProductInput>
    createMany?: ProductInBagCreateManyProductInputEnvelope
    connect?: Enumerable<ProductInBagWhereUniqueInput>
  }

  export type OfferCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<OfferCreateWithoutProductInput>, Enumerable<OfferUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<OfferCreateOrConnectWithoutProductInput>
    createMany?: OfferCreateManyProductInputEnvelope
    connect?: Enumerable<OfferWhereUniqueInput>
  }

  export type ProductInShopUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ProductInShopCreateWithoutProductInput>, Enumerable<ProductInShopUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductInShopCreateOrConnectWithoutProductInput>
    createMany?: ProductInShopCreateManyProductInputEnvelope
    connect?: Enumerable<ProductInShopWhereUniqueInput>
  }

  export type ProductInBagUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ProductInBagCreateWithoutProductInput>, Enumerable<ProductInBagUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductInBagCreateOrConnectWithoutProductInput>
    createMany?: ProductInBagCreateManyProductInputEnvelope
    connect?: Enumerable<ProductInBagWhereUniqueInput>
  }

  export type OfferUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<OfferCreateWithoutProductInput>, Enumerable<OfferUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<OfferCreateOrConnectWithoutProductInput>
    createMany?: OfferCreateManyProductInputEnvelope
    connect?: Enumerable<OfferWhereUniqueInput>
  }

  export type ShopUpdateOneRequiredWithoutProductsInput = {
    create?: XOR<ShopCreateWithoutProductsInput, ShopUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutProductsInput
    upsert?: ShopUpsertWithoutProductsInput
    connect?: ShopWhereUniqueInput
    update?: XOR<ShopUpdateWithoutProductsInput, ShopUncheckedUpdateWithoutProductsInput>
  }

  export type EnumProductCategoryFieldUpdateOperationsInput = {
    set?: ProductCategory
  }

  export type EnumProductRateFieldUpdateOperationsInput = {
    set?: ProductRate
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ProductInShopUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<ProductInShopCreateWithoutProductInput>, Enumerable<ProductInShopUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductInShopCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ProductInShopUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ProductInShopCreateManyProductInputEnvelope
    set?: Enumerable<ProductInShopWhereUniqueInput>
    disconnect?: Enumerable<ProductInShopWhereUniqueInput>
    delete?: Enumerable<ProductInShopWhereUniqueInput>
    connect?: Enumerable<ProductInShopWhereUniqueInput>
    update?: Enumerable<ProductInShopUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ProductInShopUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ProductInShopScalarWhereInput>
  }

  export type ProductInBagUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<ProductInBagCreateWithoutProductInput>, Enumerable<ProductInBagUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductInBagCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ProductInBagUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ProductInBagCreateManyProductInputEnvelope
    set?: Enumerable<ProductInBagWhereUniqueInput>
    disconnect?: Enumerable<ProductInBagWhereUniqueInput>
    delete?: Enumerable<ProductInBagWhereUniqueInput>
    connect?: Enumerable<ProductInBagWhereUniqueInput>
    update?: Enumerable<ProductInBagUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ProductInBagUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ProductInBagScalarWhereInput>
  }

  export type OfferUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<OfferCreateWithoutProductInput>, Enumerable<OfferUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<OfferCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<OfferUpsertWithWhereUniqueWithoutProductInput>
    createMany?: OfferCreateManyProductInputEnvelope
    set?: Enumerable<OfferWhereUniqueInput>
    disconnect?: Enumerable<OfferWhereUniqueInput>
    delete?: Enumerable<OfferWhereUniqueInput>
    connect?: Enumerable<OfferWhereUniqueInput>
    update?: Enumerable<OfferUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<OfferUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<OfferScalarWhereInput>
  }

  export type ProductInShopUncheckedUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<ProductInShopCreateWithoutProductInput>, Enumerable<ProductInShopUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductInShopCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ProductInShopUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ProductInShopCreateManyProductInputEnvelope
    set?: Enumerable<ProductInShopWhereUniqueInput>
    disconnect?: Enumerable<ProductInShopWhereUniqueInput>
    delete?: Enumerable<ProductInShopWhereUniqueInput>
    connect?: Enumerable<ProductInShopWhereUniqueInput>
    update?: Enumerable<ProductInShopUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ProductInShopUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ProductInShopScalarWhereInput>
  }

  export type ProductInBagUncheckedUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<ProductInBagCreateWithoutProductInput>, Enumerable<ProductInBagUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductInBagCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ProductInBagUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ProductInBagCreateManyProductInputEnvelope
    set?: Enumerable<ProductInBagWhereUniqueInput>
    disconnect?: Enumerable<ProductInBagWhereUniqueInput>
    delete?: Enumerable<ProductInBagWhereUniqueInput>
    connect?: Enumerable<ProductInBagWhereUniqueInput>
    update?: Enumerable<ProductInBagUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ProductInBagUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ProductInBagScalarWhereInput>
  }

  export type OfferUncheckedUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<OfferCreateWithoutProductInput>, Enumerable<OfferUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<OfferCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<OfferUpsertWithWhereUniqueWithoutProductInput>
    createMany?: OfferCreateManyProductInputEnvelope
    set?: Enumerable<OfferWhereUniqueInput>
    disconnect?: Enumerable<OfferWhereUniqueInput>
    delete?: Enumerable<OfferWhereUniqueInput>
    connect?: Enumerable<OfferWhereUniqueInput>
    update?: Enumerable<OfferUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<OfferUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<OfferScalarWhereInput>
  }

  export type MemberCreateNestedOneWithoutShopsInput = {
    create?: XOR<MemberCreateWithoutShopsInput, MemberUncheckedCreateWithoutShopsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutShopsInput
    connect?: MemberWhereUniqueInput
  }

  export type RoleCreateNestedManyWithoutShopInput = {
    create?: XOR<Enumerable<RoleCreateWithoutShopInput>, Enumerable<RoleUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutShopInput>
    createMany?: RoleCreateManyShopInputEnvelope
    connect?: Enumerable<RoleWhereUniqueInput>
  }

  export type ProductCreateNestedManyWithoutShopInput = {
    create?: XOR<Enumerable<ProductCreateWithoutShopInput>, Enumerable<ProductUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutShopInput>
    createMany?: ProductCreateManyShopInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type ProductInShopCreateNestedManyWithoutShopInput = {
    create?: XOR<Enumerable<ProductInShopCreateWithoutShopInput>, Enumerable<ProductInShopUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<ProductInShopCreateOrConnectWithoutShopInput>
    createMany?: ProductInShopCreateManyShopInputEnvelope
    connect?: Enumerable<ProductInShopWhereUniqueInput>
  }

  export type ShoppingBagCreateNestedManyWithoutShopInput = {
    create?: XOR<Enumerable<ShoppingBagCreateWithoutShopInput>, Enumerable<ShoppingBagUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<ShoppingBagCreateOrConnectWithoutShopInput>
    createMany?: ShoppingBagCreateManyShopInputEnvelope
    connect?: Enumerable<ShoppingBagWhereUniqueInput>
  }

  export type DiscountCreateNestedManyWithoutShopInput = {
    create?: XOR<Enumerable<DiscountCreateWithoutShopInput>, Enumerable<DiscountUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<DiscountCreateOrConnectWithoutShopInput>
    createMany?: DiscountCreateManyShopInputEnvelope
    connect?: Enumerable<DiscountWhereUniqueInput>
  }

  export type PolicyCreateNestedManyWithoutShopInput = {
    create?: XOR<Enumerable<PolicyCreateWithoutShopInput>, Enumerable<PolicyUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<PolicyCreateOrConnectWithoutShopInput>
    createMany?: PolicyCreateManyShopInputEnvelope
    connect?: Enumerable<PolicyWhereUniqueInput>
  }

  export type OfferCreateNestedManyWithoutShopInput = {
    create?: XOR<Enumerable<OfferCreateWithoutShopInput>, Enumerable<OfferUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<OfferCreateOrConnectWithoutShopInput>
    createMany?: OfferCreateManyShopInputEnvelope
    connect?: Enumerable<OfferWhereUniqueInput>
  }

  export type AppointmentCreateNestedManyWithoutShopInput = {
    create?: XOR<Enumerable<AppointmentCreateWithoutShopInput>, Enumerable<AppointmentUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<AppointmentCreateOrConnectWithoutShopInput>
    createMany?: AppointmentCreateManyShopInputEnvelope
    connect?: Enumerable<AppointmentWhereUniqueInput>
  }

  export type RoleUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<Enumerable<RoleCreateWithoutShopInput>, Enumerable<RoleUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutShopInput>
    createMany?: RoleCreateManyShopInputEnvelope
    connect?: Enumerable<RoleWhereUniqueInput>
  }

  export type ProductUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<Enumerable<ProductCreateWithoutShopInput>, Enumerable<ProductUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutShopInput>
    createMany?: ProductCreateManyShopInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type ProductInShopUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<Enumerable<ProductInShopCreateWithoutShopInput>, Enumerable<ProductInShopUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<ProductInShopCreateOrConnectWithoutShopInput>
    createMany?: ProductInShopCreateManyShopInputEnvelope
    connect?: Enumerable<ProductInShopWhereUniqueInput>
  }

  export type ShoppingBagUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<Enumerable<ShoppingBagCreateWithoutShopInput>, Enumerable<ShoppingBagUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<ShoppingBagCreateOrConnectWithoutShopInput>
    createMany?: ShoppingBagCreateManyShopInputEnvelope
    connect?: Enumerable<ShoppingBagWhereUniqueInput>
  }

  export type DiscountUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<Enumerable<DiscountCreateWithoutShopInput>, Enumerable<DiscountUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<DiscountCreateOrConnectWithoutShopInput>
    createMany?: DiscountCreateManyShopInputEnvelope
    connect?: Enumerable<DiscountWhereUniqueInput>
  }

  export type PolicyUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<Enumerable<PolicyCreateWithoutShopInput>, Enumerable<PolicyUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<PolicyCreateOrConnectWithoutShopInput>
    createMany?: PolicyCreateManyShopInputEnvelope
    connect?: Enumerable<PolicyWhereUniqueInput>
  }

  export type OfferUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<Enumerable<OfferCreateWithoutShopInput>, Enumerable<OfferUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<OfferCreateOrConnectWithoutShopInput>
    createMany?: OfferCreateManyShopInputEnvelope
    connect?: Enumerable<OfferWhereUniqueInput>
  }

  export type AppointmentUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<Enumerable<AppointmentCreateWithoutShopInput>, Enumerable<AppointmentUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<AppointmentCreateOrConnectWithoutShopInput>
    createMany?: AppointmentCreateManyShopInputEnvelope
    connect?: Enumerable<AppointmentWhereUniqueInput>
  }

  export type EnumShopStatusFieldUpdateOperationsInput = {
    set?: ShopStatus
  }

  export type MemberUpdateOneRequiredWithoutShopsInput = {
    create?: XOR<MemberCreateWithoutShopsInput, MemberUncheckedCreateWithoutShopsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutShopsInput
    upsert?: MemberUpsertWithoutShopsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<MemberUpdateWithoutShopsInput, MemberUncheckedUpdateWithoutShopsInput>
  }

  export type EnumShopRateFieldUpdateOperationsInput = {
    set?: ShopRate
  }

  export type RoleUpdateManyWithoutShopInput = {
    create?: XOR<Enumerable<RoleCreateWithoutShopInput>, Enumerable<RoleUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutShopInput>
    upsert?: Enumerable<RoleUpsertWithWhereUniqueWithoutShopInput>
    createMany?: RoleCreateManyShopInputEnvelope
    set?: Enumerable<RoleWhereUniqueInput>
    disconnect?: Enumerable<RoleWhereUniqueInput>
    delete?: Enumerable<RoleWhereUniqueInput>
    connect?: Enumerable<RoleWhereUniqueInput>
    update?: Enumerable<RoleUpdateWithWhereUniqueWithoutShopInput>
    updateMany?: Enumerable<RoleUpdateManyWithWhereWithoutShopInput>
    deleteMany?: Enumerable<RoleScalarWhereInput>
  }

  export type ProductUpdateManyWithoutShopInput = {
    create?: XOR<Enumerable<ProductCreateWithoutShopInput>, Enumerable<ProductUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutShopInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutShopInput>
    createMany?: ProductCreateManyShopInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutShopInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutShopInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type ProductInShopUpdateManyWithoutShopInput = {
    create?: XOR<Enumerable<ProductInShopCreateWithoutShopInput>, Enumerable<ProductInShopUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<ProductInShopCreateOrConnectWithoutShopInput>
    upsert?: Enumerable<ProductInShopUpsertWithWhereUniqueWithoutShopInput>
    createMany?: ProductInShopCreateManyShopInputEnvelope
    set?: Enumerable<ProductInShopWhereUniqueInput>
    disconnect?: Enumerable<ProductInShopWhereUniqueInput>
    delete?: Enumerable<ProductInShopWhereUniqueInput>
    connect?: Enumerable<ProductInShopWhereUniqueInput>
    update?: Enumerable<ProductInShopUpdateWithWhereUniqueWithoutShopInput>
    updateMany?: Enumerable<ProductInShopUpdateManyWithWhereWithoutShopInput>
    deleteMany?: Enumerable<ProductInShopScalarWhereInput>
  }

  export type ShoppingBagUpdateManyWithoutShopInput = {
    create?: XOR<Enumerable<ShoppingBagCreateWithoutShopInput>, Enumerable<ShoppingBagUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<ShoppingBagCreateOrConnectWithoutShopInput>
    upsert?: Enumerable<ShoppingBagUpsertWithWhereUniqueWithoutShopInput>
    createMany?: ShoppingBagCreateManyShopInputEnvelope
    set?: Enumerable<ShoppingBagWhereUniqueInput>
    disconnect?: Enumerable<ShoppingBagWhereUniqueInput>
    delete?: Enumerable<ShoppingBagWhereUniqueInput>
    connect?: Enumerable<ShoppingBagWhereUniqueInput>
    update?: Enumerable<ShoppingBagUpdateWithWhereUniqueWithoutShopInput>
    updateMany?: Enumerable<ShoppingBagUpdateManyWithWhereWithoutShopInput>
    deleteMany?: Enumerable<ShoppingBagScalarWhereInput>
  }

  export type DiscountUpdateManyWithoutShopInput = {
    create?: XOR<Enumerable<DiscountCreateWithoutShopInput>, Enumerable<DiscountUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<DiscountCreateOrConnectWithoutShopInput>
    upsert?: Enumerable<DiscountUpsertWithWhereUniqueWithoutShopInput>
    createMany?: DiscountCreateManyShopInputEnvelope
    set?: Enumerable<DiscountWhereUniqueInput>
    disconnect?: Enumerable<DiscountWhereUniqueInput>
    delete?: Enumerable<DiscountWhereUniqueInput>
    connect?: Enumerable<DiscountWhereUniqueInput>
    update?: Enumerable<DiscountUpdateWithWhereUniqueWithoutShopInput>
    updateMany?: Enumerable<DiscountUpdateManyWithWhereWithoutShopInput>
    deleteMany?: Enumerable<DiscountScalarWhereInput>
  }

  export type PolicyUpdateManyWithoutShopInput = {
    create?: XOR<Enumerable<PolicyCreateWithoutShopInput>, Enumerable<PolicyUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<PolicyCreateOrConnectWithoutShopInput>
    upsert?: Enumerable<PolicyUpsertWithWhereUniqueWithoutShopInput>
    createMany?: PolicyCreateManyShopInputEnvelope
    set?: Enumerable<PolicyWhereUniqueInput>
    disconnect?: Enumerable<PolicyWhereUniqueInput>
    delete?: Enumerable<PolicyWhereUniqueInput>
    connect?: Enumerable<PolicyWhereUniqueInput>
    update?: Enumerable<PolicyUpdateWithWhereUniqueWithoutShopInput>
    updateMany?: Enumerable<PolicyUpdateManyWithWhereWithoutShopInput>
    deleteMany?: Enumerable<PolicyScalarWhereInput>
  }

  export type OfferUpdateManyWithoutShopInput = {
    create?: XOR<Enumerable<OfferCreateWithoutShopInput>, Enumerable<OfferUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<OfferCreateOrConnectWithoutShopInput>
    upsert?: Enumerable<OfferUpsertWithWhereUniqueWithoutShopInput>
    createMany?: OfferCreateManyShopInputEnvelope
    set?: Enumerable<OfferWhereUniqueInput>
    disconnect?: Enumerable<OfferWhereUniqueInput>
    delete?: Enumerable<OfferWhereUniqueInput>
    connect?: Enumerable<OfferWhereUniqueInput>
    update?: Enumerable<OfferUpdateWithWhereUniqueWithoutShopInput>
    updateMany?: Enumerable<OfferUpdateManyWithWhereWithoutShopInput>
    deleteMany?: Enumerable<OfferScalarWhereInput>
  }

  export type AppointmentUpdateManyWithoutShopInput = {
    create?: XOR<Enumerable<AppointmentCreateWithoutShopInput>, Enumerable<AppointmentUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<AppointmentCreateOrConnectWithoutShopInput>
    upsert?: Enumerable<AppointmentUpsertWithWhereUniqueWithoutShopInput>
    createMany?: AppointmentCreateManyShopInputEnvelope
    set?: Enumerable<AppointmentWhereUniqueInput>
    disconnect?: Enumerable<AppointmentWhereUniqueInput>
    delete?: Enumerable<AppointmentWhereUniqueInput>
    connect?: Enumerable<AppointmentWhereUniqueInput>
    update?: Enumerable<AppointmentUpdateWithWhereUniqueWithoutShopInput>
    updateMany?: Enumerable<AppointmentUpdateManyWithWhereWithoutShopInput>
    deleteMany?: Enumerable<AppointmentScalarWhereInput>
  }

  export type RoleUncheckedUpdateManyWithoutShopInput = {
    create?: XOR<Enumerable<RoleCreateWithoutShopInput>, Enumerable<RoleUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutShopInput>
    upsert?: Enumerable<RoleUpsertWithWhereUniqueWithoutShopInput>
    createMany?: RoleCreateManyShopInputEnvelope
    set?: Enumerable<RoleWhereUniqueInput>
    disconnect?: Enumerable<RoleWhereUniqueInput>
    delete?: Enumerable<RoleWhereUniqueInput>
    connect?: Enumerable<RoleWhereUniqueInput>
    update?: Enumerable<RoleUpdateWithWhereUniqueWithoutShopInput>
    updateMany?: Enumerable<RoleUpdateManyWithWhereWithoutShopInput>
    deleteMany?: Enumerable<RoleScalarWhereInput>
  }

  export type ProductUncheckedUpdateManyWithoutShopInput = {
    create?: XOR<Enumerable<ProductCreateWithoutShopInput>, Enumerable<ProductUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutShopInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutShopInput>
    createMany?: ProductCreateManyShopInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutShopInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutShopInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type ProductInShopUncheckedUpdateManyWithoutShopInput = {
    create?: XOR<Enumerable<ProductInShopCreateWithoutShopInput>, Enumerable<ProductInShopUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<ProductInShopCreateOrConnectWithoutShopInput>
    upsert?: Enumerable<ProductInShopUpsertWithWhereUniqueWithoutShopInput>
    createMany?: ProductInShopCreateManyShopInputEnvelope
    set?: Enumerable<ProductInShopWhereUniqueInput>
    disconnect?: Enumerable<ProductInShopWhereUniqueInput>
    delete?: Enumerable<ProductInShopWhereUniqueInput>
    connect?: Enumerable<ProductInShopWhereUniqueInput>
    update?: Enumerable<ProductInShopUpdateWithWhereUniqueWithoutShopInput>
    updateMany?: Enumerable<ProductInShopUpdateManyWithWhereWithoutShopInput>
    deleteMany?: Enumerable<ProductInShopScalarWhereInput>
  }

  export type ShoppingBagUncheckedUpdateManyWithoutShopInput = {
    create?: XOR<Enumerable<ShoppingBagCreateWithoutShopInput>, Enumerable<ShoppingBagUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<ShoppingBagCreateOrConnectWithoutShopInput>
    upsert?: Enumerable<ShoppingBagUpsertWithWhereUniqueWithoutShopInput>
    createMany?: ShoppingBagCreateManyShopInputEnvelope
    set?: Enumerable<ShoppingBagWhereUniqueInput>
    disconnect?: Enumerable<ShoppingBagWhereUniqueInput>
    delete?: Enumerable<ShoppingBagWhereUniqueInput>
    connect?: Enumerable<ShoppingBagWhereUniqueInput>
    update?: Enumerable<ShoppingBagUpdateWithWhereUniqueWithoutShopInput>
    updateMany?: Enumerable<ShoppingBagUpdateManyWithWhereWithoutShopInput>
    deleteMany?: Enumerable<ShoppingBagScalarWhereInput>
  }

  export type DiscountUncheckedUpdateManyWithoutShopInput = {
    create?: XOR<Enumerable<DiscountCreateWithoutShopInput>, Enumerable<DiscountUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<DiscountCreateOrConnectWithoutShopInput>
    upsert?: Enumerable<DiscountUpsertWithWhereUniqueWithoutShopInput>
    createMany?: DiscountCreateManyShopInputEnvelope
    set?: Enumerable<DiscountWhereUniqueInput>
    disconnect?: Enumerable<DiscountWhereUniqueInput>
    delete?: Enumerable<DiscountWhereUniqueInput>
    connect?: Enumerable<DiscountWhereUniqueInput>
    update?: Enumerable<DiscountUpdateWithWhereUniqueWithoutShopInput>
    updateMany?: Enumerable<DiscountUpdateManyWithWhereWithoutShopInput>
    deleteMany?: Enumerable<DiscountScalarWhereInput>
  }

  export type PolicyUncheckedUpdateManyWithoutShopInput = {
    create?: XOR<Enumerable<PolicyCreateWithoutShopInput>, Enumerable<PolicyUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<PolicyCreateOrConnectWithoutShopInput>
    upsert?: Enumerable<PolicyUpsertWithWhereUniqueWithoutShopInput>
    createMany?: PolicyCreateManyShopInputEnvelope
    set?: Enumerable<PolicyWhereUniqueInput>
    disconnect?: Enumerable<PolicyWhereUniqueInput>
    delete?: Enumerable<PolicyWhereUniqueInput>
    connect?: Enumerable<PolicyWhereUniqueInput>
    update?: Enumerable<PolicyUpdateWithWhereUniqueWithoutShopInput>
    updateMany?: Enumerable<PolicyUpdateManyWithWhereWithoutShopInput>
    deleteMany?: Enumerable<PolicyScalarWhereInput>
  }

  export type OfferUncheckedUpdateManyWithoutShopInput = {
    create?: XOR<Enumerable<OfferCreateWithoutShopInput>, Enumerable<OfferUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<OfferCreateOrConnectWithoutShopInput>
    upsert?: Enumerable<OfferUpsertWithWhereUniqueWithoutShopInput>
    createMany?: OfferCreateManyShopInputEnvelope
    set?: Enumerable<OfferWhereUniqueInput>
    disconnect?: Enumerable<OfferWhereUniqueInput>
    delete?: Enumerable<OfferWhereUniqueInput>
    connect?: Enumerable<OfferWhereUniqueInput>
    update?: Enumerable<OfferUpdateWithWhereUniqueWithoutShopInput>
    updateMany?: Enumerable<OfferUpdateManyWithWhereWithoutShopInput>
    deleteMany?: Enumerable<OfferScalarWhereInput>
  }

  export type AppointmentUncheckedUpdateManyWithoutShopInput = {
    create?: XOR<Enumerable<AppointmentCreateWithoutShopInput>, Enumerable<AppointmentUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<AppointmentCreateOrConnectWithoutShopInput>
    upsert?: Enumerable<AppointmentUpsertWithWhereUniqueWithoutShopInput>
    createMany?: AppointmentCreateManyShopInputEnvelope
    set?: Enumerable<AppointmentWhereUniqueInput>
    disconnect?: Enumerable<AppointmentWhereUniqueInput>
    delete?: Enumerable<AppointmentWhereUniqueInput>
    connect?: Enumerable<AppointmentWhereUniqueInput>
    update?: Enumerable<AppointmentUpdateWithWhereUniqueWithoutShopInput>
    updateMany?: Enumerable<AppointmentUpdateManyWithWhereWithoutShopInput>
    deleteMany?: Enumerable<AppointmentScalarWhereInput>
  }

  export type RoleCreateNestedOneWithoutShop_ownersInput = {
    create?: XOR<RoleCreateWithoutShop_ownersInput, RoleUncheckedCreateWithoutShop_ownersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutShop_ownersInput
    connect?: RoleWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutShop_ownersInput = {
    create?: XOR<RoleCreateWithoutShop_ownersInput, RoleUncheckedCreateWithoutShop_ownersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutShop_ownersInput
    upsert?: RoleUpsertWithoutShop_ownersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<RoleUpdateWithoutShop_ownersInput, RoleUncheckedUpdateWithoutShop_ownersInput>
  }

  export type RoleCreateNestedOneWithoutShop_managersInput = {
    create?: XOR<RoleCreateWithoutShop_managersInput, RoleUncheckedCreateWithoutShop_managersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutShop_managersInput
    connect?: RoleWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutShop_managersInput = {
    create?: XOR<RoleCreateWithoutShop_managersInput, RoleUncheckedCreateWithoutShop_managersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutShop_managersInput
    upsert?: RoleUpsertWithoutShop_managersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<RoleUpdateWithoutShop_managersInput, RoleUncheckedUpdateWithoutShop_managersInput>
  }

  export type ShopCreateNestedOneWithoutProducts_in_shopInput = {
    create?: XOR<ShopCreateWithoutProducts_in_shopInput, ShopUncheckedCreateWithoutProducts_in_shopInput>
    connectOrCreate?: ShopCreateOrConnectWithoutProducts_in_shopInput
    connect?: ShopWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutProducts_in_shopInput = {
    create?: XOR<ProductCreateWithoutProducts_in_shopInput, ProductUncheckedCreateWithoutProducts_in_shopInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProducts_in_shopInput
    connect?: ProductWhereUniqueInput
  }

  export type ShopUpdateOneRequiredWithoutProducts_in_shopInput = {
    create?: XOR<ShopCreateWithoutProducts_in_shopInput, ShopUncheckedCreateWithoutProducts_in_shopInput>
    connectOrCreate?: ShopCreateOrConnectWithoutProducts_in_shopInput
    upsert?: ShopUpsertWithoutProducts_in_shopInput
    connect?: ShopWhereUniqueInput
    update?: XOR<ShopUpdateWithoutProducts_in_shopInput, ShopUncheckedUpdateWithoutProducts_in_shopInput>
  }

  export type ProductUpdateOneRequiredWithoutProducts_in_shopInput = {
    create?: XOR<ProductCreateWithoutProducts_in_shopInput, ProductUncheckedCreateWithoutProducts_in_shopInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProducts_in_shopInput
    upsert?: ProductUpsertWithoutProducts_in_shopInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutProducts_in_shopInput, ProductUncheckedUpdateWithoutProducts_in_shopInput>
  }

  export type MemberCreateNestedOneWithoutShoppingCartInput = {
    create?: XOR<MemberCreateWithoutShoppingCartInput, MemberUncheckedCreateWithoutShoppingCartInput>
    connectOrCreate?: MemberCreateOrConnectWithoutShoppingCartInput
    connect?: MemberWhereUniqueInput
  }

  export type ShoppingBagCreateNestedManyWithoutShoppingCartInput = {
    create?: XOR<Enumerable<ShoppingBagCreateWithoutShoppingCartInput>, Enumerable<ShoppingBagUncheckedCreateWithoutShoppingCartInput>>
    connectOrCreate?: Enumerable<ShoppingBagCreateOrConnectWithoutShoppingCartInput>
    createMany?: ShoppingBagCreateManyShoppingCartInputEnvelope
    connect?: Enumerable<ShoppingBagWhereUniqueInput>
  }

  export type ShoppingBagUncheckedCreateNestedManyWithoutShoppingCartInput = {
    create?: XOR<Enumerable<ShoppingBagCreateWithoutShoppingCartInput>, Enumerable<ShoppingBagUncheckedCreateWithoutShoppingCartInput>>
    connectOrCreate?: Enumerable<ShoppingBagCreateOrConnectWithoutShoppingCartInput>
    createMany?: ShoppingBagCreateManyShoppingCartInputEnvelope
    connect?: Enumerable<ShoppingBagWhereUniqueInput>
  }

  export type MemberUpdateOneRequiredWithoutShoppingCartInput = {
    create?: XOR<MemberCreateWithoutShoppingCartInput, MemberUncheckedCreateWithoutShoppingCartInput>
    connectOrCreate?: MemberCreateOrConnectWithoutShoppingCartInput
    upsert?: MemberUpsertWithoutShoppingCartInput
    connect?: MemberWhereUniqueInput
    update?: XOR<MemberUpdateWithoutShoppingCartInput, MemberUncheckedUpdateWithoutShoppingCartInput>
  }

  export type ShoppingBagUpdateManyWithoutShoppingCartInput = {
    create?: XOR<Enumerable<ShoppingBagCreateWithoutShoppingCartInput>, Enumerable<ShoppingBagUncheckedCreateWithoutShoppingCartInput>>
    connectOrCreate?: Enumerable<ShoppingBagCreateOrConnectWithoutShoppingCartInput>
    upsert?: Enumerable<ShoppingBagUpsertWithWhereUniqueWithoutShoppingCartInput>
    createMany?: ShoppingBagCreateManyShoppingCartInputEnvelope
    set?: Enumerable<ShoppingBagWhereUniqueInput>
    disconnect?: Enumerable<ShoppingBagWhereUniqueInput>
    delete?: Enumerable<ShoppingBagWhereUniqueInput>
    connect?: Enumerable<ShoppingBagWhereUniqueInput>
    update?: Enumerable<ShoppingBagUpdateWithWhereUniqueWithoutShoppingCartInput>
    updateMany?: Enumerable<ShoppingBagUpdateManyWithWhereWithoutShoppingCartInput>
    deleteMany?: Enumerable<ShoppingBagScalarWhereInput>
  }

  export type ShoppingBagUncheckedUpdateManyWithoutShoppingCartInput = {
    create?: XOR<Enumerable<ShoppingBagCreateWithoutShoppingCartInput>, Enumerable<ShoppingBagUncheckedCreateWithoutShoppingCartInput>>
    connectOrCreate?: Enumerable<ShoppingBagCreateOrConnectWithoutShoppingCartInput>
    upsert?: Enumerable<ShoppingBagUpsertWithWhereUniqueWithoutShoppingCartInput>
    createMany?: ShoppingBagCreateManyShoppingCartInputEnvelope
    set?: Enumerable<ShoppingBagWhereUniqueInput>
    disconnect?: Enumerable<ShoppingBagWhereUniqueInput>
    delete?: Enumerable<ShoppingBagWhereUniqueInput>
    connect?: Enumerable<ShoppingBagWhereUniqueInput>
    update?: Enumerable<ShoppingBagUpdateWithWhereUniqueWithoutShoppingCartInput>
    updateMany?: Enumerable<ShoppingBagUpdateManyWithWhereWithoutShoppingCartInput>
    deleteMany?: Enumerable<ShoppingBagScalarWhereInput>
  }

  export type ShoppingCartCreateNestedOneWithoutBagsInput = {
    create?: XOR<ShoppingCartCreateWithoutBagsInput, ShoppingCartUncheckedCreateWithoutBagsInput>
    connectOrCreate?: ShoppingCartCreateOrConnectWithoutBagsInput
    connect?: ShoppingCartWhereUniqueInput
  }

  export type ShopCreateNestedOneWithoutBagsInput = {
    create?: XOR<ShopCreateWithoutBagsInput, ShopUncheckedCreateWithoutBagsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutBagsInput
    connect?: ShopWhereUniqueInput
  }

  export type ProductInBagCreateNestedManyWithoutShoppingBagInput = {
    create?: XOR<Enumerable<ProductInBagCreateWithoutShoppingBagInput>, Enumerable<ProductInBagUncheckedCreateWithoutShoppingBagInput>>
    connectOrCreate?: Enumerable<ProductInBagCreateOrConnectWithoutShoppingBagInput>
    createMany?: ProductInBagCreateManyShoppingBagInputEnvelope
    connect?: Enumerable<ProductInBagWhereUniqueInput>
  }

  export type ProductInBagUncheckedCreateNestedManyWithoutShoppingBagInput = {
    create?: XOR<Enumerable<ProductInBagCreateWithoutShoppingBagInput>, Enumerable<ProductInBagUncheckedCreateWithoutShoppingBagInput>>
    connectOrCreate?: Enumerable<ProductInBagCreateOrConnectWithoutShoppingBagInput>
    createMany?: ProductInBagCreateManyShoppingBagInputEnvelope
    connect?: Enumerable<ProductInBagWhereUniqueInput>
  }

  export type ShoppingCartUpdateOneRequiredWithoutBagsInput = {
    create?: XOR<ShoppingCartCreateWithoutBagsInput, ShoppingCartUncheckedCreateWithoutBagsInput>
    connectOrCreate?: ShoppingCartCreateOrConnectWithoutBagsInput
    upsert?: ShoppingCartUpsertWithoutBagsInput
    connect?: ShoppingCartWhereUniqueInput
    update?: XOR<ShoppingCartUpdateWithoutBagsInput, ShoppingCartUncheckedUpdateWithoutBagsInput>
  }

  export type ShopUpdateOneRequiredWithoutBagsInput = {
    create?: XOR<ShopCreateWithoutBagsInput, ShopUncheckedCreateWithoutBagsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutBagsInput
    upsert?: ShopUpsertWithoutBagsInput
    connect?: ShopWhereUniqueInput
    update?: XOR<ShopUpdateWithoutBagsInput, ShopUncheckedUpdateWithoutBagsInput>
  }

  export type ProductInBagUpdateManyWithoutShoppingBagInput = {
    create?: XOR<Enumerable<ProductInBagCreateWithoutShoppingBagInput>, Enumerable<ProductInBagUncheckedCreateWithoutShoppingBagInput>>
    connectOrCreate?: Enumerable<ProductInBagCreateOrConnectWithoutShoppingBagInput>
    upsert?: Enumerable<ProductInBagUpsertWithWhereUniqueWithoutShoppingBagInput>
    createMany?: ProductInBagCreateManyShoppingBagInputEnvelope
    set?: Enumerable<ProductInBagWhereUniqueInput>
    disconnect?: Enumerable<ProductInBagWhereUniqueInput>
    delete?: Enumerable<ProductInBagWhereUniqueInput>
    connect?: Enumerable<ProductInBagWhereUniqueInput>
    update?: Enumerable<ProductInBagUpdateWithWhereUniqueWithoutShoppingBagInput>
    updateMany?: Enumerable<ProductInBagUpdateManyWithWhereWithoutShoppingBagInput>
    deleteMany?: Enumerable<ProductInBagScalarWhereInput>
  }

  export type ProductInBagUncheckedUpdateManyWithoutShoppingBagInput = {
    create?: XOR<Enumerable<ProductInBagCreateWithoutShoppingBagInput>, Enumerable<ProductInBagUncheckedCreateWithoutShoppingBagInput>>
    connectOrCreate?: Enumerable<ProductInBagCreateOrConnectWithoutShoppingBagInput>
    upsert?: Enumerable<ProductInBagUpsertWithWhereUniqueWithoutShoppingBagInput>
    createMany?: ProductInBagCreateManyShoppingBagInputEnvelope
    set?: Enumerable<ProductInBagWhereUniqueInput>
    disconnect?: Enumerable<ProductInBagWhereUniqueInput>
    delete?: Enumerable<ProductInBagWhereUniqueInput>
    connect?: Enumerable<ProductInBagWhereUniqueInput>
    update?: Enumerable<ProductInBagUpdateWithWhereUniqueWithoutShoppingBagInput>
    updateMany?: Enumerable<ProductInBagUpdateManyWithWhereWithoutShoppingBagInput>
    deleteMany?: Enumerable<ProductInBagScalarWhereInput>
  }

  export type ShoppingBagCreateNestedOneWithoutProducts_in_bagInput = {
    create?: XOR<ShoppingBagCreateWithoutProducts_in_bagInput, ShoppingBagUncheckedCreateWithoutProducts_in_bagInput>
    connectOrCreate?: ShoppingBagCreateOrConnectWithoutProducts_in_bagInput
    connect?: ShoppingBagWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutProducts_in_bagInput = {
    create?: XOR<ProductCreateWithoutProducts_in_bagInput, ProductUncheckedCreateWithoutProducts_in_bagInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProducts_in_bagInput
    connect?: ProductWhereUniqueInput
  }

  export type ShoppingBagUpdateOneRequiredWithoutProducts_in_bagInput = {
    create?: XOR<ShoppingBagCreateWithoutProducts_in_bagInput, ShoppingBagUncheckedCreateWithoutProducts_in_bagInput>
    connectOrCreate?: ShoppingBagCreateOrConnectWithoutProducts_in_bagInput
    upsert?: ShoppingBagUpsertWithoutProducts_in_bagInput
    connect?: ShoppingBagWhereUniqueInput
    update?: XOR<ShoppingBagUpdateWithoutProducts_in_bagInput, ShoppingBagUncheckedUpdateWithoutProducts_in_bagInput>
  }

  export type ProductUpdateOneRequiredWithoutProducts_in_bagInput = {
    create?: XOR<ProductCreateWithoutProducts_in_bagInput, ProductUncheckedCreateWithoutProducts_in_bagInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProducts_in_bagInput
    upsert?: ProductUpsertWithoutProducts_in_bagInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutProducts_in_bagInput, ProductUncheckedUpdateWithoutProducts_in_bagInput>
  }

  export type MemberCreateNestedOneWithoutMemberCredentialsInput = {
    create?: XOR<MemberCreateWithoutMemberCredentialsInput, MemberUncheckedCreateWithoutMemberCredentialsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutMemberCredentialsInput
    connect?: MemberWhereUniqueInput
  }

  export type MemberUpdateOneWithoutMemberCredentialsInput = {
    create?: XOR<MemberCreateWithoutMemberCredentialsInput, MemberUncheckedCreateWithoutMemberCredentialsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutMemberCredentialsInput
    upsert?: MemberUpsertWithoutMemberCredentialsInput
    disconnect?: boolean
    delete?: boolean
    connect?: MemberWhereUniqueInput
    update?: XOR<MemberUpdateWithoutMemberCredentialsInput, MemberUncheckedUpdateWithoutMemberCredentialsInput>
  }

  export type MessageRecipientsCreateNestedManyWithoutMessageInput = {
    create?: XOR<Enumerable<MessageRecipientsCreateWithoutMessageInput>, Enumerable<MessageRecipientsUncheckedCreateWithoutMessageInput>>
    connectOrCreate?: Enumerable<MessageRecipientsCreateOrConnectWithoutMessageInput>
    createMany?: MessageRecipientsCreateManyMessageInputEnvelope
    connect?: Enumerable<MessageRecipientsWhereUniqueInput>
  }

  export type MessageRecipientsUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<Enumerable<MessageRecipientsCreateWithoutMessageInput>, Enumerable<MessageRecipientsUncheckedCreateWithoutMessageInput>>
    connectOrCreate?: Enumerable<MessageRecipientsCreateOrConnectWithoutMessageInput>
    createMany?: MessageRecipientsCreateManyMessageInputEnvelope
    connect?: Enumerable<MessageRecipientsWhereUniqueInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumMessageTypeFieldUpdateOperationsInput = {
    set?: MessageType
  }

  export type MessageRecipientsUpdateManyWithoutMessageInput = {
    create?: XOR<Enumerable<MessageRecipientsCreateWithoutMessageInput>, Enumerable<MessageRecipientsUncheckedCreateWithoutMessageInput>>
    connectOrCreate?: Enumerable<MessageRecipientsCreateOrConnectWithoutMessageInput>
    upsert?: Enumerable<MessageRecipientsUpsertWithWhereUniqueWithoutMessageInput>
    createMany?: MessageRecipientsCreateManyMessageInputEnvelope
    set?: Enumerable<MessageRecipientsWhereUniqueInput>
    disconnect?: Enumerable<MessageRecipientsWhereUniqueInput>
    delete?: Enumerable<MessageRecipientsWhereUniqueInput>
    connect?: Enumerable<MessageRecipientsWhereUniqueInput>
    update?: Enumerable<MessageRecipientsUpdateWithWhereUniqueWithoutMessageInput>
    updateMany?: Enumerable<MessageRecipientsUpdateManyWithWhereWithoutMessageInput>
    deleteMany?: Enumerable<MessageRecipientsScalarWhereInput>
  }

  export type MessageRecipientsUncheckedUpdateManyWithoutMessageInput = {
    create?: XOR<Enumerable<MessageRecipientsCreateWithoutMessageInput>, Enumerable<MessageRecipientsUncheckedCreateWithoutMessageInput>>
    connectOrCreate?: Enumerable<MessageRecipientsCreateOrConnectWithoutMessageInput>
    upsert?: Enumerable<MessageRecipientsUpsertWithWhereUniqueWithoutMessageInput>
    createMany?: MessageRecipientsCreateManyMessageInputEnvelope
    set?: Enumerable<MessageRecipientsWhereUniqueInput>
    disconnect?: Enumerable<MessageRecipientsWhereUniqueInput>
    delete?: Enumerable<MessageRecipientsWhereUniqueInput>
    connect?: Enumerable<MessageRecipientsWhereUniqueInput>
    update?: Enumerable<MessageRecipientsUpdateWithWhereUniqueWithoutMessageInput>
    updateMany?: Enumerable<MessageRecipientsUpdateManyWithWhereWithoutMessageInput>
    deleteMany?: Enumerable<MessageRecipientsScalarWhereInput>
  }

  export type MessageCreateNestedOneWithoutRecipientsInput = {
    create?: XOR<MessageCreateWithoutRecipientsInput, MessageUncheckedCreateWithoutRecipientsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientsInput
    connect?: MessageWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutMessageRecipientsInput = {
    create?: XOR<MemberCreateWithoutMessageRecipientsInput, MemberUncheckedCreateWithoutMessageRecipientsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutMessageRecipientsInput
    connect?: MemberWhereUniqueInput
  }

  export type MessageUpdateOneRequiredWithoutRecipientsInput = {
    create?: XOR<MessageCreateWithoutRecipientsInput, MessageUncheckedCreateWithoutRecipientsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientsInput
    upsert?: MessageUpsertWithoutRecipientsInput
    connect?: MessageWhereUniqueInput
    update?: XOR<MessageUpdateWithoutRecipientsInput, MessageUncheckedUpdateWithoutRecipientsInput>
  }

  export type MemberUpdateOneRequiredWithoutMessageRecipientsInput = {
    create?: XOR<MemberCreateWithoutMessageRecipientsInput, MemberUncheckedCreateWithoutMessageRecipientsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutMessageRecipientsInput
    upsert?: MemberUpsertWithoutMessageRecipientsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<MemberUpdateWithoutMessageRecipientsInput, MemberUncheckedUpdateWithoutMessageRecipientsInput>
  }

  export type ShopCreateNestedOneWithoutDiscountsInput = {
    create?: XOR<ShopCreateWithoutDiscountsInput, ShopUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutDiscountsInput
    connect?: ShopWhereUniqueInput
  }

  export type SimpleDiscountCreateNestedOneWithoutDiscountInput = {
    create?: XOR<SimpleDiscountCreateWithoutDiscountInput, SimpleDiscountUncheckedCreateWithoutDiscountInput>
    connectOrCreate?: SimpleDiscountCreateOrConnectWithoutDiscountInput
    connect?: SimpleDiscountWhereUniqueInput
  }

  export type ConditionalDiscountCreateNestedOneWithoutDiscountInput = {
    create?: XOR<ConditionalDiscountCreateWithoutDiscountInput, ConditionalDiscountUncheckedCreateWithoutDiscountInput>
    connectOrCreate?: ConditionalDiscountCreateOrConnectWithoutDiscountInput
    connect?: ConditionalDiscountWhereUniqueInput
  }

  export type DiscountContainerCreateNestedOneWithoutDiscountInput = {
    create?: XOR<DiscountContainerCreateWithoutDiscountInput, DiscountContainerUncheckedCreateWithoutDiscountInput>
    connectOrCreate?: DiscountContainerCreateOrConnectWithoutDiscountInput
    connect?: DiscountContainerWhereUniqueInput
  }

  export type DiscountInContainerCreateNestedOneWithoutDiscountInput = {
    create?: XOR<DiscountInContainerCreateWithoutDiscountInput, DiscountInContainerUncheckedCreateWithoutDiscountInput>
    connectOrCreate?: DiscountInContainerCreateOrConnectWithoutDiscountInput
    connect?: DiscountInContainerWhereUniqueInput
  }

  export type SimpleDiscountUncheckedCreateNestedOneWithoutDiscountInput = {
    create?: XOR<SimpleDiscountCreateWithoutDiscountInput, SimpleDiscountUncheckedCreateWithoutDiscountInput>
    connectOrCreate?: SimpleDiscountCreateOrConnectWithoutDiscountInput
    connect?: SimpleDiscountWhereUniqueInput
  }

  export type ConditionalDiscountUncheckedCreateNestedOneWithoutDiscountInput = {
    create?: XOR<ConditionalDiscountCreateWithoutDiscountInput, ConditionalDiscountUncheckedCreateWithoutDiscountInput>
    connectOrCreate?: ConditionalDiscountCreateOrConnectWithoutDiscountInput
    connect?: ConditionalDiscountWhereUniqueInput
  }

  export type DiscountContainerUncheckedCreateNestedOneWithoutDiscountInput = {
    create?: XOR<DiscountContainerCreateWithoutDiscountInput, DiscountContainerUncheckedCreateWithoutDiscountInput>
    connectOrCreate?: DiscountContainerCreateOrConnectWithoutDiscountInput
    connect?: DiscountContainerWhereUniqueInput
  }

  export type DiscountInContainerUncheckedCreateNestedOneWithoutDiscountInput = {
    create?: XOR<DiscountInContainerCreateWithoutDiscountInput, DiscountInContainerUncheckedCreateWithoutDiscountInput>
    connectOrCreate?: DiscountInContainerCreateOrConnectWithoutDiscountInput
    connect?: DiscountInContainerWhereUniqueInput
  }

  export type ShopUpdateOneRequiredWithoutDiscountsInput = {
    create?: XOR<ShopCreateWithoutDiscountsInput, ShopUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutDiscountsInput
    upsert?: ShopUpsertWithoutDiscountsInput
    connect?: ShopWhereUniqueInput
    update?: XOR<ShopUpdateWithoutDiscountsInput, ShopUncheckedUpdateWithoutDiscountsInput>
  }

  export type EnumDiscountKindsFieldUpdateOperationsInput = {
    set?: DiscountKinds
  }

  export type SimpleDiscountUpdateOneWithoutDiscountInput = {
    create?: XOR<SimpleDiscountCreateWithoutDiscountInput, SimpleDiscountUncheckedCreateWithoutDiscountInput>
    connectOrCreate?: SimpleDiscountCreateOrConnectWithoutDiscountInput
    upsert?: SimpleDiscountUpsertWithoutDiscountInput
    disconnect?: boolean
    delete?: boolean
    connect?: SimpleDiscountWhereUniqueInput
    update?: XOR<SimpleDiscountUpdateWithoutDiscountInput, SimpleDiscountUncheckedUpdateWithoutDiscountInput>
  }

  export type ConditionalDiscountUpdateOneWithoutDiscountInput = {
    create?: XOR<ConditionalDiscountCreateWithoutDiscountInput, ConditionalDiscountUncheckedCreateWithoutDiscountInput>
    connectOrCreate?: ConditionalDiscountCreateOrConnectWithoutDiscountInput
    upsert?: ConditionalDiscountUpsertWithoutDiscountInput
    disconnect?: boolean
    delete?: boolean
    connect?: ConditionalDiscountWhereUniqueInput
    update?: XOR<ConditionalDiscountUpdateWithoutDiscountInput, ConditionalDiscountUncheckedUpdateWithoutDiscountInput>
  }

  export type DiscountContainerUpdateOneWithoutDiscountInput = {
    create?: XOR<DiscountContainerCreateWithoutDiscountInput, DiscountContainerUncheckedCreateWithoutDiscountInput>
    connectOrCreate?: DiscountContainerCreateOrConnectWithoutDiscountInput
    upsert?: DiscountContainerUpsertWithoutDiscountInput
    disconnect?: boolean
    delete?: boolean
    connect?: DiscountContainerWhereUniqueInput
    update?: XOR<DiscountContainerUpdateWithoutDiscountInput, DiscountContainerUncheckedUpdateWithoutDiscountInput>
  }

  export type DiscountInContainerUpdateOneWithoutDiscountInput = {
    create?: XOR<DiscountInContainerCreateWithoutDiscountInput, DiscountInContainerUncheckedCreateWithoutDiscountInput>
    connectOrCreate?: DiscountInContainerCreateOrConnectWithoutDiscountInput
    upsert?: DiscountInContainerUpsertWithoutDiscountInput
    disconnect?: boolean
    delete?: boolean
    connect?: DiscountInContainerWhereUniqueInput
    update?: XOR<DiscountInContainerUpdateWithoutDiscountInput, DiscountInContainerUncheckedUpdateWithoutDiscountInput>
  }

  export type SimpleDiscountUncheckedUpdateOneWithoutDiscountInput = {
    create?: XOR<SimpleDiscountCreateWithoutDiscountInput, SimpleDiscountUncheckedCreateWithoutDiscountInput>
    connectOrCreate?: SimpleDiscountCreateOrConnectWithoutDiscountInput
    upsert?: SimpleDiscountUpsertWithoutDiscountInput
    disconnect?: boolean
    delete?: boolean
    connect?: SimpleDiscountWhereUniqueInput
    update?: XOR<SimpleDiscountUpdateWithoutDiscountInput, SimpleDiscountUncheckedUpdateWithoutDiscountInput>
  }

  export type ConditionalDiscountUncheckedUpdateOneWithoutDiscountInput = {
    create?: XOR<ConditionalDiscountCreateWithoutDiscountInput, ConditionalDiscountUncheckedCreateWithoutDiscountInput>
    connectOrCreate?: ConditionalDiscountCreateOrConnectWithoutDiscountInput
    upsert?: ConditionalDiscountUpsertWithoutDiscountInput
    disconnect?: boolean
    delete?: boolean
    connect?: ConditionalDiscountWhereUniqueInput
    update?: XOR<ConditionalDiscountUpdateWithoutDiscountInput, ConditionalDiscountUncheckedUpdateWithoutDiscountInput>
  }

  export type DiscountContainerUncheckedUpdateOneWithoutDiscountInput = {
    create?: XOR<DiscountContainerCreateWithoutDiscountInput, DiscountContainerUncheckedCreateWithoutDiscountInput>
    connectOrCreate?: DiscountContainerCreateOrConnectWithoutDiscountInput
    upsert?: DiscountContainerUpsertWithoutDiscountInput
    disconnect?: boolean
    delete?: boolean
    connect?: DiscountContainerWhereUniqueInput
    update?: XOR<DiscountContainerUpdateWithoutDiscountInput, DiscountContainerUncheckedUpdateWithoutDiscountInput>
  }

  export type DiscountInContainerUncheckedUpdateOneWithoutDiscountInput = {
    create?: XOR<DiscountInContainerCreateWithoutDiscountInput, DiscountInContainerUncheckedCreateWithoutDiscountInput>
    connectOrCreate?: DiscountInContainerCreateOrConnectWithoutDiscountInput
    upsert?: DiscountInContainerUpsertWithoutDiscountInput
    disconnect?: boolean
    delete?: boolean
    connect?: DiscountInContainerWhereUniqueInput
    update?: XOR<DiscountInContainerUpdateWithoutDiscountInput, DiscountInContainerUncheckedUpdateWithoutDiscountInput>
  }

  export type DiscountCreateNestedOneWithoutSimpleDiscountInput = {
    create?: XOR<DiscountCreateWithoutSimpleDiscountInput, DiscountUncheckedCreateWithoutSimpleDiscountInput>
    connectOrCreate?: DiscountCreateOrConnectWithoutSimpleDiscountInput
    connect?: DiscountWhereUniqueInput
  }

  export type ConditionalDiscountCreateNestedOneWithoutSimpleDiscountInput = {
    create?: XOR<ConditionalDiscountCreateWithoutSimpleDiscountInput, ConditionalDiscountUncheckedCreateWithoutSimpleDiscountInput>
    connectOrCreate?: ConditionalDiscountCreateOrConnectWithoutSimpleDiscountInput
    connect?: ConditionalDiscountWhereUniqueInput
  }

  export type ConditionalDiscountUncheckedCreateNestedOneWithoutSimpleDiscountInput = {
    create?: XOR<ConditionalDiscountCreateWithoutSimpleDiscountInput, ConditionalDiscountUncheckedCreateWithoutSimpleDiscountInput>
    connectOrCreate?: ConditionalDiscountCreateOrConnectWithoutSimpleDiscountInput
    connect?: ConditionalDiscountWhereUniqueInput
  }

  export type DiscountUpdateOneRequiredWithoutSimpleDiscountInput = {
    create?: XOR<DiscountCreateWithoutSimpleDiscountInput, DiscountUncheckedCreateWithoutSimpleDiscountInput>
    connectOrCreate?: DiscountCreateOrConnectWithoutSimpleDiscountInput
    upsert?: DiscountUpsertWithoutSimpleDiscountInput
    connect?: DiscountWhereUniqueInput
    update?: XOR<DiscountUpdateWithoutSimpleDiscountInput, DiscountUncheckedUpdateWithoutSimpleDiscountInput>
  }

  export type EnumDiscountTypeFieldUpdateOperationsInput = {
    set?: DiscountType
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumProductCategoryFieldUpdateOperationsInput = {
    set?: ProductCategory | null
  }

  export type ConditionalDiscountUpdateOneWithoutSimpleDiscountInput = {
    create?: XOR<ConditionalDiscountCreateWithoutSimpleDiscountInput, ConditionalDiscountUncheckedCreateWithoutSimpleDiscountInput>
    connectOrCreate?: ConditionalDiscountCreateOrConnectWithoutSimpleDiscountInput
    upsert?: ConditionalDiscountUpsertWithoutSimpleDiscountInput
    disconnect?: boolean
    delete?: boolean
    connect?: ConditionalDiscountWhereUniqueInput
    update?: XOR<ConditionalDiscountUpdateWithoutSimpleDiscountInput, ConditionalDiscountUncheckedUpdateWithoutSimpleDiscountInput>
  }

  export type ConditionalDiscountUncheckedUpdateOneWithoutSimpleDiscountInput = {
    create?: XOR<ConditionalDiscountCreateWithoutSimpleDiscountInput, ConditionalDiscountUncheckedCreateWithoutSimpleDiscountInput>
    connectOrCreate?: ConditionalDiscountCreateOrConnectWithoutSimpleDiscountInput
    upsert?: ConditionalDiscountUpsertWithoutSimpleDiscountInput
    disconnect?: boolean
    delete?: boolean
    connect?: ConditionalDiscountWhereUniqueInput
    update?: XOR<ConditionalDiscountUpdateWithoutSimpleDiscountInput, ConditionalDiscountUncheckedUpdateWithoutSimpleDiscountInput>
  }

  export type DiscountCreateNestedOneWithoutConditionalDiscountInput = {
    create?: XOR<DiscountCreateWithoutConditionalDiscountInput, DiscountUncheckedCreateWithoutConditionalDiscountInput>
    connectOrCreate?: DiscountCreateOrConnectWithoutConditionalDiscountInput
    connect?: DiscountWhereUniqueInput
  }

  export type SimpleDiscountCreateNestedOneWithoutConditionalDiscountInput = {
    create?: XOR<SimpleDiscountCreateWithoutConditionalDiscountInput, SimpleDiscountUncheckedCreateWithoutConditionalDiscountInput>
    connectOrCreate?: SimpleDiscountCreateOrConnectWithoutConditionalDiscountInput
    connect?: SimpleDiscountWhereUniqueInput
  }

  export type DiscountPredicateCreateNestedOneWithoutDiscountInput = {
    create?: XOR<DiscountPredicateCreateWithoutDiscountInput, DiscountPredicateUncheckedCreateWithoutDiscountInput>
    connectOrCreate?: DiscountPredicateCreateOrConnectWithoutDiscountInput
    connect?: DiscountPredicateWhereUniqueInput
  }

  export type DiscountPredicateUncheckedCreateNestedOneWithoutDiscountInput = {
    create?: XOR<DiscountPredicateCreateWithoutDiscountInput, DiscountPredicateUncheckedCreateWithoutDiscountInput>
    connectOrCreate?: DiscountPredicateCreateOrConnectWithoutDiscountInput
    connect?: DiscountPredicateWhereUniqueInput
  }

  export type DiscountUpdateOneRequiredWithoutConditionalDiscountInput = {
    create?: XOR<DiscountCreateWithoutConditionalDiscountInput, DiscountUncheckedCreateWithoutConditionalDiscountInput>
    connectOrCreate?: DiscountCreateOrConnectWithoutConditionalDiscountInput
    upsert?: DiscountUpsertWithoutConditionalDiscountInput
    connect?: DiscountWhereUniqueInput
    update?: XOR<DiscountUpdateWithoutConditionalDiscountInput, DiscountUncheckedUpdateWithoutConditionalDiscountInput>
  }

  export type SimpleDiscountUpdateOneRequiredWithoutConditionalDiscountInput = {
    create?: XOR<SimpleDiscountCreateWithoutConditionalDiscountInput, SimpleDiscountUncheckedCreateWithoutConditionalDiscountInput>
    connectOrCreate?: SimpleDiscountCreateOrConnectWithoutConditionalDiscountInput
    upsert?: SimpleDiscountUpsertWithoutConditionalDiscountInput
    connect?: SimpleDiscountWhereUniqueInput
    update?: XOR<SimpleDiscountUpdateWithoutConditionalDiscountInput, SimpleDiscountUncheckedUpdateWithoutConditionalDiscountInput>
  }

  export type DiscountPredicateUpdateOneWithoutDiscountInput = {
    create?: XOR<DiscountPredicateCreateWithoutDiscountInput, DiscountPredicateUncheckedCreateWithoutDiscountInput>
    connectOrCreate?: DiscountPredicateCreateOrConnectWithoutDiscountInput
    upsert?: DiscountPredicateUpsertWithoutDiscountInput
    disconnect?: boolean
    delete?: boolean
    connect?: DiscountPredicateWhereUniqueInput
    update?: XOR<DiscountPredicateUpdateWithoutDiscountInput, DiscountPredicateUncheckedUpdateWithoutDiscountInput>
  }

  export type DiscountPredicateUncheckedUpdateOneWithoutDiscountInput = {
    create?: XOR<DiscountPredicateCreateWithoutDiscountInput, DiscountPredicateUncheckedCreateWithoutDiscountInput>
    connectOrCreate?: DiscountPredicateCreateOrConnectWithoutDiscountInput
    upsert?: DiscountPredicateUpsertWithoutDiscountInput
    disconnect?: boolean
    delete?: boolean
    connect?: DiscountPredicateWhereUniqueInput
    update?: XOR<DiscountPredicateUpdateWithoutDiscountInput, DiscountPredicateUncheckedUpdateWithoutDiscountInput>
  }

  export type ConditionalDiscountCreateNestedOneWithoutDiscountPredicateInput = {
    create?: XOR<ConditionalDiscountCreateWithoutDiscountPredicateInput, ConditionalDiscountUncheckedCreateWithoutDiscountPredicateInput>
    connectOrCreate?: ConditionalDiscountCreateOrConnectWithoutDiscountPredicateInput
    connect?: ConditionalDiscountWhereUniqueInput
  }

  export type ConditionalDiscountUpdateOneRequiredWithoutDiscountPredicateInput = {
    create?: XOR<ConditionalDiscountCreateWithoutDiscountPredicateInput, ConditionalDiscountUncheckedCreateWithoutDiscountPredicateInput>
    connectOrCreate?: ConditionalDiscountCreateOrConnectWithoutDiscountPredicateInput
    upsert?: ConditionalDiscountUpsertWithoutDiscountPredicateInput
    connect?: ConditionalDiscountWhereUniqueInput
    update?: XOR<ConditionalDiscountUpdateWithoutDiscountPredicateInput, ConditionalDiscountUncheckedUpdateWithoutDiscountPredicateInput>
  }

  export type EnumRelationTypeFieldUpdateOperationsInput = {
    set?: RelationType
  }

  export type DiscountCreateNestedOneWithoutDiscountContainerInput = {
    create?: XOR<DiscountCreateWithoutDiscountContainerInput, DiscountUncheckedCreateWithoutDiscountContainerInput>
    connectOrCreate?: DiscountCreateOrConnectWithoutDiscountContainerInput
    connect?: DiscountWhereUniqueInput
  }

  export type DiscountInContainerCreateNestedManyWithoutDiscountContainerInput = {
    create?: XOR<Enumerable<DiscountInContainerCreateWithoutDiscountContainerInput>, Enumerable<DiscountInContainerUncheckedCreateWithoutDiscountContainerInput>>
    connectOrCreate?: Enumerable<DiscountInContainerCreateOrConnectWithoutDiscountContainerInput>
    createMany?: DiscountInContainerCreateManyDiscountContainerInputEnvelope
    connect?: Enumerable<DiscountInContainerWhereUniqueInput>
  }

  export type DiscountInContainerUncheckedCreateNestedManyWithoutDiscountContainerInput = {
    create?: XOR<Enumerable<DiscountInContainerCreateWithoutDiscountContainerInput>, Enumerable<DiscountInContainerUncheckedCreateWithoutDiscountContainerInput>>
    connectOrCreate?: Enumerable<DiscountInContainerCreateOrConnectWithoutDiscountContainerInput>
    createMany?: DiscountInContainerCreateManyDiscountContainerInputEnvelope
    connect?: Enumerable<DiscountInContainerWhereUniqueInput>
  }

  export type DiscountUpdateOneRequiredWithoutDiscountContainerInput = {
    create?: XOR<DiscountCreateWithoutDiscountContainerInput, DiscountUncheckedCreateWithoutDiscountContainerInput>
    connectOrCreate?: DiscountCreateOrConnectWithoutDiscountContainerInput
    upsert?: DiscountUpsertWithoutDiscountContainerInput
    connect?: DiscountWhereUniqueInput
    update?: XOR<DiscountUpdateWithoutDiscountContainerInput, DiscountUncheckedUpdateWithoutDiscountContainerInput>
  }

  export type EnumDiscountRelationFieldUpdateOperationsInput = {
    set?: DiscountRelation
  }

  export type DiscountInContainerUpdateManyWithoutDiscountContainerInput = {
    create?: XOR<Enumerable<DiscountInContainerCreateWithoutDiscountContainerInput>, Enumerable<DiscountInContainerUncheckedCreateWithoutDiscountContainerInput>>
    connectOrCreate?: Enumerable<DiscountInContainerCreateOrConnectWithoutDiscountContainerInput>
    upsert?: Enumerable<DiscountInContainerUpsertWithWhereUniqueWithoutDiscountContainerInput>
    createMany?: DiscountInContainerCreateManyDiscountContainerInputEnvelope
    set?: Enumerable<DiscountInContainerWhereUniqueInput>
    disconnect?: Enumerable<DiscountInContainerWhereUniqueInput>
    delete?: Enumerable<DiscountInContainerWhereUniqueInput>
    connect?: Enumerable<DiscountInContainerWhereUniqueInput>
    update?: Enumerable<DiscountInContainerUpdateWithWhereUniqueWithoutDiscountContainerInput>
    updateMany?: Enumerable<DiscountInContainerUpdateManyWithWhereWithoutDiscountContainerInput>
    deleteMany?: Enumerable<DiscountInContainerScalarWhereInput>
  }

  export type DiscountInContainerUncheckedUpdateManyWithoutDiscountContainerInput = {
    create?: XOR<Enumerable<DiscountInContainerCreateWithoutDiscountContainerInput>, Enumerable<DiscountInContainerUncheckedCreateWithoutDiscountContainerInput>>
    connectOrCreate?: Enumerable<DiscountInContainerCreateOrConnectWithoutDiscountContainerInput>
    upsert?: Enumerable<DiscountInContainerUpsertWithWhereUniqueWithoutDiscountContainerInput>
    createMany?: DiscountInContainerCreateManyDiscountContainerInputEnvelope
    set?: Enumerable<DiscountInContainerWhereUniqueInput>
    disconnect?: Enumerable<DiscountInContainerWhereUniqueInput>
    delete?: Enumerable<DiscountInContainerWhereUniqueInput>
    connect?: Enumerable<DiscountInContainerWhereUniqueInput>
    update?: Enumerable<DiscountInContainerUpdateWithWhereUniqueWithoutDiscountContainerInput>
    updateMany?: Enumerable<DiscountInContainerUpdateManyWithWhereWithoutDiscountContainerInput>
    deleteMany?: Enumerable<DiscountInContainerScalarWhereInput>
  }

  export type DiscountCreateNestedOneWithoutDiscountInContainerInput = {
    create?: XOR<DiscountCreateWithoutDiscountInContainerInput, DiscountUncheckedCreateWithoutDiscountInContainerInput>
    connectOrCreate?: DiscountCreateOrConnectWithoutDiscountInContainerInput
    connect?: DiscountWhereUniqueInput
  }

  export type DiscountContainerCreateNestedOneWithoutDiscountsInput = {
    create?: XOR<DiscountContainerCreateWithoutDiscountsInput, DiscountContainerUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: DiscountContainerCreateOrConnectWithoutDiscountsInput
    connect?: DiscountContainerWhereUniqueInput
  }

  export type DiscountUpdateOneRequiredWithoutDiscountInContainerInput = {
    create?: XOR<DiscountCreateWithoutDiscountInContainerInput, DiscountUncheckedCreateWithoutDiscountInContainerInput>
    connectOrCreate?: DiscountCreateOrConnectWithoutDiscountInContainerInput
    upsert?: DiscountUpsertWithoutDiscountInContainerInput
    connect?: DiscountWhereUniqueInput
    update?: XOR<DiscountUpdateWithoutDiscountInContainerInput, DiscountUncheckedUpdateWithoutDiscountInContainerInput>
  }

  export type DiscountContainerUpdateOneRequiredWithoutDiscountsInput = {
    create?: XOR<DiscountContainerCreateWithoutDiscountsInput, DiscountContainerUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: DiscountContainerCreateOrConnectWithoutDiscountsInput
    upsert?: DiscountContainerUpsertWithoutDiscountsInput
    connect?: DiscountContainerWhereUniqueInput
    update?: XOR<DiscountContainerUpdateWithoutDiscountsInput, DiscountContainerUncheckedUpdateWithoutDiscountsInput>
  }

  export type ShopCreateNestedOneWithoutPoliciesInput = {
    create?: XOR<ShopCreateWithoutPoliciesInput, ShopUncheckedCreateWithoutPoliciesInput>
    connectOrCreate?: ShopCreateOrConnectWithoutPoliciesInput
    connect?: ShopWhereUniqueInput
  }

  export type SimplePolicyCreateNestedOneWithoutPolicyInput = {
    create?: XOR<SimplePolicyCreateWithoutPolicyInput, SimplePolicyUncheckedCreateWithoutPolicyInput>
    connectOrCreate?: SimplePolicyCreateOrConnectWithoutPolicyInput
    connect?: SimplePolicyWhereUniqueInput
  }

  export type ConditionalPolicyCreateNestedOneWithoutPolicyInput = {
    create?: XOR<ConditionalPolicyCreateWithoutPolicyInput, ConditionalPolicyUncheckedCreateWithoutPolicyInput>
    connectOrCreate?: ConditionalPolicyCreateOrConnectWithoutPolicyInput
    connect?: ConditionalPolicyWhereUniqueInput
  }

  export type LogicalPolicyCreateNestedOneWithoutPolicyInput = {
    create?: XOR<LogicalPolicyCreateWithoutPolicyInput, LogicalPolicyUncheckedCreateWithoutPolicyInput>
    connectOrCreate?: LogicalPolicyCreateOrConnectWithoutPolicyInput
    connect?: LogicalPolicyWhereUniqueInput
  }

  export type PolicyInContainerCreateNestedOneWithoutPolicyInput = {
    create?: XOR<PolicyInContainerCreateWithoutPolicyInput, PolicyInContainerUncheckedCreateWithoutPolicyInput>
    connectOrCreate?: PolicyInContainerCreateOrConnectWithoutPolicyInput
    connect?: PolicyInContainerWhereUniqueInput
  }

  export type SimplePolicyUncheckedCreateNestedOneWithoutPolicyInput = {
    create?: XOR<SimplePolicyCreateWithoutPolicyInput, SimplePolicyUncheckedCreateWithoutPolicyInput>
    connectOrCreate?: SimplePolicyCreateOrConnectWithoutPolicyInput
    connect?: SimplePolicyWhereUniqueInput
  }

  export type ConditionalPolicyUncheckedCreateNestedOneWithoutPolicyInput = {
    create?: XOR<ConditionalPolicyCreateWithoutPolicyInput, ConditionalPolicyUncheckedCreateWithoutPolicyInput>
    connectOrCreate?: ConditionalPolicyCreateOrConnectWithoutPolicyInput
    connect?: ConditionalPolicyWhereUniqueInput
  }

  export type LogicalPolicyUncheckedCreateNestedOneWithoutPolicyInput = {
    create?: XOR<LogicalPolicyCreateWithoutPolicyInput, LogicalPolicyUncheckedCreateWithoutPolicyInput>
    connectOrCreate?: LogicalPolicyCreateOrConnectWithoutPolicyInput
    connect?: LogicalPolicyWhereUniqueInput
  }

  export type PolicyInContainerUncheckedCreateNestedOneWithoutPolicyInput = {
    create?: XOR<PolicyInContainerCreateWithoutPolicyInput, PolicyInContainerUncheckedCreateWithoutPolicyInput>
    connectOrCreate?: PolicyInContainerCreateOrConnectWithoutPolicyInput
    connect?: PolicyInContainerWhereUniqueInput
  }

  export type ShopUpdateOneRequiredWithoutPoliciesInput = {
    create?: XOR<ShopCreateWithoutPoliciesInput, ShopUncheckedCreateWithoutPoliciesInput>
    connectOrCreate?: ShopCreateOrConnectWithoutPoliciesInput
    upsert?: ShopUpsertWithoutPoliciesInput
    connect?: ShopWhereUniqueInput
    update?: XOR<ShopUpdateWithoutPoliciesInput, ShopUncheckedUpdateWithoutPoliciesInput>
  }

  export type SimplePolicyUpdateOneWithoutPolicyInput = {
    create?: XOR<SimplePolicyCreateWithoutPolicyInput, SimplePolicyUncheckedCreateWithoutPolicyInput>
    connectOrCreate?: SimplePolicyCreateOrConnectWithoutPolicyInput
    upsert?: SimplePolicyUpsertWithoutPolicyInput
    disconnect?: boolean
    delete?: boolean
    connect?: SimplePolicyWhereUniqueInput
    update?: XOR<SimplePolicyUpdateWithoutPolicyInput, SimplePolicyUncheckedUpdateWithoutPolicyInput>
  }

  export type ConditionalPolicyUpdateOneWithoutPolicyInput = {
    create?: XOR<ConditionalPolicyCreateWithoutPolicyInput, ConditionalPolicyUncheckedCreateWithoutPolicyInput>
    connectOrCreate?: ConditionalPolicyCreateOrConnectWithoutPolicyInput
    upsert?: ConditionalPolicyUpsertWithoutPolicyInput
    disconnect?: boolean
    delete?: boolean
    connect?: ConditionalPolicyWhereUniqueInput
    update?: XOR<ConditionalPolicyUpdateWithoutPolicyInput, ConditionalPolicyUncheckedUpdateWithoutPolicyInput>
  }

  export type LogicalPolicyUpdateOneWithoutPolicyInput = {
    create?: XOR<LogicalPolicyCreateWithoutPolicyInput, LogicalPolicyUncheckedCreateWithoutPolicyInput>
    connectOrCreate?: LogicalPolicyCreateOrConnectWithoutPolicyInput
    upsert?: LogicalPolicyUpsertWithoutPolicyInput
    disconnect?: boolean
    delete?: boolean
    connect?: LogicalPolicyWhereUniqueInput
    update?: XOR<LogicalPolicyUpdateWithoutPolicyInput, LogicalPolicyUncheckedUpdateWithoutPolicyInput>
  }

  export type PolicyInContainerUpdateOneWithoutPolicyInput = {
    create?: XOR<PolicyInContainerCreateWithoutPolicyInput, PolicyInContainerUncheckedCreateWithoutPolicyInput>
    connectOrCreate?: PolicyInContainerCreateOrConnectWithoutPolicyInput
    upsert?: PolicyInContainerUpsertWithoutPolicyInput
    disconnect?: boolean
    delete?: boolean
    connect?: PolicyInContainerWhereUniqueInput
    update?: XOR<PolicyInContainerUpdateWithoutPolicyInput, PolicyInContainerUncheckedUpdateWithoutPolicyInput>
  }

  export type SimplePolicyUncheckedUpdateOneWithoutPolicyInput = {
    create?: XOR<SimplePolicyCreateWithoutPolicyInput, SimplePolicyUncheckedCreateWithoutPolicyInput>
    connectOrCreate?: SimplePolicyCreateOrConnectWithoutPolicyInput
    upsert?: SimplePolicyUpsertWithoutPolicyInput
    disconnect?: boolean
    delete?: boolean
    connect?: SimplePolicyWhereUniqueInput
    update?: XOR<SimplePolicyUpdateWithoutPolicyInput, SimplePolicyUncheckedUpdateWithoutPolicyInput>
  }

  export type ConditionalPolicyUncheckedUpdateOneWithoutPolicyInput = {
    create?: XOR<ConditionalPolicyCreateWithoutPolicyInput, ConditionalPolicyUncheckedCreateWithoutPolicyInput>
    connectOrCreate?: ConditionalPolicyCreateOrConnectWithoutPolicyInput
    upsert?: ConditionalPolicyUpsertWithoutPolicyInput
    disconnect?: boolean
    delete?: boolean
    connect?: ConditionalPolicyWhereUniqueInput
    update?: XOR<ConditionalPolicyUpdateWithoutPolicyInput, ConditionalPolicyUncheckedUpdateWithoutPolicyInput>
  }

  export type LogicalPolicyUncheckedUpdateOneWithoutPolicyInput = {
    create?: XOR<LogicalPolicyCreateWithoutPolicyInput, LogicalPolicyUncheckedCreateWithoutPolicyInput>
    connectOrCreate?: LogicalPolicyCreateOrConnectWithoutPolicyInput
    upsert?: LogicalPolicyUpsertWithoutPolicyInput
    disconnect?: boolean
    delete?: boolean
    connect?: LogicalPolicyWhereUniqueInput
    update?: XOR<LogicalPolicyUpdateWithoutPolicyInput, LogicalPolicyUncheckedUpdateWithoutPolicyInput>
  }

  export type PolicyInContainerUncheckedUpdateOneWithoutPolicyInput = {
    create?: XOR<PolicyInContainerCreateWithoutPolicyInput, PolicyInContainerUncheckedCreateWithoutPolicyInput>
    connectOrCreate?: PolicyInContainerCreateOrConnectWithoutPolicyInput
    upsert?: PolicyInContainerUpsertWithoutPolicyInput
    disconnect?: boolean
    delete?: boolean
    connect?: PolicyInContainerWhereUniqueInput
    update?: XOR<PolicyInContainerUpdateWithoutPolicyInput, PolicyInContainerUncheckedUpdateWithoutPolicyInput>
  }

  export type PolicyCreateNestedOneWithoutSimplePolicyInput = {
    create?: XOR<PolicyCreateWithoutSimplePolicyInput, PolicyUncheckedCreateWithoutSimplePolicyInput>
    connectOrCreate?: PolicyCreateOrConnectWithoutSimplePolicyInput
    connect?: PolicyWhereUniqueInput
  }

  export type PolicyUpdateOneRequiredWithoutSimplePolicyInput = {
    create?: XOR<PolicyCreateWithoutSimplePolicyInput, PolicyUncheckedCreateWithoutSimplePolicyInput>
    connectOrCreate?: PolicyCreateOrConnectWithoutSimplePolicyInput
    upsert?: PolicyUpsertWithoutSimplePolicyInput
    connect?: PolicyWhereUniqueInput
    update?: XOR<PolicyUpdateWithoutSimplePolicyInput, PolicyUncheckedUpdateWithoutSimplePolicyInput>
  }

  export type PolicyCreateNestedOneWithoutConditionalPolicyInput = {
    create?: XOR<PolicyCreateWithoutConditionalPolicyInput, PolicyUncheckedCreateWithoutConditionalPolicyInput>
    connectOrCreate?: PolicyCreateOrConnectWithoutConditionalPolicyInput
    connect?: PolicyWhereUniqueInput
  }

  export type PolicyPredicateCreateNestedOneWithoutPolicyInput = {
    create?: XOR<PolicyPredicateCreateWithoutPolicyInput, PolicyPredicateUncheckedCreateWithoutPolicyInput>
    connectOrCreate?: PolicyPredicateCreateOrConnectWithoutPolicyInput
    connect?: PolicyPredicateWhereUniqueInput
  }

  export type PolicyPredicateUncheckedCreateNestedOneWithoutPolicyInput = {
    create?: XOR<PolicyPredicateCreateWithoutPolicyInput, PolicyPredicateUncheckedCreateWithoutPolicyInput>
    connectOrCreate?: PolicyPredicateCreateOrConnectWithoutPolicyInput
    connect?: PolicyPredicateWhereUniqueInput
  }

  export type PolicyUpdateOneRequiredWithoutConditionalPolicyInput = {
    create?: XOR<PolicyCreateWithoutConditionalPolicyInput, PolicyUncheckedCreateWithoutConditionalPolicyInput>
    connectOrCreate?: PolicyCreateOrConnectWithoutConditionalPolicyInput
    upsert?: PolicyUpsertWithoutConditionalPolicyInput
    connect?: PolicyWhereUniqueInput
    update?: XOR<PolicyUpdateWithoutConditionalPolicyInput, PolicyUncheckedUpdateWithoutConditionalPolicyInput>
  }

  export type PolicyPredicateUpdateOneWithoutPolicyInput = {
    create?: XOR<PolicyPredicateCreateWithoutPolicyInput, PolicyPredicateUncheckedCreateWithoutPolicyInput>
    connectOrCreate?: PolicyPredicateCreateOrConnectWithoutPolicyInput
    upsert?: PolicyPredicateUpsertWithoutPolicyInput
    disconnect?: boolean
    delete?: boolean
    connect?: PolicyPredicateWhereUniqueInput
    update?: XOR<PolicyPredicateUpdateWithoutPolicyInput, PolicyPredicateUncheckedUpdateWithoutPolicyInput>
  }

  export type PolicyPredicateUncheckedUpdateOneWithoutPolicyInput = {
    create?: XOR<PolicyPredicateCreateWithoutPolicyInput, PolicyPredicateUncheckedCreateWithoutPolicyInput>
    connectOrCreate?: PolicyPredicateCreateOrConnectWithoutPolicyInput
    upsert?: PolicyPredicateUpsertWithoutPolicyInput
    disconnect?: boolean
    delete?: boolean
    connect?: PolicyPredicateWhereUniqueInput
    update?: XOR<PolicyPredicateUpdateWithoutPolicyInput, PolicyPredicateUncheckedUpdateWithoutPolicyInput>
  }

  export type ConditionalPolicyCreateNestedOneWithoutPolicyPredicateInput = {
    create?: XOR<ConditionalPolicyCreateWithoutPolicyPredicateInput, ConditionalPolicyUncheckedCreateWithoutPolicyPredicateInput>
    connectOrCreate?: ConditionalPolicyCreateOrConnectWithoutPolicyPredicateInput
    connect?: ConditionalPolicyWhereUniqueInput
  }

  export type ConditionalPolicyUpdateOneRequiredWithoutPolicyPredicateInput = {
    create?: XOR<ConditionalPolicyCreateWithoutPolicyPredicateInput, ConditionalPolicyUncheckedCreateWithoutPolicyPredicateInput>
    connectOrCreate?: ConditionalPolicyCreateOrConnectWithoutPolicyPredicateInput
    upsert?: ConditionalPolicyUpsertWithoutPolicyPredicateInput
    connect?: ConditionalPolicyWhereUniqueInput
    update?: XOR<ConditionalPolicyUpdateWithoutPolicyPredicateInput, ConditionalPolicyUncheckedUpdateWithoutPolicyPredicateInput>
  }

  export type EnumSimplePolicyTypeFieldUpdateOperationsInput = {
    set?: SimplePolicyType
  }

  export type PolicyCreateNestedOneWithoutLogicalPolicyInput = {
    create?: XOR<PolicyCreateWithoutLogicalPolicyInput, PolicyUncheckedCreateWithoutLogicalPolicyInput>
    connectOrCreate?: PolicyCreateOrConnectWithoutLogicalPolicyInput
    connect?: PolicyWhereUniqueInput
  }

  export type PolicyInContainerCreateNestedManyWithoutPolicyContainerInput = {
    create?: XOR<Enumerable<PolicyInContainerCreateWithoutPolicyContainerInput>, Enumerable<PolicyInContainerUncheckedCreateWithoutPolicyContainerInput>>
    connectOrCreate?: Enumerable<PolicyInContainerCreateOrConnectWithoutPolicyContainerInput>
    createMany?: PolicyInContainerCreateManyPolicyContainerInputEnvelope
    connect?: Enumerable<PolicyInContainerWhereUniqueInput>
  }

  export type PolicyInContainerUncheckedCreateNestedManyWithoutPolicyContainerInput = {
    create?: XOR<Enumerable<PolicyInContainerCreateWithoutPolicyContainerInput>, Enumerable<PolicyInContainerUncheckedCreateWithoutPolicyContainerInput>>
    connectOrCreate?: Enumerable<PolicyInContainerCreateOrConnectWithoutPolicyContainerInput>
    createMany?: PolicyInContainerCreateManyPolicyContainerInputEnvelope
    connect?: Enumerable<PolicyInContainerWhereUniqueInput>
  }

  export type PolicyUpdateOneRequiredWithoutLogicalPolicyInput = {
    create?: XOR<PolicyCreateWithoutLogicalPolicyInput, PolicyUncheckedCreateWithoutLogicalPolicyInput>
    connectOrCreate?: PolicyCreateOrConnectWithoutLogicalPolicyInput
    upsert?: PolicyUpsertWithoutLogicalPolicyInput
    connect?: PolicyWhereUniqueInput
    update?: XOR<PolicyUpdateWithoutLogicalPolicyInput, PolicyUncheckedUpdateWithoutLogicalPolicyInput>
  }

  export type EnumPurchasePoliciesRelationFieldUpdateOperationsInput = {
    set?: PurchasePoliciesRelation
  }

  export type PolicyInContainerUpdateManyWithoutPolicyContainerInput = {
    create?: XOR<Enumerable<PolicyInContainerCreateWithoutPolicyContainerInput>, Enumerable<PolicyInContainerUncheckedCreateWithoutPolicyContainerInput>>
    connectOrCreate?: Enumerable<PolicyInContainerCreateOrConnectWithoutPolicyContainerInput>
    upsert?: Enumerable<PolicyInContainerUpsertWithWhereUniqueWithoutPolicyContainerInput>
    createMany?: PolicyInContainerCreateManyPolicyContainerInputEnvelope
    set?: Enumerable<PolicyInContainerWhereUniqueInput>
    disconnect?: Enumerable<PolicyInContainerWhereUniqueInput>
    delete?: Enumerable<PolicyInContainerWhereUniqueInput>
    connect?: Enumerable<PolicyInContainerWhereUniqueInput>
    update?: Enumerable<PolicyInContainerUpdateWithWhereUniqueWithoutPolicyContainerInput>
    updateMany?: Enumerable<PolicyInContainerUpdateManyWithWhereWithoutPolicyContainerInput>
    deleteMany?: Enumerable<PolicyInContainerScalarWhereInput>
  }

  export type PolicyInContainerUncheckedUpdateManyWithoutPolicyContainerInput = {
    create?: XOR<Enumerable<PolicyInContainerCreateWithoutPolicyContainerInput>, Enumerable<PolicyInContainerUncheckedCreateWithoutPolicyContainerInput>>
    connectOrCreate?: Enumerable<PolicyInContainerCreateOrConnectWithoutPolicyContainerInput>
    upsert?: Enumerable<PolicyInContainerUpsertWithWhereUniqueWithoutPolicyContainerInput>
    createMany?: PolicyInContainerCreateManyPolicyContainerInputEnvelope
    set?: Enumerable<PolicyInContainerWhereUniqueInput>
    disconnect?: Enumerable<PolicyInContainerWhereUniqueInput>
    delete?: Enumerable<PolicyInContainerWhereUniqueInput>
    connect?: Enumerable<PolicyInContainerWhereUniqueInput>
    update?: Enumerable<PolicyInContainerUpdateWithWhereUniqueWithoutPolicyContainerInput>
    updateMany?: Enumerable<PolicyInContainerUpdateManyWithWhereWithoutPolicyContainerInput>
    deleteMany?: Enumerable<PolicyInContainerScalarWhereInput>
  }

  export type PolicyCreateNestedOneWithoutPolicyInContainerInput = {
    create?: XOR<PolicyCreateWithoutPolicyInContainerInput, PolicyUncheckedCreateWithoutPolicyInContainerInput>
    connectOrCreate?: PolicyCreateOrConnectWithoutPolicyInContainerInput
    connect?: PolicyWhereUniqueInput
  }

  export type LogicalPolicyCreateNestedOneWithoutPoliciesInput = {
    create?: XOR<LogicalPolicyCreateWithoutPoliciesInput, LogicalPolicyUncheckedCreateWithoutPoliciesInput>
    connectOrCreate?: LogicalPolicyCreateOrConnectWithoutPoliciesInput
    connect?: LogicalPolicyWhereUniqueInput
  }

  export type PolicyUpdateOneRequiredWithoutPolicyInContainerInput = {
    create?: XOR<PolicyCreateWithoutPolicyInContainerInput, PolicyUncheckedCreateWithoutPolicyInContainerInput>
    connectOrCreate?: PolicyCreateOrConnectWithoutPolicyInContainerInput
    upsert?: PolicyUpsertWithoutPolicyInContainerInput
    connect?: PolicyWhereUniqueInput
    update?: XOR<PolicyUpdateWithoutPolicyInContainerInput, PolicyUncheckedUpdateWithoutPolicyInContainerInput>
  }

  export type LogicalPolicyUpdateOneRequiredWithoutPoliciesInput = {
    create?: XOR<LogicalPolicyCreateWithoutPoliciesInput, LogicalPolicyUncheckedCreateWithoutPoliciesInput>
    connectOrCreate?: LogicalPolicyCreateOrConnectWithoutPoliciesInput
    upsert?: LogicalPolicyUpsertWithoutPoliciesInput
    connect?: LogicalPolicyWhereUniqueInput
    update?: XOR<LogicalPolicyUpdateWithoutPoliciesInput, LogicalPolicyUncheckedUpdateWithoutPoliciesInput>
  }

  export type MemberCreateNestedOneWithoutOffersInput = {
    create?: XOR<MemberCreateWithoutOffersInput, MemberUncheckedCreateWithoutOffersInput>
    connectOrCreate?: MemberCreateOrConnectWithoutOffersInput
    connect?: MemberWhereUniqueInput
  }

  export type ShopCreateNestedOneWithoutOffersInput = {
    create?: XOR<ShopCreateWithoutOffersInput, ShopUncheckedCreateWithoutOffersInput>
    connectOrCreate?: ShopCreateOrConnectWithoutOffersInput
    connect?: ShopWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutOffersInput = {
    create?: XOR<ProductCreateWithoutOffersInput, ProductUncheckedCreateWithoutOffersInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOffersInput
    connect?: ProductWhereUniqueInput
  }

  export type OfferApproverCreateNestedManyWithoutOfferInput = {
    create?: XOR<Enumerable<OfferApproverCreateWithoutOfferInput>, Enumerable<OfferApproverUncheckedCreateWithoutOfferInput>>
    connectOrCreate?: Enumerable<OfferApproverCreateOrConnectWithoutOfferInput>
    createMany?: OfferApproverCreateManyOfferInputEnvelope
    connect?: Enumerable<OfferApproverWhereUniqueInput>
  }

  export type OfferApproverUncheckedCreateNestedManyWithoutOfferInput = {
    create?: XOR<Enumerable<OfferApproverCreateWithoutOfferInput>, Enumerable<OfferApproverUncheckedCreateWithoutOfferInput>>
    connectOrCreate?: Enumerable<OfferApproverCreateOrConnectWithoutOfferInput>
    createMany?: OfferApproverCreateManyOfferInputEnvelope
    connect?: Enumerable<OfferApproverWhereUniqueInput>
  }

  export type MemberUpdateOneRequiredWithoutOffersInput = {
    create?: XOR<MemberCreateWithoutOffersInput, MemberUncheckedCreateWithoutOffersInput>
    connectOrCreate?: MemberCreateOrConnectWithoutOffersInput
    upsert?: MemberUpsertWithoutOffersInput
    connect?: MemberWhereUniqueInput
    update?: XOR<MemberUpdateWithoutOffersInput, MemberUncheckedUpdateWithoutOffersInput>
  }

  export type ShopUpdateOneRequiredWithoutOffersInput = {
    create?: XOR<ShopCreateWithoutOffersInput, ShopUncheckedCreateWithoutOffersInput>
    connectOrCreate?: ShopCreateOrConnectWithoutOffersInput
    upsert?: ShopUpsertWithoutOffersInput
    connect?: ShopWhereUniqueInput
    update?: XOR<ShopUpdateWithoutOffersInput, ShopUncheckedUpdateWithoutOffersInput>
  }

  export type ProductUpdateOneRequiredWithoutOffersInput = {
    create?: XOR<ProductCreateWithoutOffersInput, ProductUncheckedCreateWithoutOffersInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOffersInput
    upsert?: ProductUpsertWithoutOffersInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutOffersInput, ProductUncheckedUpdateWithoutOffersInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OfferApproverUpdateManyWithoutOfferInput = {
    create?: XOR<Enumerable<OfferApproverCreateWithoutOfferInput>, Enumerable<OfferApproverUncheckedCreateWithoutOfferInput>>
    connectOrCreate?: Enumerable<OfferApproverCreateOrConnectWithoutOfferInput>
    upsert?: Enumerable<OfferApproverUpsertWithWhereUniqueWithoutOfferInput>
    createMany?: OfferApproverCreateManyOfferInputEnvelope
    set?: Enumerable<OfferApproverWhereUniqueInput>
    disconnect?: Enumerable<OfferApproverWhereUniqueInput>
    delete?: Enumerable<OfferApproverWhereUniqueInput>
    connect?: Enumerable<OfferApproverWhereUniqueInput>
    update?: Enumerable<OfferApproverUpdateWithWhereUniqueWithoutOfferInput>
    updateMany?: Enumerable<OfferApproverUpdateManyWithWhereWithoutOfferInput>
    deleteMany?: Enumerable<OfferApproverScalarWhereInput>
  }

  export type OfferApproverUncheckedUpdateManyWithoutOfferInput = {
    create?: XOR<Enumerable<OfferApproverCreateWithoutOfferInput>, Enumerable<OfferApproverUncheckedCreateWithoutOfferInput>>
    connectOrCreate?: Enumerable<OfferApproverCreateOrConnectWithoutOfferInput>
    upsert?: Enumerable<OfferApproverUpsertWithWhereUniqueWithoutOfferInput>
    createMany?: OfferApproverCreateManyOfferInputEnvelope
    set?: Enumerable<OfferApproverWhereUniqueInput>
    disconnect?: Enumerable<OfferApproverWhereUniqueInput>
    delete?: Enumerable<OfferApproverWhereUniqueInput>
    connect?: Enumerable<OfferApproverWhereUniqueInput>
    update?: Enumerable<OfferApproverUpdateWithWhereUniqueWithoutOfferInput>
    updateMany?: Enumerable<OfferApproverUpdateManyWithWhereWithoutOfferInput>
    deleteMany?: Enumerable<OfferApproverScalarWhereInput>
  }

  export type MemberCreateNestedOneWithoutOfferApproversInput = {
    create?: XOR<MemberCreateWithoutOfferApproversInput, MemberUncheckedCreateWithoutOfferApproversInput>
    connectOrCreate?: MemberCreateOrConnectWithoutOfferApproversInput
    connect?: MemberWhereUniqueInput
  }

  export type OfferCreateNestedOneWithoutOfferApproverInput = {
    create?: XOR<OfferCreateWithoutOfferApproverInput, OfferUncheckedCreateWithoutOfferApproverInput>
    connectOrCreate?: OfferCreateOrConnectWithoutOfferApproverInput
    connect?: OfferWhereUniqueInput
  }

  export type MemberUpdateOneRequiredWithoutOfferApproversInput = {
    create?: XOR<MemberCreateWithoutOfferApproversInput, MemberUncheckedCreateWithoutOfferApproversInput>
    connectOrCreate?: MemberCreateOrConnectWithoutOfferApproversInput
    upsert?: MemberUpsertWithoutOfferApproversInput
    connect?: MemberWhereUniqueInput
    update?: XOR<MemberUpdateWithoutOfferApproversInput, MemberUncheckedUpdateWithoutOfferApproversInput>
  }

  export type OfferUpdateOneRequiredWithoutOfferApproverInput = {
    create?: XOR<OfferCreateWithoutOfferApproverInput, OfferUncheckedCreateWithoutOfferApproverInput>
    connectOrCreate?: OfferCreateOrConnectWithoutOfferApproverInput
    upsert?: OfferUpsertWithoutOfferApproverInput
    connect?: OfferWhereUniqueInput
    update?: XOR<OfferUpdateWithoutOfferApproverInput, OfferUncheckedUpdateWithoutOfferApproverInput>
  }

  export type MemberCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<MemberCreateWithoutAppointmentsInput, MemberUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutAppointmentsInput
    connect?: MemberWhereUniqueInput
  }

  export type ShopCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<ShopCreateWithoutAppointmentsInput, ShopUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutAppointmentsInput
    connect?: ShopWhereUniqueInput
  }

  export type AppointmentAgreementCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<Enumerable<AppointmentAgreementCreateWithoutAppointmentInput>, Enumerable<AppointmentAgreementUncheckedCreateWithoutAppointmentInput>>
    connectOrCreate?: Enumerable<AppointmentAgreementCreateOrConnectWithoutAppointmentInput>
    createMany?: AppointmentAgreementCreateManyAppointmentInputEnvelope
    connect?: Enumerable<AppointmentAgreementWhereUniqueInput>
  }

  export type AppointmentAgreementUncheckedCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<Enumerable<AppointmentAgreementCreateWithoutAppointmentInput>, Enumerable<AppointmentAgreementUncheckedCreateWithoutAppointmentInput>>
    connectOrCreate?: Enumerable<AppointmentAgreementCreateOrConnectWithoutAppointmentInput>
    createMany?: AppointmentAgreementCreateManyAppointmentInputEnvelope
    connect?: Enumerable<AppointmentAgreementWhereUniqueInput>
  }

  export type MemberUpdateOneRequiredWithoutAppointmentsInput = {
    create?: XOR<MemberCreateWithoutAppointmentsInput, MemberUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutAppointmentsInput
    upsert?: MemberUpsertWithoutAppointmentsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<MemberUpdateWithoutAppointmentsInput, MemberUncheckedUpdateWithoutAppointmentsInput>
  }

  export type ShopUpdateOneRequiredWithoutAppointmentsInput = {
    create?: XOR<ShopCreateWithoutAppointmentsInput, ShopUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutAppointmentsInput
    upsert?: ShopUpsertWithoutAppointmentsInput
    connect?: ShopWhereUniqueInput
    update?: XOR<ShopUpdateWithoutAppointmentsInput, ShopUncheckedUpdateWithoutAppointmentsInput>
  }

  export type AppointmentAgreementUpdateManyWithoutAppointmentInput = {
    create?: XOR<Enumerable<AppointmentAgreementCreateWithoutAppointmentInput>, Enumerable<AppointmentAgreementUncheckedCreateWithoutAppointmentInput>>
    connectOrCreate?: Enumerable<AppointmentAgreementCreateOrConnectWithoutAppointmentInput>
    upsert?: Enumerable<AppointmentAgreementUpsertWithWhereUniqueWithoutAppointmentInput>
    createMany?: AppointmentAgreementCreateManyAppointmentInputEnvelope
    set?: Enumerable<AppointmentAgreementWhereUniqueInput>
    disconnect?: Enumerable<AppointmentAgreementWhereUniqueInput>
    delete?: Enumerable<AppointmentAgreementWhereUniqueInput>
    connect?: Enumerable<AppointmentAgreementWhereUniqueInput>
    update?: Enumerable<AppointmentAgreementUpdateWithWhereUniqueWithoutAppointmentInput>
    updateMany?: Enumerable<AppointmentAgreementUpdateManyWithWhereWithoutAppointmentInput>
    deleteMany?: Enumerable<AppointmentAgreementScalarWhereInput>
  }

  export type AppointmentAgreementUncheckedUpdateManyWithoutAppointmentInput = {
    create?: XOR<Enumerable<AppointmentAgreementCreateWithoutAppointmentInput>, Enumerable<AppointmentAgreementUncheckedCreateWithoutAppointmentInput>>
    connectOrCreate?: Enumerable<AppointmentAgreementCreateOrConnectWithoutAppointmentInput>
    upsert?: Enumerable<AppointmentAgreementUpsertWithWhereUniqueWithoutAppointmentInput>
    createMany?: AppointmentAgreementCreateManyAppointmentInputEnvelope
    set?: Enumerable<AppointmentAgreementWhereUniqueInput>
    disconnect?: Enumerable<AppointmentAgreementWhereUniqueInput>
    delete?: Enumerable<AppointmentAgreementWhereUniqueInput>
    connect?: Enumerable<AppointmentAgreementWhereUniqueInput>
    update?: Enumerable<AppointmentAgreementUpdateWithWhereUniqueWithoutAppointmentInput>
    updateMany?: Enumerable<AppointmentAgreementUpdateManyWithWhereWithoutAppointmentInput>
    deleteMany?: Enumerable<AppointmentAgreementScalarWhereInput>
  }

  export type AppointmentCreateNestedOneWithoutAppointmentAgreementsInput = {
    create?: XOR<AppointmentCreateWithoutAppointmentAgreementsInput, AppointmentUncheckedCreateWithoutAppointmentAgreementsInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutAppointmentAgreementsInput
    connect?: AppointmentWhereUniqueInput
  }

  export type AppointmentUpdateOneRequiredWithoutAppointmentAgreementsInput = {
    create?: XOR<AppointmentCreateWithoutAppointmentAgreementsInput, AppointmentUncheckedCreateWithoutAppointmentAgreementsInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutAppointmentAgreementsInput
    upsert?: AppointmentUpsertWithoutAppointmentAgreementsInput
    connect?: AppointmentWhereUniqueInput
    update?: XOR<AppointmentUpdateWithoutAppointmentAgreementsInput, AppointmentUncheckedUpdateWithoutAppointmentAgreementsInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedEnumJobTypeFilter = {
    equals?: JobType
    in?: Enumerable<JobType>
    notIn?: Enumerable<JobType>
    not?: NestedEnumJobTypeFilter | JobType
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedEnumJobTypeWithAggregatesFilter = {
    equals?: JobType
    in?: Enumerable<JobType>
    notIn?: Enumerable<JobType>
    not?: NestedEnumJobTypeWithAggregatesFilter | JobType
    _count?: NestedIntFilter
    _min?: NestedEnumJobTypeFilter
    _max?: NestedEnumJobTypeFilter
  }

  export type NestedEnumProductCategoryFilter = {
    equals?: ProductCategory
    in?: Enumerable<ProductCategory>
    notIn?: Enumerable<ProductCategory>
    not?: NestedEnumProductCategoryFilter | ProductCategory
  }

  export type NestedEnumProductRateFilter = {
    equals?: ProductRate
    in?: Enumerable<ProductRate>
    notIn?: Enumerable<ProductRate>
    not?: NestedEnumProductRateFilter | ProductRate
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedEnumProductCategoryWithAggregatesFilter = {
    equals?: ProductCategory
    in?: Enumerable<ProductCategory>
    notIn?: Enumerable<ProductCategory>
    not?: NestedEnumProductCategoryWithAggregatesFilter | ProductCategory
    _count?: NestedIntFilter
    _min?: NestedEnumProductCategoryFilter
    _max?: NestedEnumProductCategoryFilter
  }

  export type NestedEnumProductRateWithAggregatesFilter = {
    equals?: ProductRate
    in?: Enumerable<ProductRate>
    notIn?: Enumerable<ProductRate>
    not?: NestedEnumProductRateWithAggregatesFilter | ProductRate
    _count?: NestedIntFilter
    _min?: NestedEnumProductRateFilter
    _max?: NestedEnumProductRateFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedEnumShopStatusFilter = {
    equals?: ShopStatus
    in?: Enumerable<ShopStatus>
    notIn?: Enumerable<ShopStatus>
    not?: NestedEnumShopStatusFilter | ShopStatus
  }

  export type NestedEnumShopRateFilter = {
    equals?: ShopRate
    in?: Enumerable<ShopRate>
    notIn?: Enumerable<ShopRate>
    not?: NestedEnumShopRateFilter | ShopRate
  }

  export type NestedEnumShopStatusWithAggregatesFilter = {
    equals?: ShopStatus
    in?: Enumerable<ShopStatus>
    notIn?: Enumerable<ShopStatus>
    not?: NestedEnumShopStatusWithAggregatesFilter | ShopStatus
    _count?: NestedIntFilter
    _min?: NestedEnumShopStatusFilter
    _max?: NestedEnumShopStatusFilter
  }

  export type NestedEnumShopRateWithAggregatesFilter = {
    equals?: ShopRate
    in?: Enumerable<ShopRate>
    notIn?: Enumerable<ShopRate>
    not?: NestedEnumShopRateWithAggregatesFilter | ShopRate
    _count?: NestedIntFilter
    _min?: NestedEnumShopRateFilter
    _max?: NestedEnumShopRateFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedEnumMessageTypeFilter = {
    equals?: MessageType
    in?: Enumerable<MessageType>
    notIn?: Enumerable<MessageType>
    not?: NestedEnumMessageTypeFilter | MessageType
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedEnumMessageTypeWithAggregatesFilter = {
    equals?: MessageType
    in?: Enumerable<MessageType>
    notIn?: Enumerable<MessageType>
    not?: NestedEnumMessageTypeWithAggregatesFilter | MessageType
    _count?: NestedIntFilter
    _min?: NestedEnumMessageTypeFilter
    _max?: NestedEnumMessageTypeFilter
  }

  export type NestedEnumDiscountKindsFilter = {
    equals?: DiscountKinds
    in?: Enumerable<DiscountKinds>
    notIn?: Enumerable<DiscountKinds>
    not?: NestedEnumDiscountKindsFilter | DiscountKinds
  }

  export type NestedEnumDiscountKindsWithAggregatesFilter = {
    equals?: DiscountKinds
    in?: Enumerable<DiscountKinds>
    notIn?: Enumerable<DiscountKinds>
    not?: NestedEnumDiscountKindsWithAggregatesFilter | DiscountKinds
    _count?: NestedIntFilter
    _min?: NestedEnumDiscountKindsFilter
    _max?: NestedEnumDiscountKindsFilter
  }

  export type NestedEnumDiscountTypeFilter = {
    equals?: DiscountType
    in?: Enumerable<DiscountType>
    notIn?: Enumerable<DiscountType>
    not?: NestedEnumDiscountTypeFilter | DiscountType
  }

  export type NestedEnumProductCategoryNullableFilter = {
    equals?: ProductCategory | null
    in?: Enumerable<ProductCategory> | null
    notIn?: Enumerable<ProductCategory> | null
    not?: NestedEnumProductCategoryNullableFilter | ProductCategory | null
  }

  export type NestedEnumDiscountTypeWithAggregatesFilter = {
    equals?: DiscountType
    in?: Enumerable<DiscountType>
    notIn?: Enumerable<DiscountType>
    not?: NestedEnumDiscountTypeWithAggregatesFilter | DiscountType
    _count?: NestedIntFilter
    _min?: NestedEnumDiscountTypeFilter
    _max?: NestedEnumDiscountTypeFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedEnumProductCategoryNullableWithAggregatesFilter = {
    equals?: ProductCategory | null
    in?: Enumerable<ProductCategory> | null
    notIn?: Enumerable<ProductCategory> | null
    not?: NestedEnumProductCategoryNullableWithAggregatesFilter | ProductCategory | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumProductCategoryNullableFilter
    _max?: NestedEnumProductCategoryNullableFilter
  }

  export type NestedEnumRelationTypeFilter = {
    equals?: RelationType
    in?: Enumerable<RelationType>
    notIn?: Enumerable<RelationType>
    not?: NestedEnumRelationTypeFilter | RelationType
  }

  export type NestedEnumRelationTypeWithAggregatesFilter = {
    equals?: RelationType
    in?: Enumerable<RelationType>
    notIn?: Enumerable<RelationType>
    not?: NestedEnumRelationTypeWithAggregatesFilter | RelationType
    _count?: NestedIntFilter
    _min?: NestedEnumRelationTypeFilter
    _max?: NestedEnumRelationTypeFilter
  }

  export type NestedEnumDiscountRelationFilter = {
    equals?: DiscountRelation
    in?: Enumerable<DiscountRelation>
    notIn?: Enumerable<DiscountRelation>
    not?: NestedEnumDiscountRelationFilter | DiscountRelation
  }

  export type NestedEnumDiscountRelationWithAggregatesFilter = {
    equals?: DiscountRelation
    in?: Enumerable<DiscountRelation>
    notIn?: Enumerable<DiscountRelation>
    not?: NestedEnumDiscountRelationWithAggregatesFilter | DiscountRelation
    _count?: NestedIntFilter
    _min?: NestedEnumDiscountRelationFilter
    _max?: NestedEnumDiscountRelationFilter
  }

  export type NestedEnumSimplePolicyTypeFilter = {
    equals?: SimplePolicyType
    in?: Enumerable<SimplePolicyType>
    notIn?: Enumerable<SimplePolicyType>
    not?: NestedEnumSimplePolicyTypeFilter | SimplePolicyType
  }

  export type NestedEnumSimplePolicyTypeWithAggregatesFilter = {
    equals?: SimplePolicyType
    in?: Enumerable<SimplePolicyType>
    notIn?: Enumerable<SimplePolicyType>
    not?: NestedEnumSimplePolicyTypeWithAggregatesFilter | SimplePolicyType
    _count?: NestedIntFilter
    _min?: NestedEnumSimplePolicyTypeFilter
    _max?: NestedEnumSimplePolicyTypeFilter
  }

  export type NestedEnumPurchasePoliciesRelationFilter = {
    equals?: PurchasePoliciesRelation
    in?: Enumerable<PurchasePoliciesRelation>
    notIn?: Enumerable<PurchasePoliciesRelation>
    not?: NestedEnumPurchasePoliciesRelationFilter | PurchasePoliciesRelation
  }

  export type NestedEnumPurchasePoliciesRelationWithAggregatesFilter = {
    equals?: PurchasePoliciesRelation
    in?: Enumerable<PurchasePoliciesRelation>
    notIn?: Enumerable<PurchasePoliciesRelation>
    not?: NestedEnumPurchasePoliciesRelationWithAggregatesFilter | PurchasePoliciesRelation
    _count?: NestedIntFilter
    _min?: NestedEnumPurchasePoliciesRelationFilter
    _max?: NestedEnumPurchasePoliciesRelationFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type RoleCreateWithoutMemberInput = {
    shop: ShopCreateNestedOneWithoutRoleInput
    job_type: JobType
    permissions?: RoleCreatepermissionsInput | Enumerable<Permissions>
    shop_owners?: ShopOwnerCreateNestedManyWithoutRoleInput
    shop_managers?: ShopManagerCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutMemberInput = {
    shopId: number
    job_type: JobType
    permissions?: RoleCreatepermissionsInput | Enumerable<Permissions>
    shop_owners?: ShopOwnerUncheckedCreateNestedManyWithoutRoleInput
    shop_managers?: ShopManagerUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutMemberInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutMemberInput, RoleUncheckedCreateWithoutMemberInput>
  }

  export type RoleCreateManyMemberInputEnvelope = {
    data: Enumerable<RoleCreateManyMemberInput>
    skipDuplicates?: boolean
  }

  export type ShopCreateWithoutMemberInput = {
    id: number
    name: string
    status: ShopStatus
    rate?: ShopRate
    description?: string | null
    role?: RoleCreateNestedManyWithoutShopInput
    products?: ProductCreateNestedManyWithoutShopInput
    products_in_shop?: ProductInShopCreateNestedManyWithoutShopInput
    bags?: ShoppingBagCreateNestedManyWithoutShopInput
    discounts?: DiscountCreateNestedManyWithoutShopInput
    policies?: PolicyCreateNestedManyWithoutShopInput
    offers?: OfferCreateNestedManyWithoutShopInput
    appointments?: AppointmentCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutMemberInput = {
    id: number
    name: string
    status: ShopStatus
    rate?: ShopRate
    description?: string | null
    role?: RoleUncheckedCreateNestedManyWithoutShopInput
    products?: ProductUncheckedCreateNestedManyWithoutShopInput
    products_in_shop?: ProductInShopUncheckedCreateNestedManyWithoutShopInput
    bags?: ShoppingBagUncheckedCreateNestedManyWithoutShopInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutShopInput
    policies?: PolicyUncheckedCreateNestedManyWithoutShopInput
    offers?: OfferUncheckedCreateNestedManyWithoutShopInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutMemberInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutMemberInput, ShopUncheckedCreateWithoutMemberInput>
  }

  export type ShopCreateManyMemberInputEnvelope = {
    data: Enumerable<ShopCreateManyMemberInput>
    skipDuplicates?: boolean
  }

  export type ShoppingCartCreateWithoutMemberInput = {
    bags?: ShoppingBagCreateNestedManyWithoutShoppingCartInput
  }

  export type ShoppingCartUncheckedCreateWithoutMemberInput = {
    bags?: ShoppingBagUncheckedCreateNestedManyWithoutShoppingCartInput
  }

  export type ShoppingCartCreateOrConnectWithoutMemberInput = {
    where: ShoppingCartWhereUniqueInput
    create: XOR<ShoppingCartCreateWithoutMemberInput, ShoppingCartUncheckedCreateWithoutMemberInput>
  }

  export type MemberCredentialsCreateWithoutMemberInput = {
    password: string
  }

  export type MemberCredentialsUncheckedCreateWithoutMemberInput = {
    password: string
  }

  export type MemberCredentialsCreateOrConnectWithoutMemberInput = {
    where: MemberCredentialsWhereUniqueInput
    create: XOR<MemberCredentialsCreateWithoutMemberInput, MemberCredentialsUncheckedCreateWithoutMemberInput>
  }

  export type OfferCreateWithoutMemberInput = {
    id: number
    shop: ShopCreateNestedOneWithoutOffersInput
    product: ProductCreateNestedOneWithoutOffersInput
    price: number
    offerApprover?: OfferApproverCreateNestedManyWithoutOfferInput
  }

  export type OfferUncheckedCreateWithoutMemberInput = {
    id: number
    shopId: number
    productId: number
    price: number
    offerApprover?: OfferApproverUncheckedCreateNestedManyWithoutOfferInput
  }

  export type OfferCreateOrConnectWithoutMemberInput = {
    where: OfferWhereUniqueInput
    create: XOR<OfferCreateWithoutMemberInput, OfferUncheckedCreateWithoutMemberInput>
  }

  export type OfferCreateManyMemberInputEnvelope = {
    data: Enumerable<OfferCreateManyMemberInput>
    skipDuplicates?: boolean
  }

  export type OfferApproverCreateWithoutMemberInput = {
    offer: OfferCreateNestedOneWithoutOfferApproverInput
    answered?: boolean
    approved?: boolean
  }

  export type OfferApproverUncheckedCreateWithoutMemberInput = {
    offerId: number
    answered?: boolean
    approved?: boolean
  }

  export type OfferApproverCreateOrConnectWithoutMemberInput = {
    where: OfferApproverWhereUniqueInput
    create: XOR<OfferApproverCreateWithoutMemberInput, OfferApproverUncheckedCreateWithoutMemberInput>
  }

  export type OfferApproverCreateManyMemberInputEnvelope = {
    data: Enumerable<OfferApproverCreateManyMemberInput>
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutMemberInput = {
    shop: ShopCreateNestedOneWithoutAppointmentsInput
    assigner: string
    appointmentAgreements?: AppointmentAgreementCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutMemberInput = {
    shopId: number
    assigner: string
    appointmentAgreements?: AppointmentAgreementUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutMemberInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutMemberInput, AppointmentUncheckedCreateWithoutMemberInput>
  }

  export type AppointmentCreateManyMemberInputEnvelope = {
    data: Enumerable<AppointmentCreateManyMemberInput>
    skipDuplicates?: boolean
  }

  export type MessageRecipientsCreateWithoutMemberInput = {
    message: MessageCreateNestedOneWithoutRecipientsInput
  }

  export type MessageRecipientsUncheckedCreateWithoutMemberInput = {
    messageId: number
  }

  export type MessageRecipientsCreateOrConnectWithoutMemberInput = {
    where: MessageRecipientsWhereUniqueInput
    create: XOR<MessageRecipientsCreateWithoutMemberInput, MessageRecipientsUncheckedCreateWithoutMemberInput>
  }

  export type MessageRecipientsCreateManyMemberInputEnvelope = {
    data: Enumerable<MessageRecipientsCreateManyMemberInput>
    skipDuplicates?: boolean
  }

  export type RoleUpsertWithWhereUniqueWithoutMemberInput = {
    where: RoleWhereUniqueInput
    update: XOR<RoleUpdateWithoutMemberInput, RoleUncheckedUpdateWithoutMemberInput>
    create: XOR<RoleCreateWithoutMemberInput, RoleUncheckedCreateWithoutMemberInput>
  }

  export type RoleUpdateWithWhereUniqueWithoutMemberInput = {
    where: RoleWhereUniqueInput
    data: XOR<RoleUpdateWithoutMemberInput, RoleUncheckedUpdateWithoutMemberInput>
  }

  export type RoleUpdateManyWithWhereWithoutMemberInput = {
    where: RoleScalarWhereInput
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutRolesInput>
  }

  export type RoleScalarWhereInput = {
    AND?: Enumerable<RoleScalarWhereInput>
    OR?: Enumerable<RoleScalarWhereInput>
    NOT?: Enumerable<RoleScalarWhereInput>
    username?: StringFilter | string
    shopId?: IntFilter | number
    job_type?: EnumJobTypeFilter | JobType
    permissions?: EnumPermissionsNullableListFilter
  }

  export type ShopUpsertWithWhereUniqueWithoutMemberInput = {
    where: ShopWhereUniqueInput
    update: XOR<ShopUpdateWithoutMemberInput, ShopUncheckedUpdateWithoutMemberInput>
    create: XOR<ShopCreateWithoutMemberInput, ShopUncheckedCreateWithoutMemberInput>
  }

  export type ShopUpdateWithWhereUniqueWithoutMemberInput = {
    where: ShopWhereUniqueInput
    data: XOR<ShopUpdateWithoutMemberInput, ShopUncheckedUpdateWithoutMemberInput>
  }

  export type ShopUpdateManyWithWhereWithoutMemberInput = {
    where: ShopScalarWhereInput
    data: XOR<ShopUpdateManyMutationInput, ShopUncheckedUpdateManyWithoutShopsInput>
  }

  export type ShopScalarWhereInput = {
    AND?: Enumerable<ShopScalarWhereInput>
    OR?: Enumerable<ShopScalarWhereInput>
    NOT?: Enumerable<ShopScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    status?: EnumShopStatusFilter | ShopStatus
    shop_founder?: StringFilter | string
    rate?: EnumShopRateFilter | ShopRate
    description?: StringNullableFilter | string | null
  }

  export type ShoppingCartUpsertWithoutMemberInput = {
    update: XOR<ShoppingCartUpdateWithoutMemberInput, ShoppingCartUncheckedUpdateWithoutMemberInput>
    create: XOR<ShoppingCartCreateWithoutMemberInput, ShoppingCartUncheckedCreateWithoutMemberInput>
  }

  export type ShoppingCartUpdateWithoutMemberInput = {
    bags?: ShoppingBagUpdateManyWithoutShoppingCartInput
  }

  export type ShoppingCartUncheckedUpdateWithoutMemberInput = {
    bags?: ShoppingBagUncheckedUpdateManyWithoutShoppingCartInput
  }

  export type MemberCredentialsUpsertWithoutMemberInput = {
    update: XOR<MemberCredentialsUpdateWithoutMemberInput, MemberCredentialsUncheckedUpdateWithoutMemberInput>
    create: XOR<MemberCredentialsCreateWithoutMemberInput, MemberCredentialsUncheckedCreateWithoutMemberInput>
  }

  export type MemberCredentialsUpdateWithoutMemberInput = {
    password?: StringFieldUpdateOperationsInput | string
  }

  export type MemberCredentialsUncheckedUpdateWithoutMemberInput = {
    password?: StringFieldUpdateOperationsInput | string
  }

  export type OfferUpsertWithWhereUniqueWithoutMemberInput = {
    where: OfferWhereUniqueInput
    update: XOR<OfferUpdateWithoutMemberInput, OfferUncheckedUpdateWithoutMemberInput>
    create: XOR<OfferCreateWithoutMemberInput, OfferUncheckedCreateWithoutMemberInput>
  }

  export type OfferUpdateWithWhereUniqueWithoutMemberInput = {
    where: OfferWhereUniqueInput
    data: XOR<OfferUpdateWithoutMemberInput, OfferUncheckedUpdateWithoutMemberInput>
  }

  export type OfferUpdateManyWithWhereWithoutMemberInput = {
    where: OfferScalarWhereInput
    data: XOR<OfferUpdateManyMutationInput, OfferUncheckedUpdateManyWithoutOffersInput>
  }

  export type OfferScalarWhereInput = {
    AND?: Enumerable<OfferScalarWhereInput>
    OR?: Enumerable<OfferScalarWhereInput>
    NOT?: Enumerable<OfferScalarWhereInput>
    id?: IntFilter | number
    username?: StringFilter | string
    shopId?: IntFilter | number
    productId?: IntFilter | number
    price?: FloatFilter | number
  }

  export type OfferApproverUpsertWithWhereUniqueWithoutMemberInput = {
    where: OfferApproverWhereUniqueInput
    update: XOR<OfferApproverUpdateWithoutMemberInput, OfferApproverUncheckedUpdateWithoutMemberInput>
    create: XOR<OfferApproverCreateWithoutMemberInput, OfferApproverUncheckedCreateWithoutMemberInput>
  }

  export type OfferApproverUpdateWithWhereUniqueWithoutMemberInput = {
    where: OfferApproverWhereUniqueInput
    data: XOR<OfferApproverUpdateWithoutMemberInput, OfferApproverUncheckedUpdateWithoutMemberInput>
  }

  export type OfferApproverUpdateManyWithWhereWithoutMemberInput = {
    where: OfferApproverScalarWhereInput
    data: XOR<OfferApproverUpdateManyMutationInput, OfferApproverUncheckedUpdateManyWithoutOfferApproversInput>
  }

  export type OfferApproverScalarWhereInput = {
    AND?: Enumerable<OfferApproverScalarWhereInput>
    OR?: Enumerable<OfferApproverScalarWhereInput>
    NOT?: Enumerable<OfferApproverScalarWhereInput>
    username?: StringFilter | string
    offerId?: IntFilter | number
    answered?: BoolFilter | boolean
    approved?: BoolFilter | boolean
  }

  export type AppointmentUpsertWithWhereUniqueWithoutMemberInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutMemberInput, AppointmentUncheckedUpdateWithoutMemberInput>
    create: XOR<AppointmentCreateWithoutMemberInput, AppointmentUncheckedCreateWithoutMemberInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutMemberInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutMemberInput, AppointmentUncheckedUpdateWithoutMemberInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutMemberInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutAppointmentsInput>
  }

  export type AppointmentScalarWhereInput = {
    AND?: Enumerable<AppointmentScalarWhereInput>
    OR?: Enumerable<AppointmentScalarWhereInput>
    NOT?: Enumerable<AppointmentScalarWhereInput>
    username?: StringFilter | string
    shopId?: IntFilter | number
    assigner?: StringFilter | string
  }

  export type MessageRecipientsUpsertWithWhereUniqueWithoutMemberInput = {
    where: MessageRecipientsWhereUniqueInput
    update: XOR<MessageRecipientsUpdateWithoutMemberInput, MessageRecipientsUncheckedUpdateWithoutMemberInput>
    create: XOR<MessageRecipientsCreateWithoutMemberInput, MessageRecipientsUncheckedCreateWithoutMemberInput>
  }

  export type MessageRecipientsUpdateWithWhereUniqueWithoutMemberInput = {
    where: MessageRecipientsWhereUniqueInput
    data: XOR<MessageRecipientsUpdateWithoutMemberInput, MessageRecipientsUncheckedUpdateWithoutMemberInput>
  }

  export type MessageRecipientsUpdateManyWithWhereWithoutMemberInput = {
    where: MessageRecipientsScalarWhereInput
    data: XOR<MessageRecipientsUpdateManyMutationInput, MessageRecipientsUncheckedUpdateManyWithoutMessageRecipientsInput>
  }

  export type MessageRecipientsScalarWhereInput = {
    AND?: Enumerable<MessageRecipientsScalarWhereInput>
    OR?: Enumerable<MessageRecipientsScalarWhereInput>
    NOT?: Enumerable<MessageRecipientsScalarWhereInput>
    messageId?: IntFilter | number
    username?: StringFilter | string
  }

  export type MemberCreateWithoutRolesInput = {
    username: string
    shops?: ShopCreateNestedManyWithoutMemberInput
    ShoppingCart?: ShoppingCartCreateNestedOneWithoutMemberInput
    MemberCredentials?: MemberCredentialsCreateNestedOneWithoutMemberInput
    offers?: OfferCreateNestedManyWithoutMemberInput
    offerApprovers?: OfferApproverCreateNestedManyWithoutMemberInput
    appointments?: AppointmentCreateNestedManyWithoutMemberInput
    messageRecipients?: MessageRecipientsCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutRolesInput = {
    username: string
    shops?: ShopUncheckedCreateNestedManyWithoutMemberInput
    ShoppingCart?: ShoppingCartUncheckedCreateNestedOneWithoutMemberInput
    MemberCredentials?: MemberCredentialsUncheckedCreateNestedOneWithoutMemberInput
    offers?: OfferUncheckedCreateNestedManyWithoutMemberInput
    offerApprovers?: OfferApproverUncheckedCreateNestedManyWithoutMemberInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutMemberInput
    messageRecipients?: MessageRecipientsUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutRolesInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutRolesInput, MemberUncheckedCreateWithoutRolesInput>
  }

  export type ShopCreateWithoutRoleInput = {
    id: number
    name: string
    status: ShopStatus
    member: MemberCreateNestedOneWithoutShopsInput
    rate?: ShopRate
    description?: string | null
    products?: ProductCreateNestedManyWithoutShopInput
    products_in_shop?: ProductInShopCreateNestedManyWithoutShopInput
    bags?: ShoppingBagCreateNestedManyWithoutShopInput
    discounts?: DiscountCreateNestedManyWithoutShopInput
    policies?: PolicyCreateNestedManyWithoutShopInput
    offers?: OfferCreateNestedManyWithoutShopInput
    appointments?: AppointmentCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutRoleInput = {
    id: number
    name: string
    status: ShopStatus
    shop_founder: string
    rate?: ShopRate
    description?: string | null
    products?: ProductUncheckedCreateNestedManyWithoutShopInput
    products_in_shop?: ProductInShopUncheckedCreateNestedManyWithoutShopInput
    bags?: ShoppingBagUncheckedCreateNestedManyWithoutShopInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutShopInput
    policies?: PolicyUncheckedCreateNestedManyWithoutShopInput
    offers?: OfferUncheckedCreateNestedManyWithoutShopInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutRoleInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutRoleInput, ShopUncheckedCreateWithoutRoleInput>
  }

  export type ShopOwnerCreateWithoutRoleInput = {

  }

  export type ShopOwnerUncheckedCreateWithoutRoleInput = {

  }

  export type ShopOwnerCreateOrConnectWithoutRoleInput = {
    where: ShopOwnerWhereUniqueInput
    create: XOR<ShopOwnerCreateWithoutRoleInput, ShopOwnerUncheckedCreateWithoutRoleInput>
  }

  export type ShopOwnerCreateManyRoleInputEnvelope = {
    data: Enumerable<ShopOwnerCreateManyRoleInput>
    skipDuplicates?: boolean
  }

  export type ShopManagerCreateWithoutRoleInput = {

  }

  export type ShopManagerUncheckedCreateWithoutRoleInput = {

  }

  export type ShopManagerCreateOrConnectWithoutRoleInput = {
    where: ShopManagerWhereUniqueInput
    create: XOR<ShopManagerCreateWithoutRoleInput, ShopManagerUncheckedCreateWithoutRoleInput>
  }

  export type ShopManagerCreateManyRoleInputEnvelope = {
    data: Enumerable<ShopManagerCreateManyRoleInput>
    skipDuplicates?: boolean
  }

  export type MemberUpsertWithoutRolesInput = {
    update: XOR<MemberUpdateWithoutRolesInput, MemberUncheckedUpdateWithoutRolesInput>
    create: XOR<MemberCreateWithoutRolesInput, MemberUncheckedCreateWithoutRolesInput>
  }

  export type MemberUpdateWithoutRolesInput = {
    username?: StringFieldUpdateOperationsInput | string
    shops?: ShopUpdateManyWithoutMemberInput
    ShoppingCart?: ShoppingCartUpdateOneWithoutMemberInput
    MemberCredentials?: MemberCredentialsUpdateOneWithoutMemberInput
    offers?: OfferUpdateManyWithoutMemberInput
    offerApprovers?: OfferApproverUpdateManyWithoutMemberInput
    appointments?: AppointmentUpdateManyWithoutMemberInput
    messageRecipients?: MessageRecipientsUpdateManyWithoutMemberInput
  }

  export type MemberUncheckedUpdateWithoutRolesInput = {
    username?: StringFieldUpdateOperationsInput | string
    shops?: ShopUncheckedUpdateManyWithoutMemberInput
    ShoppingCart?: ShoppingCartUncheckedUpdateOneWithoutMemberInput
    MemberCredentials?: MemberCredentialsUncheckedUpdateOneWithoutMemberInput
    offers?: OfferUncheckedUpdateManyWithoutMemberInput
    offerApprovers?: OfferApproverUncheckedUpdateManyWithoutMemberInput
    appointments?: AppointmentUncheckedUpdateManyWithoutMemberInput
    messageRecipients?: MessageRecipientsUncheckedUpdateManyWithoutMemberInput
  }

  export type ShopUpsertWithoutRoleInput = {
    update: XOR<ShopUpdateWithoutRoleInput, ShopUncheckedUpdateWithoutRoleInput>
    create: XOR<ShopCreateWithoutRoleInput, ShopUncheckedCreateWithoutRoleInput>
  }

  export type ShopUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | ShopStatus
    member?: MemberUpdateOneRequiredWithoutShopsInput
    rate?: EnumShopRateFieldUpdateOperationsInput | ShopRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUpdateManyWithoutShopInput
    products_in_shop?: ProductInShopUpdateManyWithoutShopInput
    bags?: ShoppingBagUpdateManyWithoutShopInput
    discounts?: DiscountUpdateManyWithoutShopInput
    policies?: PolicyUpdateManyWithoutShopInput
    offers?: OfferUpdateManyWithoutShopInput
    appointments?: AppointmentUpdateManyWithoutShopInput
  }

  export type ShopUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | ShopStatus
    shop_founder?: StringFieldUpdateOperationsInput | string
    rate?: EnumShopRateFieldUpdateOperationsInput | ShopRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUncheckedUpdateManyWithoutShopInput
    products_in_shop?: ProductInShopUncheckedUpdateManyWithoutShopInput
    bags?: ShoppingBagUncheckedUpdateManyWithoutShopInput
    discounts?: DiscountUncheckedUpdateManyWithoutShopInput
    policies?: PolicyUncheckedUpdateManyWithoutShopInput
    offers?: OfferUncheckedUpdateManyWithoutShopInput
    appointments?: AppointmentUncheckedUpdateManyWithoutShopInput
  }

  export type ShopOwnerUpdateWithWhereUniqueWithoutRoleInput = {
    where: ShopOwnerWhereUniqueInput
    data: XOR<ShopOwnerUpdateWithoutRoleInput, ShopOwnerUncheckedUpdateWithoutRoleInput>
  }

  export type ShopOwnerUpdateManyWithWhereWithoutRoleInput = {
    where: ShopOwnerScalarWhereInput
    data: XOR<ShopOwnerUpdateManyMutationInput, ShopOwnerUncheckedUpdateManyWithoutShop_ownersInput>
  }

  export type ShopOwnerScalarWhereInput = {
    AND?: Enumerable<ShopOwnerScalarWhereInput>
    OR?: Enumerable<ShopOwnerScalarWhereInput>
    NOT?: Enumerable<ShopOwnerScalarWhereInput>
    username?: StringFilter | string
    shopId?: IntFilter | number
  }

  export type ShopManagerUpdateWithWhereUniqueWithoutRoleInput = {
    where: ShopManagerWhereUniqueInput
    data: XOR<ShopManagerUpdateWithoutRoleInput, ShopManagerUncheckedUpdateWithoutRoleInput>
  }

  export type ShopManagerUpdateManyWithWhereWithoutRoleInput = {
    where: ShopManagerScalarWhereInput
    data: XOR<ShopManagerUpdateManyMutationInput, ShopManagerUncheckedUpdateManyWithoutShop_managersInput>
  }

  export type ShopManagerScalarWhereInput = {
    AND?: Enumerable<ShopManagerScalarWhereInput>
    OR?: Enumerable<ShopManagerScalarWhereInput>
    NOT?: Enumerable<ShopManagerScalarWhereInput>
    username?: StringFilter | string
    shopId?: IntFilter | number
  }

  export type ShopCreateWithoutProductsInput = {
    id: number
    name: string
    status: ShopStatus
    member: MemberCreateNestedOneWithoutShopsInput
    rate?: ShopRate
    description?: string | null
    role?: RoleCreateNestedManyWithoutShopInput
    products_in_shop?: ProductInShopCreateNestedManyWithoutShopInput
    bags?: ShoppingBagCreateNestedManyWithoutShopInput
    discounts?: DiscountCreateNestedManyWithoutShopInput
    policies?: PolicyCreateNestedManyWithoutShopInput
    offers?: OfferCreateNestedManyWithoutShopInput
    appointments?: AppointmentCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutProductsInput = {
    id: number
    name: string
    status: ShopStatus
    shop_founder: string
    rate?: ShopRate
    description?: string | null
    role?: RoleUncheckedCreateNestedManyWithoutShopInput
    products_in_shop?: ProductInShopUncheckedCreateNestedManyWithoutShopInput
    bags?: ShoppingBagUncheckedCreateNestedManyWithoutShopInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutShopInput
    policies?: PolicyUncheckedCreateNestedManyWithoutShopInput
    offers?: OfferUncheckedCreateNestedManyWithoutShopInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutProductsInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutProductsInput, ShopUncheckedCreateWithoutProductsInput>
  }

  export type ProductInShopCreateWithoutProductInput = {
    shop: ShopCreateNestedOneWithoutProducts_in_shopInput
    product_quantity?: number
  }

  export type ProductInShopUncheckedCreateWithoutProductInput = {
    shopId: number
    product_quantity?: number
  }

  export type ProductInShopCreateOrConnectWithoutProductInput = {
    where: ProductInShopWhereUniqueInput
    create: XOR<ProductInShopCreateWithoutProductInput, ProductInShopUncheckedCreateWithoutProductInput>
  }

  export type ProductInShopCreateManyProductInputEnvelope = {
    data: Enumerable<ProductInShopCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type ProductInBagCreateWithoutProductInput = {
    shoppingBag: ShoppingBagCreateNestedOneWithoutProducts_in_bagInput
    product_quantity?: number
  }

  export type ProductInBagUncheckedCreateWithoutProductInput = {
    username: string
    shopId: number
    product_quantity?: number
  }

  export type ProductInBagCreateOrConnectWithoutProductInput = {
    where: ProductInBagWhereUniqueInput
    create: XOR<ProductInBagCreateWithoutProductInput, ProductInBagUncheckedCreateWithoutProductInput>
  }

  export type ProductInBagCreateManyProductInputEnvelope = {
    data: Enumerable<ProductInBagCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type OfferCreateWithoutProductInput = {
    id: number
    member: MemberCreateNestedOneWithoutOffersInput
    shop: ShopCreateNestedOneWithoutOffersInput
    price: number
    offerApprover?: OfferApproverCreateNestedManyWithoutOfferInput
  }

  export type OfferUncheckedCreateWithoutProductInput = {
    id: number
    username: string
    shopId: number
    price: number
    offerApprover?: OfferApproverUncheckedCreateNestedManyWithoutOfferInput
  }

  export type OfferCreateOrConnectWithoutProductInput = {
    where: OfferWhereUniqueInput
    create: XOR<OfferCreateWithoutProductInput, OfferUncheckedCreateWithoutProductInput>
  }

  export type OfferCreateManyProductInputEnvelope = {
    data: Enumerable<OfferCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type ShopUpsertWithoutProductsInput = {
    update: XOR<ShopUpdateWithoutProductsInput, ShopUncheckedUpdateWithoutProductsInput>
    create: XOR<ShopCreateWithoutProductsInput, ShopUncheckedCreateWithoutProductsInput>
  }

  export type ShopUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | ShopStatus
    member?: MemberUpdateOneRequiredWithoutShopsInput
    rate?: EnumShopRateFieldUpdateOperationsInput | ShopRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
    role?: RoleUpdateManyWithoutShopInput
    products_in_shop?: ProductInShopUpdateManyWithoutShopInput
    bags?: ShoppingBagUpdateManyWithoutShopInput
    discounts?: DiscountUpdateManyWithoutShopInput
    policies?: PolicyUpdateManyWithoutShopInput
    offers?: OfferUpdateManyWithoutShopInput
    appointments?: AppointmentUpdateManyWithoutShopInput
  }

  export type ShopUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | ShopStatus
    shop_founder?: StringFieldUpdateOperationsInput | string
    rate?: EnumShopRateFieldUpdateOperationsInput | ShopRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
    role?: RoleUncheckedUpdateManyWithoutShopInput
    products_in_shop?: ProductInShopUncheckedUpdateManyWithoutShopInput
    bags?: ShoppingBagUncheckedUpdateManyWithoutShopInput
    discounts?: DiscountUncheckedUpdateManyWithoutShopInput
    policies?: PolicyUncheckedUpdateManyWithoutShopInput
    offers?: OfferUncheckedUpdateManyWithoutShopInput
    appointments?: AppointmentUncheckedUpdateManyWithoutShopInput
  }

  export type ProductInShopUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductInShopWhereUniqueInput
    update: XOR<ProductInShopUpdateWithoutProductInput, ProductInShopUncheckedUpdateWithoutProductInput>
    create: XOR<ProductInShopCreateWithoutProductInput, ProductInShopUncheckedCreateWithoutProductInput>
  }

  export type ProductInShopUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductInShopWhereUniqueInput
    data: XOR<ProductInShopUpdateWithoutProductInput, ProductInShopUncheckedUpdateWithoutProductInput>
  }

  export type ProductInShopUpdateManyWithWhereWithoutProductInput = {
    where: ProductInShopScalarWhereInput
    data: XOR<ProductInShopUpdateManyMutationInput, ProductInShopUncheckedUpdateManyWithoutProducts_in_shopInput>
  }

  export type ProductInShopScalarWhereInput = {
    AND?: Enumerable<ProductInShopScalarWhereInput>
    OR?: Enumerable<ProductInShopScalarWhereInput>
    NOT?: Enumerable<ProductInShopScalarWhereInput>
    shopId?: IntFilter | number
    productId?: IntFilter | number
    product_quantity?: IntFilter | number
  }

  export type ProductInBagUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductInBagWhereUniqueInput
    update: XOR<ProductInBagUpdateWithoutProductInput, ProductInBagUncheckedUpdateWithoutProductInput>
    create: XOR<ProductInBagCreateWithoutProductInput, ProductInBagUncheckedCreateWithoutProductInput>
  }

  export type ProductInBagUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductInBagWhereUniqueInput
    data: XOR<ProductInBagUpdateWithoutProductInput, ProductInBagUncheckedUpdateWithoutProductInput>
  }

  export type ProductInBagUpdateManyWithWhereWithoutProductInput = {
    where: ProductInBagScalarWhereInput
    data: XOR<ProductInBagUpdateManyMutationInput, ProductInBagUncheckedUpdateManyWithoutProducts_in_bagInput>
  }

  export type ProductInBagScalarWhereInput = {
    AND?: Enumerable<ProductInBagScalarWhereInput>
    OR?: Enumerable<ProductInBagScalarWhereInput>
    NOT?: Enumerable<ProductInBagScalarWhereInput>
    username?: StringFilter | string
    shopId?: IntFilter | number
    productId?: IntFilter | number
    product_quantity?: IntFilter | number
  }

  export type OfferUpsertWithWhereUniqueWithoutProductInput = {
    where: OfferWhereUniqueInput
    update: XOR<OfferUpdateWithoutProductInput, OfferUncheckedUpdateWithoutProductInput>
    create: XOR<OfferCreateWithoutProductInput, OfferUncheckedCreateWithoutProductInput>
  }

  export type OfferUpdateWithWhereUniqueWithoutProductInput = {
    where: OfferWhereUniqueInput
    data: XOR<OfferUpdateWithoutProductInput, OfferUncheckedUpdateWithoutProductInput>
  }

  export type OfferUpdateManyWithWhereWithoutProductInput = {
    where: OfferScalarWhereInput
    data: XOR<OfferUpdateManyMutationInput, OfferUncheckedUpdateManyWithoutOffersInput>
  }

  export type MemberCreateWithoutShopsInput = {
    username: string
    roles?: RoleCreateNestedManyWithoutMemberInput
    ShoppingCart?: ShoppingCartCreateNestedOneWithoutMemberInput
    MemberCredentials?: MemberCredentialsCreateNestedOneWithoutMemberInput
    offers?: OfferCreateNestedManyWithoutMemberInput
    offerApprovers?: OfferApproverCreateNestedManyWithoutMemberInput
    appointments?: AppointmentCreateNestedManyWithoutMemberInput
    messageRecipients?: MessageRecipientsCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutShopsInput = {
    username: string
    roles?: RoleUncheckedCreateNestedManyWithoutMemberInput
    ShoppingCart?: ShoppingCartUncheckedCreateNestedOneWithoutMemberInput
    MemberCredentials?: MemberCredentialsUncheckedCreateNestedOneWithoutMemberInput
    offers?: OfferUncheckedCreateNestedManyWithoutMemberInput
    offerApprovers?: OfferApproverUncheckedCreateNestedManyWithoutMemberInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutMemberInput
    messageRecipients?: MessageRecipientsUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutShopsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutShopsInput, MemberUncheckedCreateWithoutShopsInput>
  }

  export type RoleCreateWithoutShopInput = {
    member: MemberCreateNestedOneWithoutRolesInput
    job_type: JobType
    permissions?: RoleCreatepermissionsInput | Enumerable<Permissions>
    shop_owners?: ShopOwnerCreateNestedManyWithoutRoleInput
    shop_managers?: ShopManagerCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutShopInput = {
    username: string
    job_type: JobType
    permissions?: RoleCreatepermissionsInput | Enumerable<Permissions>
    shop_owners?: ShopOwnerUncheckedCreateNestedManyWithoutRoleInput
    shop_managers?: ShopManagerUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutShopInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutShopInput, RoleUncheckedCreateWithoutShopInput>
  }

  export type RoleCreateManyShopInputEnvelope = {
    data: Enumerable<RoleCreateManyShopInput>
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutShopInput = {
    id: number
    name: string
    category?: ProductCategory
    rate?: ProductRate
    description?: string | null
    products_in_shop?: ProductInShopCreateNestedManyWithoutProductInput
    products_in_bag?: ProductInBagCreateNestedManyWithoutProductInput
    offers?: OfferCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutShopInput = {
    id: number
    name: string
    category?: ProductCategory
    rate?: ProductRate
    description?: string | null
    products_in_shop?: ProductInShopUncheckedCreateNestedManyWithoutProductInput
    products_in_bag?: ProductInBagUncheckedCreateNestedManyWithoutProductInput
    offers?: OfferUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutShopInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutShopInput, ProductUncheckedCreateWithoutShopInput>
  }

  export type ProductCreateManyShopInputEnvelope = {
    data: Enumerable<ProductCreateManyShopInput>
    skipDuplicates?: boolean
  }

  export type ProductInShopCreateWithoutShopInput = {
    product: ProductCreateNestedOneWithoutProducts_in_shopInput
    product_quantity?: number
  }

  export type ProductInShopUncheckedCreateWithoutShopInput = {
    productId: number
    product_quantity?: number
  }

  export type ProductInShopCreateOrConnectWithoutShopInput = {
    where: ProductInShopWhereUniqueInput
    create: XOR<ProductInShopCreateWithoutShopInput, ProductInShopUncheckedCreateWithoutShopInput>
  }

  export type ProductInShopCreateManyShopInputEnvelope = {
    data: Enumerable<ProductInShopCreateManyShopInput>
    skipDuplicates?: boolean
  }

  export type ShoppingBagCreateWithoutShopInput = {
    shoppingCart: ShoppingCartCreateNestedOneWithoutBagsInput
    products_in_bag?: ProductInBagCreateNestedManyWithoutShoppingBagInput
  }

  export type ShoppingBagUncheckedCreateWithoutShopInput = {
    username: string
    products_in_bag?: ProductInBagUncheckedCreateNestedManyWithoutShoppingBagInput
  }

  export type ShoppingBagCreateOrConnectWithoutShopInput = {
    where: ShoppingBagWhereUniqueInput
    create: XOR<ShoppingBagCreateWithoutShopInput, ShoppingBagUncheckedCreateWithoutShopInput>
  }

  export type ShoppingBagCreateManyShopInputEnvelope = {
    data: Enumerable<ShoppingBagCreateManyShopInput>
    skipDuplicates?: boolean
  }

  export type DiscountCreateWithoutShopInput = {
    id: number
    kind: DiscountKinds
    simpleDiscount?: SimpleDiscountCreateNestedOneWithoutDiscountInput
    conditionalDiscount?: ConditionalDiscountCreateNestedOneWithoutDiscountInput
    discountContainer?: DiscountContainerCreateNestedOneWithoutDiscountInput
    discountInContainer?: DiscountInContainerCreateNestedOneWithoutDiscountInput
  }

  export type DiscountUncheckedCreateWithoutShopInput = {
    id: number
    kind: DiscountKinds
    simpleDiscount?: SimpleDiscountUncheckedCreateNestedOneWithoutDiscountInput
    conditionalDiscount?: ConditionalDiscountUncheckedCreateNestedOneWithoutDiscountInput
    discountContainer?: DiscountContainerUncheckedCreateNestedOneWithoutDiscountInput
    discountInContainer?: DiscountInContainerUncheckedCreateNestedOneWithoutDiscountInput
  }

  export type DiscountCreateOrConnectWithoutShopInput = {
    where: DiscountWhereUniqueInput
    create: XOR<DiscountCreateWithoutShopInput, DiscountUncheckedCreateWithoutShopInput>
  }

  export type DiscountCreateManyShopInputEnvelope = {
    data: Enumerable<DiscountCreateManyShopInput>
    skipDuplicates?: boolean
  }

  export type PolicyCreateWithoutShopInput = {
    id: number
    simplePolicy?: SimplePolicyCreateNestedOneWithoutPolicyInput
    conditionalPolicy?: ConditionalPolicyCreateNestedOneWithoutPolicyInput
    logicalPolicy?: LogicalPolicyCreateNestedOneWithoutPolicyInput
    policyInContainer?: PolicyInContainerCreateNestedOneWithoutPolicyInput
  }

  export type PolicyUncheckedCreateWithoutShopInput = {
    id: number
    simplePolicy?: SimplePolicyUncheckedCreateNestedOneWithoutPolicyInput
    conditionalPolicy?: ConditionalPolicyUncheckedCreateNestedOneWithoutPolicyInput
    logicalPolicy?: LogicalPolicyUncheckedCreateNestedOneWithoutPolicyInput
    policyInContainer?: PolicyInContainerUncheckedCreateNestedOneWithoutPolicyInput
  }

  export type PolicyCreateOrConnectWithoutShopInput = {
    where: PolicyWhereUniqueInput
    create: XOR<PolicyCreateWithoutShopInput, PolicyUncheckedCreateWithoutShopInput>
  }

  export type PolicyCreateManyShopInputEnvelope = {
    data: Enumerable<PolicyCreateManyShopInput>
    skipDuplicates?: boolean
  }

  export type OfferCreateWithoutShopInput = {
    id: number
    member: MemberCreateNestedOneWithoutOffersInput
    product: ProductCreateNestedOneWithoutOffersInput
    price: number
    offerApprover?: OfferApproverCreateNestedManyWithoutOfferInput
  }

  export type OfferUncheckedCreateWithoutShopInput = {
    id: number
    username: string
    productId: number
    price: number
    offerApprover?: OfferApproverUncheckedCreateNestedManyWithoutOfferInput
  }

  export type OfferCreateOrConnectWithoutShopInput = {
    where: OfferWhereUniqueInput
    create: XOR<OfferCreateWithoutShopInput, OfferUncheckedCreateWithoutShopInput>
  }

  export type OfferCreateManyShopInputEnvelope = {
    data: Enumerable<OfferCreateManyShopInput>
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutShopInput = {
    member: MemberCreateNestedOneWithoutAppointmentsInput
    assigner: string
    appointmentAgreements?: AppointmentAgreementCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutShopInput = {
    username: string
    assigner: string
    appointmentAgreements?: AppointmentAgreementUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutShopInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutShopInput, AppointmentUncheckedCreateWithoutShopInput>
  }

  export type AppointmentCreateManyShopInputEnvelope = {
    data: Enumerable<AppointmentCreateManyShopInput>
    skipDuplicates?: boolean
  }

  export type MemberUpsertWithoutShopsInput = {
    update: XOR<MemberUpdateWithoutShopsInput, MemberUncheckedUpdateWithoutShopsInput>
    create: XOR<MemberCreateWithoutShopsInput, MemberUncheckedCreateWithoutShopsInput>
  }

  export type MemberUpdateWithoutShopsInput = {
    username?: StringFieldUpdateOperationsInput | string
    roles?: RoleUpdateManyWithoutMemberInput
    ShoppingCart?: ShoppingCartUpdateOneWithoutMemberInput
    MemberCredentials?: MemberCredentialsUpdateOneWithoutMemberInput
    offers?: OfferUpdateManyWithoutMemberInput
    offerApprovers?: OfferApproverUpdateManyWithoutMemberInput
    appointments?: AppointmentUpdateManyWithoutMemberInput
    messageRecipients?: MessageRecipientsUpdateManyWithoutMemberInput
  }

  export type MemberUncheckedUpdateWithoutShopsInput = {
    username?: StringFieldUpdateOperationsInput | string
    roles?: RoleUncheckedUpdateManyWithoutMemberInput
    ShoppingCart?: ShoppingCartUncheckedUpdateOneWithoutMemberInput
    MemberCredentials?: MemberCredentialsUncheckedUpdateOneWithoutMemberInput
    offers?: OfferUncheckedUpdateManyWithoutMemberInput
    offerApprovers?: OfferApproverUncheckedUpdateManyWithoutMemberInput
    appointments?: AppointmentUncheckedUpdateManyWithoutMemberInput
    messageRecipients?: MessageRecipientsUncheckedUpdateManyWithoutMemberInput
  }

  export type RoleUpsertWithWhereUniqueWithoutShopInput = {
    where: RoleWhereUniqueInput
    update: XOR<RoleUpdateWithoutShopInput, RoleUncheckedUpdateWithoutShopInput>
    create: XOR<RoleCreateWithoutShopInput, RoleUncheckedCreateWithoutShopInput>
  }

  export type RoleUpdateWithWhereUniqueWithoutShopInput = {
    where: RoleWhereUniqueInput
    data: XOR<RoleUpdateWithoutShopInput, RoleUncheckedUpdateWithoutShopInput>
  }

  export type RoleUpdateManyWithWhereWithoutShopInput = {
    where: RoleScalarWhereInput
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutShopInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutShopInput, ProductUncheckedUpdateWithoutShopInput>
    create: XOR<ProductCreateWithoutShopInput, ProductUncheckedCreateWithoutShopInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutShopInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutShopInput, ProductUncheckedUpdateWithoutShopInput>
  }

  export type ProductUpdateManyWithWhereWithoutShopInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductsInput>
  }

  export type ProductScalarWhereInput = {
    AND?: Enumerable<ProductScalarWhereInput>
    OR?: Enumerable<ProductScalarWhereInput>
    NOT?: Enumerable<ProductScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    shopId?: IntFilter | number
    category?: EnumProductCategoryFilter | ProductCategory
    rate?: EnumProductRateFilter | ProductRate
    description?: StringNullableFilter | string | null
  }

  export type ProductInShopUpsertWithWhereUniqueWithoutShopInput = {
    where: ProductInShopWhereUniqueInput
    update: XOR<ProductInShopUpdateWithoutShopInput, ProductInShopUncheckedUpdateWithoutShopInput>
    create: XOR<ProductInShopCreateWithoutShopInput, ProductInShopUncheckedCreateWithoutShopInput>
  }

  export type ProductInShopUpdateWithWhereUniqueWithoutShopInput = {
    where: ProductInShopWhereUniqueInput
    data: XOR<ProductInShopUpdateWithoutShopInput, ProductInShopUncheckedUpdateWithoutShopInput>
  }

  export type ProductInShopUpdateManyWithWhereWithoutShopInput = {
    where: ProductInShopScalarWhereInput
    data: XOR<ProductInShopUpdateManyMutationInput, ProductInShopUncheckedUpdateManyWithoutProducts_in_shopInput>
  }

  export type ShoppingBagUpsertWithWhereUniqueWithoutShopInput = {
    where: ShoppingBagWhereUniqueInput
    update: XOR<ShoppingBagUpdateWithoutShopInput, ShoppingBagUncheckedUpdateWithoutShopInput>
    create: XOR<ShoppingBagCreateWithoutShopInput, ShoppingBagUncheckedCreateWithoutShopInput>
  }

  export type ShoppingBagUpdateWithWhereUniqueWithoutShopInput = {
    where: ShoppingBagWhereUniqueInput
    data: XOR<ShoppingBagUpdateWithoutShopInput, ShoppingBagUncheckedUpdateWithoutShopInput>
  }

  export type ShoppingBagUpdateManyWithWhereWithoutShopInput = {
    where: ShoppingBagScalarWhereInput
    data: XOR<ShoppingBagUpdateManyMutationInput, ShoppingBagUncheckedUpdateManyWithoutBagsInput>
  }

  export type ShoppingBagScalarWhereInput = {
    AND?: Enumerable<ShoppingBagScalarWhereInput>
    OR?: Enumerable<ShoppingBagScalarWhereInput>
    NOT?: Enumerable<ShoppingBagScalarWhereInput>
    username?: StringFilter | string
    shopId?: IntFilter | number
  }

  export type DiscountUpsertWithWhereUniqueWithoutShopInput = {
    where: DiscountWhereUniqueInput
    update: XOR<DiscountUpdateWithoutShopInput, DiscountUncheckedUpdateWithoutShopInput>
    create: XOR<DiscountCreateWithoutShopInput, DiscountUncheckedCreateWithoutShopInput>
  }

  export type DiscountUpdateWithWhereUniqueWithoutShopInput = {
    where: DiscountWhereUniqueInput
    data: XOR<DiscountUpdateWithoutShopInput, DiscountUncheckedUpdateWithoutShopInput>
  }

  export type DiscountUpdateManyWithWhereWithoutShopInput = {
    where: DiscountScalarWhereInput
    data: XOR<DiscountUpdateManyMutationInput, DiscountUncheckedUpdateManyWithoutDiscountsInput>
  }

  export type DiscountScalarWhereInput = {
    AND?: Enumerable<DiscountScalarWhereInput>
    OR?: Enumerable<DiscountScalarWhereInput>
    NOT?: Enumerable<DiscountScalarWhereInput>
    id?: IntFilter | number
    shopId?: IntFilter | number
    kind?: EnumDiscountKindsFilter | DiscountKinds
  }

  export type PolicyUpsertWithWhereUniqueWithoutShopInput = {
    where: PolicyWhereUniqueInput
    update: XOR<PolicyUpdateWithoutShopInput, PolicyUncheckedUpdateWithoutShopInput>
    create: XOR<PolicyCreateWithoutShopInput, PolicyUncheckedCreateWithoutShopInput>
  }

  export type PolicyUpdateWithWhereUniqueWithoutShopInput = {
    where: PolicyWhereUniqueInput
    data: XOR<PolicyUpdateWithoutShopInput, PolicyUncheckedUpdateWithoutShopInput>
  }

  export type PolicyUpdateManyWithWhereWithoutShopInput = {
    where: PolicyScalarWhereInput
    data: XOR<PolicyUpdateManyMutationInput, PolicyUncheckedUpdateManyWithoutPoliciesInput>
  }

  export type PolicyScalarWhereInput = {
    AND?: Enumerable<PolicyScalarWhereInput>
    OR?: Enumerable<PolicyScalarWhereInput>
    NOT?: Enumerable<PolicyScalarWhereInput>
    id?: IntFilter | number
    shopId?: IntFilter | number
  }

  export type OfferUpsertWithWhereUniqueWithoutShopInput = {
    where: OfferWhereUniqueInput
    update: XOR<OfferUpdateWithoutShopInput, OfferUncheckedUpdateWithoutShopInput>
    create: XOR<OfferCreateWithoutShopInput, OfferUncheckedCreateWithoutShopInput>
  }

  export type OfferUpdateWithWhereUniqueWithoutShopInput = {
    where: OfferWhereUniqueInput
    data: XOR<OfferUpdateWithoutShopInput, OfferUncheckedUpdateWithoutShopInput>
  }

  export type OfferUpdateManyWithWhereWithoutShopInput = {
    where: OfferScalarWhereInput
    data: XOR<OfferUpdateManyMutationInput, OfferUncheckedUpdateManyWithoutOffersInput>
  }

  export type AppointmentUpsertWithWhereUniqueWithoutShopInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutShopInput, AppointmentUncheckedUpdateWithoutShopInput>
    create: XOR<AppointmentCreateWithoutShopInput, AppointmentUncheckedCreateWithoutShopInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutShopInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutShopInput, AppointmentUncheckedUpdateWithoutShopInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutShopInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutAppointmentsInput>
  }

  export type RoleCreateWithoutShop_ownersInput = {
    member: MemberCreateNestedOneWithoutRolesInput
    shop: ShopCreateNestedOneWithoutRoleInput
    job_type: JobType
    permissions?: RoleCreatepermissionsInput | Enumerable<Permissions>
    shop_managers?: ShopManagerCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutShop_ownersInput = {
    username: string
    shopId: number
    job_type: JobType
    permissions?: RoleCreatepermissionsInput | Enumerable<Permissions>
    shop_managers?: ShopManagerUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutShop_ownersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutShop_ownersInput, RoleUncheckedCreateWithoutShop_ownersInput>
  }

  export type RoleUpsertWithoutShop_ownersInput = {
    update: XOR<RoleUpdateWithoutShop_ownersInput, RoleUncheckedUpdateWithoutShop_ownersInput>
    create: XOR<RoleCreateWithoutShop_ownersInput, RoleUncheckedCreateWithoutShop_ownersInput>
  }

  export type RoleUpdateWithoutShop_ownersInput = {
    member?: MemberUpdateOneRequiredWithoutRolesInput
    shop?: ShopUpdateOneRequiredWithoutRoleInput
    job_type?: EnumJobTypeFieldUpdateOperationsInput | JobType
    permissions?: RoleUpdatepermissionsInput | Enumerable<Permissions>
    shop_managers?: ShopManagerUpdateManyWithoutRoleInput
  }

  export type RoleUncheckedUpdateWithoutShop_ownersInput = {
    username?: StringFieldUpdateOperationsInput | string
    shopId?: IntFieldUpdateOperationsInput | number
    job_type?: EnumJobTypeFieldUpdateOperationsInput | JobType
    permissions?: RoleUpdatepermissionsInput | Enumerable<Permissions>
    shop_managers?: ShopManagerUncheckedUpdateManyWithoutRoleInput
  }

  export type RoleCreateWithoutShop_managersInput = {
    member: MemberCreateNestedOneWithoutRolesInput
    shop: ShopCreateNestedOneWithoutRoleInput
    job_type: JobType
    permissions?: RoleCreatepermissionsInput | Enumerable<Permissions>
    shop_owners?: ShopOwnerCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutShop_managersInput = {
    username: string
    shopId: number
    job_type: JobType
    permissions?: RoleCreatepermissionsInput | Enumerable<Permissions>
    shop_owners?: ShopOwnerUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutShop_managersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutShop_managersInput, RoleUncheckedCreateWithoutShop_managersInput>
  }

  export type RoleUpsertWithoutShop_managersInput = {
    update: XOR<RoleUpdateWithoutShop_managersInput, RoleUncheckedUpdateWithoutShop_managersInput>
    create: XOR<RoleCreateWithoutShop_managersInput, RoleUncheckedCreateWithoutShop_managersInput>
  }

  export type RoleUpdateWithoutShop_managersInput = {
    member?: MemberUpdateOneRequiredWithoutRolesInput
    shop?: ShopUpdateOneRequiredWithoutRoleInput
    job_type?: EnumJobTypeFieldUpdateOperationsInput | JobType
    permissions?: RoleUpdatepermissionsInput | Enumerable<Permissions>
    shop_owners?: ShopOwnerUpdateManyWithoutRoleInput
  }

  export type RoleUncheckedUpdateWithoutShop_managersInput = {
    username?: StringFieldUpdateOperationsInput | string
    shopId?: IntFieldUpdateOperationsInput | number
    job_type?: EnumJobTypeFieldUpdateOperationsInput | JobType
    permissions?: RoleUpdatepermissionsInput | Enumerable<Permissions>
    shop_owners?: ShopOwnerUncheckedUpdateManyWithoutRoleInput
  }

  export type ShopCreateWithoutProducts_in_shopInput = {
    id: number
    name: string
    status: ShopStatus
    member: MemberCreateNestedOneWithoutShopsInput
    rate?: ShopRate
    description?: string | null
    role?: RoleCreateNestedManyWithoutShopInput
    products?: ProductCreateNestedManyWithoutShopInput
    bags?: ShoppingBagCreateNestedManyWithoutShopInput
    discounts?: DiscountCreateNestedManyWithoutShopInput
    policies?: PolicyCreateNestedManyWithoutShopInput
    offers?: OfferCreateNestedManyWithoutShopInput
    appointments?: AppointmentCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutProducts_in_shopInput = {
    id: number
    name: string
    status: ShopStatus
    shop_founder: string
    rate?: ShopRate
    description?: string | null
    role?: RoleUncheckedCreateNestedManyWithoutShopInput
    products?: ProductUncheckedCreateNestedManyWithoutShopInput
    bags?: ShoppingBagUncheckedCreateNestedManyWithoutShopInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutShopInput
    policies?: PolicyUncheckedCreateNestedManyWithoutShopInput
    offers?: OfferUncheckedCreateNestedManyWithoutShopInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutProducts_in_shopInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutProducts_in_shopInput, ShopUncheckedCreateWithoutProducts_in_shopInput>
  }

  export type ProductCreateWithoutProducts_in_shopInput = {
    id: number
    name: string
    shop: ShopCreateNestedOneWithoutProductsInput
    category?: ProductCategory
    rate?: ProductRate
    description?: string | null
    products_in_bag?: ProductInBagCreateNestedManyWithoutProductInput
    offers?: OfferCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProducts_in_shopInput = {
    id: number
    name: string
    shopId: number
    category?: ProductCategory
    rate?: ProductRate
    description?: string | null
    products_in_bag?: ProductInBagUncheckedCreateNestedManyWithoutProductInput
    offers?: OfferUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProducts_in_shopInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProducts_in_shopInput, ProductUncheckedCreateWithoutProducts_in_shopInput>
  }

  export type ShopUpsertWithoutProducts_in_shopInput = {
    update: XOR<ShopUpdateWithoutProducts_in_shopInput, ShopUncheckedUpdateWithoutProducts_in_shopInput>
    create: XOR<ShopCreateWithoutProducts_in_shopInput, ShopUncheckedCreateWithoutProducts_in_shopInput>
  }

  export type ShopUpdateWithoutProducts_in_shopInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | ShopStatus
    member?: MemberUpdateOneRequiredWithoutShopsInput
    rate?: EnumShopRateFieldUpdateOperationsInput | ShopRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
    role?: RoleUpdateManyWithoutShopInput
    products?: ProductUpdateManyWithoutShopInput
    bags?: ShoppingBagUpdateManyWithoutShopInput
    discounts?: DiscountUpdateManyWithoutShopInput
    policies?: PolicyUpdateManyWithoutShopInput
    offers?: OfferUpdateManyWithoutShopInput
    appointments?: AppointmentUpdateManyWithoutShopInput
  }

  export type ShopUncheckedUpdateWithoutProducts_in_shopInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | ShopStatus
    shop_founder?: StringFieldUpdateOperationsInput | string
    rate?: EnumShopRateFieldUpdateOperationsInput | ShopRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
    role?: RoleUncheckedUpdateManyWithoutShopInput
    products?: ProductUncheckedUpdateManyWithoutShopInput
    bags?: ShoppingBagUncheckedUpdateManyWithoutShopInput
    discounts?: DiscountUncheckedUpdateManyWithoutShopInput
    policies?: PolicyUncheckedUpdateManyWithoutShopInput
    offers?: OfferUncheckedUpdateManyWithoutShopInput
    appointments?: AppointmentUncheckedUpdateManyWithoutShopInput
  }

  export type ProductUpsertWithoutProducts_in_shopInput = {
    update: XOR<ProductUpdateWithoutProducts_in_shopInput, ProductUncheckedUpdateWithoutProducts_in_shopInput>
    create: XOR<ProductCreateWithoutProducts_in_shopInput, ProductUncheckedCreateWithoutProducts_in_shopInput>
  }

  export type ProductUpdateWithoutProducts_in_shopInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shop?: ShopUpdateOneRequiredWithoutProductsInput
    category?: EnumProductCategoryFieldUpdateOperationsInput | ProductCategory
    rate?: EnumProductRateFieldUpdateOperationsInput | ProductRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
    products_in_bag?: ProductInBagUpdateManyWithoutProductInput
    offers?: OfferUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutProducts_in_shopInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shopId?: IntFieldUpdateOperationsInput | number
    category?: EnumProductCategoryFieldUpdateOperationsInput | ProductCategory
    rate?: EnumProductRateFieldUpdateOperationsInput | ProductRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
    products_in_bag?: ProductInBagUncheckedUpdateManyWithoutProductInput
    offers?: OfferUncheckedUpdateManyWithoutProductInput
  }

  export type MemberCreateWithoutShoppingCartInput = {
    username: string
    roles?: RoleCreateNestedManyWithoutMemberInput
    shops?: ShopCreateNestedManyWithoutMemberInput
    MemberCredentials?: MemberCredentialsCreateNestedOneWithoutMemberInput
    offers?: OfferCreateNestedManyWithoutMemberInput
    offerApprovers?: OfferApproverCreateNestedManyWithoutMemberInput
    appointments?: AppointmentCreateNestedManyWithoutMemberInput
    messageRecipients?: MessageRecipientsCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutShoppingCartInput = {
    username: string
    roles?: RoleUncheckedCreateNestedManyWithoutMemberInput
    shops?: ShopUncheckedCreateNestedManyWithoutMemberInput
    MemberCredentials?: MemberCredentialsUncheckedCreateNestedOneWithoutMemberInput
    offers?: OfferUncheckedCreateNestedManyWithoutMemberInput
    offerApprovers?: OfferApproverUncheckedCreateNestedManyWithoutMemberInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutMemberInput
    messageRecipients?: MessageRecipientsUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutShoppingCartInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutShoppingCartInput, MemberUncheckedCreateWithoutShoppingCartInput>
  }

  export type ShoppingBagCreateWithoutShoppingCartInput = {
    shop: ShopCreateNestedOneWithoutBagsInput
    products_in_bag?: ProductInBagCreateNestedManyWithoutShoppingBagInput
  }

  export type ShoppingBagUncheckedCreateWithoutShoppingCartInput = {
    shopId: number
    products_in_bag?: ProductInBagUncheckedCreateNestedManyWithoutShoppingBagInput
  }

  export type ShoppingBagCreateOrConnectWithoutShoppingCartInput = {
    where: ShoppingBagWhereUniqueInput
    create: XOR<ShoppingBagCreateWithoutShoppingCartInput, ShoppingBagUncheckedCreateWithoutShoppingCartInput>
  }

  export type ShoppingBagCreateManyShoppingCartInputEnvelope = {
    data: Enumerable<ShoppingBagCreateManyShoppingCartInput>
    skipDuplicates?: boolean
  }

  export type MemberUpsertWithoutShoppingCartInput = {
    update: XOR<MemberUpdateWithoutShoppingCartInput, MemberUncheckedUpdateWithoutShoppingCartInput>
    create: XOR<MemberCreateWithoutShoppingCartInput, MemberUncheckedCreateWithoutShoppingCartInput>
  }

  export type MemberUpdateWithoutShoppingCartInput = {
    username?: StringFieldUpdateOperationsInput | string
    roles?: RoleUpdateManyWithoutMemberInput
    shops?: ShopUpdateManyWithoutMemberInput
    MemberCredentials?: MemberCredentialsUpdateOneWithoutMemberInput
    offers?: OfferUpdateManyWithoutMemberInput
    offerApprovers?: OfferApproverUpdateManyWithoutMemberInput
    appointments?: AppointmentUpdateManyWithoutMemberInput
    messageRecipients?: MessageRecipientsUpdateManyWithoutMemberInput
  }

  export type MemberUncheckedUpdateWithoutShoppingCartInput = {
    username?: StringFieldUpdateOperationsInput | string
    roles?: RoleUncheckedUpdateManyWithoutMemberInput
    shops?: ShopUncheckedUpdateManyWithoutMemberInput
    MemberCredentials?: MemberCredentialsUncheckedUpdateOneWithoutMemberInput
    offers?: OfferUncheckedUpdateManyWithoutMemberInput
    offerApprovers?: OfferApproverUncheckedUpdateManyWithoutMemberInput
    appointments?: AppointmentUncheckedUpdateManyWithoutMemberInput
    messageRecipients?: MessageRecipientsUncheckedUpdateManyWithoutMemberInput
  }

  export type ShoppingBagUpsertWithWhereUniqueWithoutShoppingCartInput = {
    where: ShoppingBagWhereUniqueInput
    update: XOR<ShoppingBagUpdateWithoutShoppingCartInput, ShoppingBagUncheckedUpdateWithoutShoppingCartInput>
    create: XOR<ShoppingBagCreateWithoutShoppingCartInput, ShoppingBagUncheckedCreateWithoutShoppingCartInput>
  }

  export type ShoppingBagUpdateWithWhereUniqueWithoutShoppingCartInput = {
    where: ShoppingBagWhereUniqueInput
    data: XOR<ShoppingBagUpdateWithoutShoppingCartInput, ShoppingBagUncheckedUpdateWithoutShoppingCartInput>
  }

  export type ShoppingBagUpdateManyWithWhereWithoutShoppingCartInput = {
    where: ShoppingBagScalarWhereInput
    data: XOR<ShoppingBagUpdateManyMutationInput, ShoppingBagUncheckedUpdateManyWithoutBagsInput>
  }

  export type ShoppingCartCreateWithoutBagsInput = {
    member: MemberCreateNestedOneWithoutShoppingCartInput
  }

  export type ShoppingCartUncheckedCreateWithoutBagsInput = {
    username: string
  }

  export type ShoppingCartCreateOrConnectWithoutBagsInput = {
    where: ShoppingCartWhereUniqueInput
    create: XOR<ShoppingCartCreateWithoutBagsInput, ShoppingCartUncheckedCreateWithoutBagsInput>
  }

  export type ShopCreateWithoutBagsInput = {
    id: number
    name: string
    status: ShopStatus
    member: MemberCreateNestedOneWithoutShopsInput
    rate?: ShopRate
    description?: string | null
    role?: RoleCreateNestedManyWithoutShopInput
    products?: ProductCreateNestedManyWithoutShopInput
    products_in_shop?: ProductInShopCreateNestedManyWithoutShopInput
    discounts?: DiscountCreateNestedManyWithoutShopInput
    policies?: PolicyCreateNestedManyWithoutShopInput
    offers?: OfferCreateNestedManyWithoutShopInput
    appointments?: AppointmentCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutBagsInput = {
    id: number
    name: string
    status: ShopStatus
    shop_founder: string
    rate?: ShopRate
    description?: string | null
    role?: RoleUncheckedCreateNestedManyWithoutShopInput
    products?: ProductUncheckedCreateNestedManyWithoutShopInput
    products_in_shop?: ProductInShopUncheckedCreateNestedManyWithoutShopInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutShopInput
    policies?: PolicyUncheckedCreateNestedManyWithoutShopInput
    offers?: OfferUncheckedCreateNestedManyWithoutShopInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutBagsInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutBagsInput, ShopUncheckedCreateWithoutBagsInput>
  }

  export type ProductInBagCreateWithoutShoppingBagInput = {
    product: ProductCreateNestedOneWithoutProducts_in_bagInput
    product_quantity?: number
  }

  export type ProductInBagUncheckedCreateWithoutShoppingBagInput = {
    productId: number
    product_quantity?: number
  }

  export type ProductInBagCreateOrConnectWithoutShoppingBagInput = {
    where: ProductInBagWhereUniqueInput
    create: XOR<ProductInBagCreateWithoutShoppingBagInput, ProductInBagUncheckedCreateWithoutShoppingBagInput>
  }

  export type ProductInBagCreateManyShoppingBagInputEnvelope = {
    data: Enumerable<ProductInBagCreateManyShoppingBagInput>
    skipDuplicates?: boolean
  }

  export type ShoppingCartUpsertWithoutBagsInput = {
    update: XOR<ShoppingCartUpdateWithoutBagsInput, ShoppingCartUncheckedUpdateWithoutBagsInput>
    create: XOR<ShoppingCartCreateWithoutBagsInput, ShoppingCartUncheckedCreateWithoutBagsInput>
  }

  export type ShoppingCartUpdateWithoutBagsInput = {
    member?: MemberUpdateOneRequiredWithoutShoppingCartInput
  }

  export type ShoppingCartUncheckedUpdateWithoutBagsInput = {
    username?: StringFieldUpdateOperationsInput | string
  }

  export type ShopUpsertWithoutBagsInput = {
    update: XOR<ShopUpdateWithoutBagsInput, ShopUncheckedUpdateWithoutBagsInput>
    create: XOR<ShopCreateWithoutBagsInput, ShopUncheckedCreateWithoutBagsInput>
  }

  export type ShopUpdateWithoutBagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | ShopStatus
    member?: MemberUpdateOneRequiredWithoutShopsInput
    rate?: EnumShopRateFieldUpdateOperationsInput | ShopRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
    role?: RoleUpdateManyWithoutShopInput
    products?: ProductUpdateManyWithoutShopInput
    products_in_shop?: ProductInShopUpdateManyWithoutShopInput
    discounts?: DiscountUpdateManyWithoutShopInput
    policies?: PolicyUpdateManyWithoutShopInput
    offers?: OfferUpdateManyWithoutShopInput
    appointments?: AppointmentUpdateManyWithoutShopInput
  }

  export type ShopUncheckedUpdateWithoutBagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | ShopStatus
    shop_founder?: StringFieldUpdateOperationsInput | string
    rate?: EnumShopRateFieldUpdateOperationsInput | ShopRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
    role?: RoleUncheckedUpdateManyWithoutShopInput
    products?: ProductUncheckedUpdateManyWithoutShopInput
    products_in_shop?: ProductInShopUncheckedUpdateManyWithoutShopInput
    discounts?: DiscountUncheckedUpdateManyWithoutShopInput
    policies?: PolicyUncheckedUpdateManyWithoutShopInput
    offers?: OfferUncheckedUpdateManyWithoutShopInput
    appointments?: AppointmentUncheckedUpdateManyWithoutShopInput
  }

  export type ProductInBagUpsertWithWhereUniqueWithoutShoppingBagInput = {
    where: ProductInBagWhereUniqueInput
    update: XOR<ProductInBagUpdateWithoutShoppingBagInput, ProductInBagUncheckedUpdateWithoutShoppingBagInput>
    create: XOR<ProductInBagCreateWithoutShoppingBagInput, ProductInBagUncheckedCreateWithoutShoppingBagInput>
  }

  export type ProductInBagUpdateWithWhereUniqueWithoutShoppingBagInput = {
    where: ProductInBagWhereUniqueInput
    data: XOR<ProductInBagUpdateWithoutShoppingBagInput, ProductInBagUncheckedUpdateWithoutShoppingBagInput>
  }

  export type ProductInBagUpdateManyWithWhereWithoutShoppingBagInput = {
    where: ProductInBagScalarWhereInput
    data: XOR<ProductInBagUpdateManyMutationInput, ProductInBagUncheckedUpdateManyWithoutProducts_in_bagInput>
  }

  export type ShoppingBagCreateWithoutProducts_in_bagInput = {
    shoppingCart: ShoppingCartCreateNestedOneWithoutBagsInput
    shop: ShopCreateNestedOneWithoutBagsInput
  }

  export type ShoppingBagUncheckedCreateWithoutProducts_in_bagInput = {
    username: string
    shopId: number
  }

  export type ShoppingBagCreateOrConnectWithoutProducts_in_bagInput = {
    where: ShoppingBagWhereUniqueInput
    create: XOR<ShoppingBagCreateWithoutProducts_in_bagInput, ShoppingBagUncheckedCreateWithoutProducts_in_bagInput>
  }

  export type ProductCreateWithoutProducts_in_bagInput = {
    id: number
    name: string
    shop: ShopCreateNestedOneWithoutProductsInput
    category?: ProductCategory
    rate?: ProductRate
    description?: string | null
    products_in_shop?: ProductInShopCreateNestedManyWithoutProductInput
    offers?: OfferCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProducts_in_bagInput = {
    id: number
    name: string
    shopId: number
    category?: ProductCategory
    rate?: ProductRate
    description?: string | null
    products_in_shop?: ProductInShopUncheckedCreateNestedManyWithoutProductInput
    offers?: OfferUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProducts_in_bagInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProducts_in_bagInput, ProductUncheckedCreateWithoutProducts_in_bagInput>
  }

  export type ShoppingBagUpsertWithoutProducts_in_bagInput = {
    update: XOR<ShoppingBagUpdateWithoutProducts_in_bagInput, ShoppingBagUncheckedUpdateWithoutProducts_in_bagInput>
    create: XOR<ShoppingBagCreateWithoutProducts_in_bagInput, ShoppingBagUncheckedCreateWithoutProducts_in_bagInput>
  }

  export type ShoppingBagUpdateWithoutProducts_in_bagInput = {
    shoppingCart?: ShoppingCartUpdateOneRequiredWithoutBagsInput
    shop?: ShopUpdateOneRequiredWithoutBagsInput
  }

  export type ShoppingBagUncheckedUpdateWithoutProducts_in_bagInput = {
    username?: StringFieldUpdateOperationsInput | string
    shopId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductUpsertWithoutProducts_in_bagInput = {
    update: XOR<ProductUpdateWithoutProducts_in_bagInput, ProductUncheckedUpdateWithoutProducts_in_bagInput>
    create: XOR<ProductCreateWithoutProducts_in_bagInput, ProductUncheckedCreateWithoutProducts_in_bagInput>
  }

  export type ProductUpdateWithoutProducts_in_bagInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shop?: ShopUpdateOneRequiredWithoutProductsInput
    category?: EnumProductCategoryFieldUpdateOperationsInput | ProductCategory
    rate?: EnumProductRateFieldUpdateOperationsInput | ProductRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
    products_in_shop?: ProductInShopUpdateManyWithoutProductInput
    offers?: OfferUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutProducts_in_bagInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shopId?: IntFieldUpdateOperationsInput | number
    category?: EnumProductCategoryFieldUpdateOperationsInput | ProductCategory
    rate?: EnumProductRateFieldUpdateOperationsInput | ProductRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
    products_in_shop?: ProductInShopUncheckedUpdateManyWithoutProductInput
    offers?: OfferUncheckedUpdateManyWithoutProductInput
  }

  export type MemberCreateWithoutMemberCredentialsInput = {
    username: string
    roles?: RoleCreateNestedManyWithoutMemberInput
    shops?: ShopCreateNestedManyWithoutMemberInput
    ShoppingCart?: ShoppingCartCreateNestedOneWithoutMemberInput
    offers?: OfferCreateNestedManyWithoutMemberInput
    offerApprovers?: OfferApproverCreateNestedManyWithoutMemberInput
    appointments?: AppointmentCreateNestedManyWithoutMemberInput
    messageRecipients?: MessageRecipientsCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutMemberCredentialsInput = {
    username: string
    roles?: RoleUncheckedCreateNestedManyWithoutMemberInput
    shops?: ShopUncheckedCreateNestedManyWithoutMemberInput
    ShoppingCart?: ShoppingCartUncheckedCreateNestedOneWithoutMemberInput
    offers?: OfferUncheckedCreateNestedManyWithoutMemberInput
    offerApprovers?: OfferApproverUncheckedCreateNestedManyWithoutMemberInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutMemberInput
    messageRecipients?: MessageRecipientsUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutMemberCredentialsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutMemberCredentialsInput, MemberUncheckedCreateWithoutMemberCredentialsInput>
  }

  export type MemberUpsertWithoutMemberCredentialsInput = {
    update: XOR<MemberUpdateWithoutMemberCredentialsInput, MemberUncheckedUpdateWithoutMemberCredentialsInput>
    create: XOR<MemberCreateWithoutMemberCredentialsInput, MemberUncheckedCreateWithoutMemberCredentialsInput>
  }

  export type MemberUpdateWithoutMemberCredentialsInput = {
    username?: StringFieldUpdateOperationsInput | string
    roles?: RoleUpdateManyWithoutMemberInput
    shops?: ShopUpdateManyWithoutMemberInput
    ShoppingCart?: ShoppingCartUpdateOneWithoutMemberInput
    offers?: OfferUpdateManyWithoutMemberInput
    offerApprovers?: OfferApproverUpdateManyWithoutMemberInput
    appointments?: AppointmentUpdateManyWithoutMemberInput
    messageRecipients?: MessageRecipientsUpdateManyWithoutMemberInput
  }

  export type MemberUncheckedUpdateWithoutMemberCredentialsInput = {
    username?: StringFieldUpdateOperationsInput | string
    roles?: RoleUncheckedUpdateManyWithoutMemberInput
    shops?: ShopUncheckedUpdateManyWithoutMemberInput
    ShoppingCart?: ShoppingCartUncheckedUpdateOneWithoutMemberInput
    offers?: OfferUncheckedUpdateManyWithoutMemberInput
    offerApprovers?: OfferApproverUncheckedUpdateManyWithoutMemberInput
    appointments?: AppointmentUncheckedUpdateManyWithoutMemberInput
    messageRecipients?: MessageRecipientsUncheckedUpdateManyWithoutMemberInput
  }

  export type MessageRecipientsCreateWithoutMessageInput = {
    member: MemberCreateNestedOneWithoutMessageRecipientsInput
  }

  export type MessageRecipientsUncheckedCreateWithoutMessageInput = {
    username: string
  }

  export type MessageRecipientsCreateOrConnectWithoutMessageInput = {
    where: MessageRecipientsWhereUniqueInput
    create: XOR<MessageRecipientsCreateWithoutMessageInput, MessageRecipientsUncheckedCreateWithoutMessageInput>
  }

  export type MessageRecipientsCreateManyMessageInputEnvelope = {
    data: Enumerable<MessageRecipientsCreateManyMessageInput>
    skipDuplicates?: boolean
  }

  export type MessageRecipientsUpsertWithWhereUniqueWithoutMessageInput = {
    where: MessageRecipientsWhereUniqueInput
    update: XOR<MessageRecipientsUpdateWithoutMessageInput, MessageRecipientsUncheckedUpdateWithoutMessageInput>
    create: XOR<MessageRecipientsCreateWithoutMessageInput, MessageRecipientsUncheckedCreateWithoutMessageInput>
  }

  export type MessageRecipientsUpdateWithWhereUniqueWithoutMessageInput = {
    where: MessageRecipientsWhereUniqueInput
    data: XOR<MessageRecipientsUpdateWithoutMessageInput, MessageRecipientsUncheckedUpdateWithoutMessageInput>
  }

  export type MessageRecipientsUpdateManyWithWhereWithoutMessageInput = {
    where: MessageRecipientsScalarWhereInput
    data: XOR<MessageRecipientsUpdateManyMutationInput, MessageRecipientsUncheckedUpdateManyWithoutRecipientsInput>
  }

  export type MessageCreateWithoutRecipientsInput = {
    id: number
    timestamp: number
    isRead: boolean
    messageType: MessageType
  }

  export type MessageUncheckedCreateWithoutRecipientsInput = {
    id: number
    timestamp: number
    isRead: boolean
    messageType: MessageType
  }

  export type MessageCreateOrConnectWithoutRecipientsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutRecipientsInput, MessageUncheckedCreateWithoutRecipientsInput>
  }

  export type MemberCreateWithoutMessageRecipientsInput = {
    username: string
    roles?: RoleCreateNestedManyWithoutMemberInput
    shops?: ShopCreateNestedManyWithoutMemberInput
    ShoppingCart?: ShoppingCartCreateNestedOneWithoutMemberInput
    MemberCredentials?: MemberCredentialsCreateNestedOneWithoutMemberInput
    offers?: OfferCreateNestedManyWithoutMemberInput
    offerApprovers?: OfferApproverCreateNestedManyWithoutMemberInput
    appointments?: AppointmentCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutMessageRecipientsInput = {
    username: string
    roles?: RoleUncheckedCreateNestedManyWithoutMemberInput
    shops?: ShopUncheckedCreateNestedManyWithoutMemberInput
    ShoppingCart?: ShoppingCartUncheckedCreateNestedOneWithoutMemberInput
    MemberCredentials?: MemberCredentialsUncheckedCreateNestedOneWithoutMemberInput
    offers?: OfferUncheckedCreateNestedManyWithoutMemberInput
    offerApprovers?: OfferApproverUncheckedCreateNestedManyWithoutMemberInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutMessageRecipientsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutMessageRecipientsInput, MemberUncheckedCreateWithoutMessageRecipientsInput>
  }

  export type MessageUpsertWithoutRecipientsInput = {
    update: XOR<MessageUpdateWithoutRecipientsInput, MessageUncheckedUpdateWithoutRecipientsInput>
    create: XOR<MessageCreateWithoutRecipientsInput, MessageUncheckedCreateWithoutRecipientsInput>
  }

  export type MessageUpdateWithoutRecipientsInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: IntFieldUpdateOperationsInput | number
    isRead?: BoolFieldUpdateOperationsInput | boolean
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | MessageType
  }

  export type MessageUncheckedUpdateWithoutRecipientsInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: IntFieldUpdateOperationsInput | number
    isRead?: BoolFieldUpdateOperationsInput | boolean
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | MessageType
  }

  export type MemberUpsertWithoutMessageRecipientsInput = {
    update: XOR<MemberUpdateWithoutMessageRecipientsInput, MemberUncheckedUpdateWithoutMessageRecipientsInput>
    create: XOR<MemberCreateWithoutMessageRecipientsInput, MemberUncheckedCreateWithoutMessageRecipientsInput>
  }

  export type MemberUpdateWithoutMessageRecipientsInput = {
    username?: StringFieldUpdateOperationsInput | string
    roles?: RoleUpdateManyWithoutMemberInput
    shops?: ShopUpdateManyWithoutMemberInput
    ShoppingCart?: ShoppingCartUpdateOneWithoutMemberInput
    MemberCredentials?: MemberCredentialsUpdateOneWithoutMemberInput
    offers?: OfferUpdateManyWithoutMemberInput
    offerApprovers?: OfferApproverUpdateManyWithoutMemberInput
    appointments?: AppointmentUpdateManyWithoutMemberInput
  }

  export type MemberUncheckedUpdateWithoutMessageRecipientsInput = {
    username?: StringFieldUpdateOperationsInput | string
    roles?: RoleUncheckedUpdateManyWithoutMemberInput
    shops?: ShopUncheckedUpdateManyWithoutMemberInput
    ShoppingCart?: ShoppingCartUncheckedUpdateOneWithoutMemberInput
    MemberCredentials?: MemberCredentialsUncheckedUpdateOneWithoutMemberInput
    offers?: OfferUncheckedUpdateManyWithoutMemberInput
    offerApprovers?: OfferApproverUncheckedUpdateManyWithoutMemberInput
    appointments?: AppointmentUncheckedUpdateManyWithoutMemberInput
  }

  export type ShopCreateWithoutDiscountsInput = {
    id: number
    name: string
    status: ShopStatus
    member: MemberCreateNestedOneWithoutShopsInput
    rate?: ShopRate
    description?: string | null
    role?: RoleCreateNestedManyWithoutShopInput
    products?: ProductCreateNestedManyWithoutShopInput
    products_in_shop?: ProductInShopCreateNestedManyWithoutShopInput
    bags?: ShoppingBagCreateNestedManyWithoutShopInput
    policies?: PolicyCreateNestedManyWithoutShopInput
    offers?: OfferCreateNestedManyWithoutShopInput
    appointments?: AppointmentCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutDiscountsInput = {
    id: number
    name: string
    status: ShopStatus
    shop_founder: string
    rate?: ShopRate
    description?: string | null
    role?: RoleUncheckedCreateNestedManyWithoutShopInput
    products?: ProductUncheckedCreateNestedManyWithoutShopInput
    products_in_shop?: ProductInShopUncheckedCreateNestedManyWithoutShopInput
    bags?: ShoppingBagUncheckedCreateNestedManyWithoutShopInput
    policies?: PolicyUncheckedCreateNestedManyWithoutShopInput
    offers?: OfferUncheckedCreateNestedManyWithoutShopInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutDiscountsInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutDiscountsInput, ShopUncheckedCreateWithoutDiscountsInput>
  }

  export type SimpleDiscountCreateWithoutDiscountInput = {
    discountType: DiscountType
    discountPercent: number
    description: string
    productId?: number | null
    category?: ProductCategory | null
    conditionalDiscount?: ConditionalDiscountCreateNestedOneWithoutSimpleDiscountInput
  }

  export type SimpleDiscountUncheckedCreateWithoutDiscountInput = {
    discountType: DiscountType
    discountPercent: number
    description: string
    productId?: number | null
    category?: ProductCategory | null
    conditionalDiscount?: ConditionalDiscountUncheckedCreateNestedOneWithoutSimpleDiscountInput
  }

  export type SimpleDiscountCreateOrConnectWithoutDiscountInput = {
    where: SimpleDiscountWhereUniqueInput
    create: XOR<SimpleDiscountCreateWithoutDiscountInput, SimpleDiscountUncheckedCreateWithoutDiscountInput>
  }

  export type ConditionalDiscountCreateWithoutDiscountInput = {
    simpleDiscount: SimpleDiscountCreateNestedOneWithoutConditionalDiscountInput
    discountPredicate?: DiscountPredicateCreateNestedOneWithoutDiscountInput
  }

  export type ConditionalDiscountUncheckedCreateWithoutDiscountInput = {
    simpleId: number
    simpleShopId: number
    discountPredicate?: DiscountPredicateUncheckedCreateNestedOneWithoutDiscountInput
  }

  export type ConditionalDiscountCreateOrConnectWithoutDiscountInput = {
    where: ConditionalDiscountWhereUniqueInput
    create: XOR<ConditionalDiscountCreateWithoutDiscountInput, ConditionalDiscountUncheckedCreateWithoutDiscountInput>
  }

  export type DiscountContainerCreateWithoutDiscountInput = {
    description: string
    type: DiscountRelation
    discounts?: DiscountInContainerCreateNestedManyWithoutDiscountContainerInput
  }

  export type DiscountContainerUncheckedCreateWithoutDiscountInput = {
    description: string
    type: DiscountRelation
    discounts?: DiscountInContainerUncheckedCreateNestedManyWithoutDiscountContainerInput
  }

  export type DiscountContainerCreateOrConnectWithoutDiscountInput = {
    where: DiscountContainerWhereUniqueInput
    create: XOR<DiscountContainerCreateWithoutDiscountInput, DiscountContainerUncheckedCreateWithoutDiscountInput>
  }

  export type DiscountInContainerCreateWithoutDiscountInput = {
    discountContainer: DiscountContainerCreateNestedOneWithoutDiscountsInput
  }

  export type DiscountInContainerUncheckedCreateWithoutDiscountInput = {
    containingDiscount: number
  }

  export type DiscountInContainerCreateOrConnectWithoutDiscountInput = {
    where: DiscountInContainerWhereUniqueInput
    create: XOR<DiscountInContainerCreateWithoutDiscountInput, DiscountInContainerUncheckedCreateWithoutDiscountInput>
  }

  export type ShopUpsertWithoutDiscountsInput = {
    update: XOR<ShopUpdateWithoutDiscountsInput, ShopUncheckedUpdateWithoutDiscountsInput>
    create: XOR<ShopCreateWithoutDiscountsInput, ShopUncheckedCreateWithoutDiscountsInput>
  }

  export type ShopUpdateWithoutDiscountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | ShopStatus
    member?: MemberUpdateOneRequiredWithoutShopsInput
    rate?: EnumShopRateFieldUpdateOperationsInput | ShopRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
    role?: RoleUpdateManyWithoutShopInput
    products?: ProductUpdateManyWithoutShopInput
    products_in_shop?: ProductInShopUpdateManyWithoutShopInput
    bags?: ShoppingBagUpdateManyWithoutShopInput
    policies?: PolicyUpdateManyWithoutShopInput
    offers?: OfferUpdateManyWithoutShopInput
    appointments?: AppointmentUpdateManyWithoutShopInput
  }

  export type ShopUncheckedUpdateWithoutDiscountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | ShopStatus
    shop_founder?: StringFieldUpdateOperationsInput | string
    rate?: EnumShopRateFieldUpdateOperationsInput | ShopRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
    role?: RoleUncheckedUpdateManyWithoutShopInput
    products?: ProductUncheckedUpdateManyWithoutShopInput
    products_in_shop?: ProductInShopUncheckedUpdateManyWithoutShopInput
    bags?: ShoppingBagUncheckedUpdateManyWithoutShopInput
    policies?: PolicyUncheckedUpdateManyWithoutShopInput
    offers?: OfferUncheckedUpdateManyWithoutShopInput
    appointments?: AppointmentUncheckedUpdateManyWithoutShopInput
  }

  export type SimpleDiscountUpsertWithoutDiscountInput = {
    update: XOR<SimpleDiscountUpdateWithoutDiscountInput, SimpleDiscountUncheckedUpdateWithoutDiscountInput>
    create: XOR<SimpleDiscountCreateWithoutDiscountInput, SimpleDiscountUncheckedCreateWithoutDiscountInput>
  }

  export type SimpleDiscountUpdateWithoutDiscountInput = {
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | DiscountType
    discountPercent?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableEnumProductCategoryFieldUpdateOperationsInput | ProductCategory | null
    conditionalDiscount?: ConditionalDiscountUpdateOneWithoutSimpleDiscountInput
  }

  export type SimpleDiscountUncheckedUpdateWithoutDiscountInput = {
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | DiscountType
    discountPercent?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableEnumProductCategoryFieldUpdateOperationsInput | ProductCategory | null
    conditionalDiscount?: ConditionalDiscountUncheckedUpdateOneWithoutSimpleDiscountInput
  }

  export type ConditionalDiscountUpsertWithoutDiscountInput = {
    update: XOR<ConditionalDiscountUpdateWithoutDiscountInput, ConditionalDiscountUncheckedUpdateWithoutDiscountInput>
    create: XOR<ConditionalDiscountCreateWithoutDiscountInput, ConditionalDiscountUncheckedCreateWithoutDiscountInput>
  }

  export type ConditionalDiscountUpdateWithoutDiscountInput = {
    simpleDiscount?: SimpleDiscountUpdateOneRequiredWithoutConditionalDiscountInput
    discountPredicate?: DiscountPredicateUpdateOneWithoutDiscountInput
  }

  export type ConditionalDiscountUncheckedUpdateWithoutDiscountInput = {
    simpleId?: IntFieldUpdateOperationsInput | number
    simpleShopId?: IntFieldUpdateOperationsInput | number
    discountPredicate?: DiscountPredicateUncheckedUpdateOneWithoutDiscountInput
  }

  export type DiscountContainerUpsertWithoutDiscountInput = {
    update: XOR<DiscountContainerUpdateWithoutDiscountInput, DiscountContainerUncheckedUpdateWithoutDiscountInput>
    create: XOR<DiscountContainerCreateWithoutDiscountInput, DiscountContainerUncheckedCreateWithoutDiscountInput>
  }

  export type DiscountContainerUpdateWithoutDiscountInput = {
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountRelationFieldUpdateOperationsInput | DiscountRelation
    discounts?: DiscountInContainerUpdateManyWithoutDiscountContainerInput
  }

  export type DiscountContainerUncheckedUpdateWithoutDiscountInput = {
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountRelationFieldUpdateOperationsInput | DiscountRelation
    discounts?: DiscountInContainerUncheckedUpdateManyWithoutDiscountContainerInput
  }

  export type DiscountInContainerUpsertWithoutDiscountInput = {
    update: XOR<DiscountInContainerUpdateWithoutDiscountInput, DiscountInContainerUncheckedUpdateWithoutDiscountInput>
    create: XOR<DiscountInContainerCreateWithoutDiscountInput, DiscountInContainerUncheckedCreateWithoutDiscountInput>
  }

  export type DiscountInContainerUpdateWithoutDiscountInput = {
    discountContainer?: DiscountContainerUpdateOneRequiredWithoutDiscountsInput
  }

  export type DiscountInContainerUncheckedUpdateWithoutDiscountInput = {
    containingDiscount?: IntFieldUpdateOperationsInput | number
  }

  export type DiscountCreateWithoutSimpleDiscountInput = {
    id: number
    shop: ShopCreateNestedOneWithoutDiscountsInput
    kind: DiscountKinds
    conditionalDiscount?: ConditionalDiscountCreateNestedOneWithoutDiscountInput
    discountContainer?: DiscountContainerCreateNestedOneWithoutDiscountInput
    discountInContainer?: DiscountInContainerCreateNestedOneWithoutDiscountInput
  }

  export type DiscountUncheckedCreateWithoutSimpleDiscountInput = {
    id: number
    shopId: number
    kind: DiscountKinds
    conditionalDiscount?: ConditionalDiscountUncheckedCreateNestedOneWithoutDiscountInput
    discountContainer?: DiscountContainerUncheckedCreateNestedOneWithoutDiscountInput
    discountInContainer?: DiscountInContainerUncheckedCreateNestedOneWithoutDiscountInput
  }

  export type DiscountCreateOrConnectWithoutSimpleDiscountInput = {
    where: DiscountWhereUniqueInput
    create: XOR<DiscountCreateWithoutSimpleDiscountInput, DiscountUncheckedCreateWithoutSimpleDiscountInput>
  }

  export type ConditionalDiscountCreateWithoutSimpleDiscountInput = {
    discount: DiscountCreateNestedOneWithoutConditionalDiscountInput
    discountPredicate?: DiscountPredicateCreateNestedOneWithoutDiscountInput
  }

  export type ConditionalDiscountUncheckedCreateWithoutSimpleDiscountInput = {
    id: number
    shopId: number
    discountPredicate?: DiscountPredicateUncheckedCreateNestedOneWithoutDiscountInput
  }

  export type ConditionalDiscountCreateOrConnectWithoutSimpleDiscountInput = {
    where: ConditionalDiscountWhereUniqueInput
    create: XOR<ConditionalDiscountCreateWithoutSimpleDiscountInput, ConditionalDiscountUncheckedCreateWithoutSimpleDiscountInput>
  }

  export type DiscountUpsertWithoutSimpleDiscountInput = {
    update: XOR<DiscountUpdateWithoutSimpleDiscountInput, DiscountUncheckedUpdateWithoutSimpleDiscountInput>
    create: XOR<DiscountCreateWithoutSimpleDiscountInput, DiscountUncheckedCreateWithoutSimpleDiscountInput>
  }

  export type DiscountUpdateWithoutSimpleDiscountInput = {
    id?: IntFieldUpdateOperationsInput | number
    shop?: ShopUpdateOneRequiredWithoutDiscountsInput
    kind?: EnumDiscountKindsFieldUpdateOperationsInput | DiscountKinds
    conditionalDiscount?: ConditionalDiscountUpdateOneWithoutDiscountInput
    discountContainer?: DiscountContainerUpdateOneWithoutDiscountInput
    discountInContainer?: DiscountInContainerUpdateOneWithoutDiscountInput
  }

  export type DiscountUncheckedUpdateWithoutSimpleDiscountInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    kind?: EnumDiscountKindsFieldUpdateOperationsInput | DiscountKinds
    conditionalDiscount?: ConditionalDiscountUncheckedUpdateOneWithoutDiscountInput
    discountContainer?: DiscountContainerUncheckedUpdateOneWithoutDiscountInput
    discountInContainer?: DiscountInContainerUncheckedUpdateOneWithoutDiscountInput
  }

  export type ConditionalDiscountUpsertWithoutSimpleDiscountInput = {
    update: XOR<ConditionalDiscountUpdateWithoutSimpleDiscountInput, ConditionalDiscountUncheckedUpdateWithoutSimpleDiscountInput>
    create: XOR<ConditionalDiscountCreateWithoutSimpleDiscountInput, ConditionalDiscountUncheckedCreateWithoutSimpleDiscountInput>
  }

  export type ConditionalDiscountUpdateWithoutSimpleDiscountInput = {
    discount?: DiscountUpdateOneRequiredWithoutConditionalDiscountInput
    discountPredicate?: DiscountPredicateUpdateOneWithoutDiscountInput
  }

  export type ConditionalDiscountUncheckedUpdateWithoutSimpleDiscountInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    discountPredicate?: DiscountPredicateUncheckedUpdateOneWithoutDiscountInput
  }

  export type DiscountCreateWithoutConditionalDiscountInput = {
    id: number
    shop: ShopCreateNestedOneWithoutDiscountsInput
    kind: DiscountKinds
    simpleDiscount?: SimpleDiscountCreateNestedOneWithoutDiscountInput
    discountContainer?: DiscountContainerCreateNestedOneWithoutDiscountInput
    discountInContainer?: DiscountInContainerCreateNestedOneWithoutDiscountInput
  }

  export type DiscountUncheckedCreateWithoutConditionalDiscountInput = {
    id: number
    shopId: number
    kind: DiscountKinds
    simpleDiscount?: SimpleDiscountUncheckedCreateNestedOneWithoutDiscountInput
    discountContainer?: DiscountContainerUncheckedCreateNestedOneWithoutDiscountInput
    discountInContainer?: DiscountInContainerUncheckedCreateNestedOneWithoutDiscountInput
  }

  export type DiscountCreateOrConnectWithoutConditionalDiscountInput = {
    where: DiscountWhereUniqueInput
    create: XOR<DiscountCreateWithoutConditionalDiscountInput, DiscountUncheckedCreateWithoutConditionalDiscountInput>
  }

  export type SimpleDiscountCreateWithoutConditionalDiscountInput = {
    discount: DiscountCreateNestedOneWithoutSimpleDiscountInput
    discountType: DiscountType
    discountPercent: number
    description: string
    productId?: number | null
    category?: ProductCategory | null
  }

  export type SimpleDiscountUncheckedCreateWithoutConditionalDiscountInput = {
    id: number
    shopId: number
    discountType: DiscountType
    discountPercent: number
    description: string
    productId?: number | null
    category?: ProductCategory | null
  }

  export type SimpleDiscountCreateOrConnectWithoutConditionalDiscountInput = {
    where: SimpleDiscountWhereUniqueInput
    create: XOR<SimpleDiscountCreateWithoutConditionalDiscountInput, SimpleDiscountUncheckedCreateWithoutConditionalDiscountInput>
  }

  export type DiscountPredicateCreateWithoutDiscountInput = {
    discountType: DiscountType
    relation: RelationType
    value: number
    description: string
    productId?: number | null
    category?: ProductCategory | null
  }

  export type DiscountPredicateUncheckedCreateWithoutDiscountInput = {
    discountType: DiscountType
    relation: RelationType
    value: number
    description: string
    productId?: number | null
    category?: ProductCategory | null
  }

  export type DiscountPredicateCreateOrConnectWithoutDiscountInput = {
    where: DiscountPredicateWhereUniqueInput
    create: XOR<DiscountPredicateCreateWithoutDiscountInput, DiscountPredicateUncheckedCreateWithoutDiscountInput>
  }

  export type DiscountUpsertWithoutConditionalDiscountInput = {
    update: XOR<DiscountUpdateWithoutConditionalDiscountInput, DiscountUncheckedUpdateWithoutConditionalDiscountInput>
    create: XOR<DiscountCreateWithoutConditionalDiscountInput, DiscountUncheckedCreateWithoutConditionalDiscountInput>
  }

  export type DiscountUpdateWithoutConditionalDiscountInput = {
    id?: IntFieldUpdateOperationsInput | number
    shop?: ShopUpdateOneRequiredWithoutDiscountsInput
    kind?: EnumDiscountKindsFieldUpdateOperationsInput | DiscountKinds
    simpleDiscount?: SimpleDiscountUpdateOneWithoutDiscountInput
    discountContainer?: DiscountContainerUpdateOneWithoutDiscountInput
    discountInContainer?: DiscountInContainerUpdateOneWithoutDiscountInput
  }

  export type DiscountUncheckedUpdateWithoutConditionalDiscountInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    kind?: EnumDiscountKindsFieldUpdateOperationsInput | DiscountKinds
    simpleDiscount?: SimpleDiscountUncheckedUpdateOneWithoutDiscountInput
    discountContainer?: DiscountContainerUncheckedUpdateOneWithoutDiscountInput
    discountInContainer?: DiscountInContainerUncheckedUpdateOneWithoutDiscountInput
  }

  export type SimpleDiscountUpsertWithoutConditionalDiscountInput = {
    update: XOR<SimpleDiscountUpdateWithoutConditionalDiscountInput, SimpleDiscountUncheckedUpdateWithoutConditionalDiscountInput>
    create: XOR<SimpleDiscountCreateWithoutConditionalDiscountInput, SimpleDiscountUncheckedCreateWithoutConditionalDiscountInput>
  }

  export type SimpleDiscountUpdateWithoutConditionalDiscountInput = {
    discount?: DiscountUpdateOneRequiredWithoutSimpleDiscountInput
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | DiscountType
    discountPercent?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableEnumProductCategoryFieldUpdateOperationsInput | ProductCategory | null
  }

  export type SimpleDiscountUncheckedUpdateWithoutConditionalDiscountInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | DiscountType
    discountPercent?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableEnumProductCategoryFieldUpdateOperationsInput | ProductCategory | null
  }

  export type DiscountPredicateUpsertWithoutDiscountInput = {
    update: XOR<DiscountPredicateUpdateWithoutDiscountInput, DiscountPredicateUncheckedUpdateWithoutDiscountInput>
    create: XOR<DiscountPredicateCreateWithoutDiscountInput, DiscountPredicateUncheckedCreateWithoutDiscountInput>
  }

  export type DiscountPredicateUpdateWithoutDiscountInput = {
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | DiscountType
    relation?: EnumRelationTypeFieldUpdateOperationsInput | RelationType
    value?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableEnumProductCategoryFieldUpdateOperationsInput | ProductCategory | null
  }

  export type DiscountPredicateUncheckedUpdateWithoutDiscountInput = {
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | DiscountType
    relation?: EnumRelationTypeFieldUpdateOperationsInput | RelationType
    value?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableEnumProductCategoryFieldUpdateOperationsInput | ProductCategory | null
  }

  export type ConditionalDiscountCreateWithoutDiscountPredicateInput = {
    discount: DiscountCreateNestedOneWithoutConditionalDiscountInput
    simpleDiscount: SimpleDiscountCreateNestedOneWithoutConditionalDiscountInput
  }

  export type ConditionalDiscountUncheckedCreateWithoutDiscountPredicateInput = {
    id: number
    shopId: number
    simpleId: number
    simpleShopId: number
  }

  export type ConditionalDiscountCreateOrConnectWithoutDiscountPredicateInput = {
    where: ConditionalDiscountWhereUniqueInput
    create: XOR<ConditionalDiscountCreateWithoutDiscountPredicateInput, ConditionalDiscountUncheckedCreateWithoutDiscountPredicateInput>
  }

  export type ConditionalDiscountUpsertWithoutDiscountPredicateInput = {
    update: XOR<ConditionalDiscountUpdateWithoutDiscountPredicateInput, ConditionalDiscountUncheckedUpdateWithoutDiscountPredicateInput>
    create: XOR<ConditionalDiscountCreateWithoutDiscountPredicateInput, ConditionalDiscountUncheckedCreateWithoutDiscountPredicateInput>
  }

  export type ConditionalDiscountUpdateWithoutDiscountPredicateInput = {
    discount?: DiscountUpdateOneRequiredWithoutConditionalDiscountInput
    simpleDiscount?: SimpleDiscountUpdateOneRequiredWithoutConditionalDiscountInput
  }

  export type ConditionalDiscountUncheckedUpdateWithoutDiscountPredicateInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    simpleId?: IntFieldUpdateOperationsInput | number
    simpleShopId?: IntFieldUpdateOperationsInput | number
  }

  export type DiscountCreateWithoutDiscountContainerInput = {
    id: number
    shop: ShopCreateNestedOneWithoutDiscountsInput
    kind: DiscountKinds
    simpleDiscount?: SimpleDiscountCreateNestedOneWithoutDiscountInput
    conditionalDiscount?: ConditionalDiscountCreateNestedOneWithoutDiscountInput
    discountInContainer?: DiscountInContainerCreateNestedOneWithoutDiscountInput
  }

  export type DiscountUncheckedCreateWithoutDiscountContainerInput = {
    id: number
    shopId: number
    kind: DiscountKinds
    simpleDiscount?: SimpleDiscountUncheckedCreateNestedOneWithoutDiscountInput
    conditionalDiscount?: ConditionalDiscountUncheckedCreateNestedOneWithoutDiscountInput
    discountInContainer?: DiscountInContainerUncheckedCreateNestedOneWithoutDiscountInput
  }

  export type DiscountCreateOrConnectWithoutDiscountContainerInput = {
    where: DiscountWhereUniqueInput
    create: XOR<DiscountCreateWithoutDiscountContainerInput, DiscountUncheckedCreateWithoutDiscountContainerInput>
  }

  export type DiscountInContainerCreateWithoutDiscountContainerInput = {
    discount: DiscountCreateNestedOneWithoutDiscountInContainerInput
  }

  export type DiscountInContainerUncheckedCreateWithoutDiscountContainerInput = {
    containedDiscount: number
  }

  export type DiscountInContainerCreateOrConnectWithoutDiscountContainerInput = {
    where: DiscountInContainerWhereUniqueInput
    create: XOR<DiscountInContainerCreateWithoutDiscountContainerInput, DiscountInContainerUncheckedCreateWithoutDiscountContainerInput>
  }

  export type DiscountInContainerCreateManyDiscountContainerInputEnvelope = {
    data: Enumerable<DiscountInContainerCreateManyDiscountContainerInput>
    skipDuplicates?: boolean
  }

  export type DiscountUpsertWithoutDiscountContainerInput = {
    update: XOR<DiscountUpdateWithoutDiscountContainerInput, DiscountUncheckedUpdateWithoutDiscountContainerInput>
    create: XOR<DiscountCreateWithoutDiscountContainerInput, DiscountUncheckedCreateWithoutDiscountContainerInput>
  }

  export type DiscountUpdateWithoutDiscountContainerInput = {
    id?: IntFieldUpdateOperationsInput | number
    shop?: ShopUpdateOneRequiredWithoutDiscountsInput
    kind?: EnumDiscountKindsFieldUpdateOperationsInput | DiscountKinds
    simpleDiscount?: SimpleDiscountUpdateOneWithoutDiscountInput
    conditionalDiscount?: ConditionalDiscountUpdateOneWithoutDiscountInput
    discountInContainer?: DiscountInContainerUpdateOneWithoutDiscountInput
  }

  export type DiscountUncheckedUpdateWithoutDiscountContainerInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    kind?: EnumDiscountKindsFieldUpdateOperationsInput | DiscountKinds
    simpleDiscount?: SimpleDiscountUncheckedUpdateOneWithoutDiscountInput
    conditionalDiscount?: ConditionalDiscountUncheckedUpdateOneWithoutDiscountInput
    discountInContainer?: DiscountInContainerUncheckedUpdateOneWithoutDiscountInput
  }

  export type DiscountInContainerUpsertWithWhereUniqueWithoutDiscountContainerInput = {
    where: DiscountInContainerWhereUniqueInput
    update: XOR<DiscountInContainerUpdateWithoutDiscountContainerInput, DiscountInContainerUncheckedUpdateWithoutDiscountContainerInput>
    create: XOR<DiscountInContainerCreateWithoutDiscountContainerInput, DiscountInContainerUncheckedCreateWithoutDiscountContainerInput>
  }

  export type DiscountInContainerUpdateWithWhereUniqueWithoutDiscountContainerInput = {
    where: DiscountInContainerWhereUniqueInput
    data: XOR<DiscountInContainerUpdateWithoutDiscountContainerInput, DiscountInContainerUncheckedUpdateWithoutDiscountContainerInput>
  }

  export type DiscountInContainerUpdateManyWithWhereWithoutDiscountContainerInput = {
    where: DiscountInContainerScalarWhereInput
    data: XOR<DiscountInContainerUpdateManyMutationInput, DiscountInContainerUncheckedUpdateManyWithoutDiscountsInput>
  }

  export type DiscountInContainerScalarWhereInput = {
    AND?: Enumerable<DiscountInContainerScalarWhereInput>
    OR?: Enumerable<DiscountInContainerScalarWhereInput>
    NOT?: Enumerable<DiscountInContainerScalarWhereInput>
    containedDiscount?: IntFilter | number
    shopId?: IntFilter | number
    containingDiscount?: IntFilter | number
  }

  export type DiscountCreateWithoutDiscountInContainerInput = {
    id: number
    shop: ShopCreateNestedOneWithoutDiscountsInput
    kind: DiscountKinds
    simpleDiscount?: SimpleDiscountCreateNestedOneWithoutDiscountInput
    conditionalDiscount?: ConditionalDiscountCreateNestedOneWithoutDiscountInput
    discountContainer?: DiscountContainerCreateNestedOneWithoutDiscountInput
  }

  export type DiscountUncheckedCreateWithoutDiscountInContainerInput = {
    id: number
    shopId: number
    kind: DiscountKinds
    simpleDiscount?: SimpleDiscountUncheckedCreateNestedOneWithoutDiscountInput
    conditionalDiscount?: ConditionalDiscountUncheckedCreateNestedOneWithoutDiscountInput
    discountContainer?: DiscountContainerUncheckedCreateNestedOneWithoutDiscountInput
  }

  export type DiscountCreateOrConnectWithoutDiscountInContainerInput = {
    where: DiscountWhereUniqueInput
    create: XOR<DiscountCreateWithoutDiscountInContainerInput, DiscountUncheckedCreateWithoutDiscountInContainerInput>
  }

  export type DiscountContainerCreateWithoutDiscountsInput = {
    discount: DiscountCreateNestedOneWithoutDiscountContainerInput
    description: string
    type: DiscountRelation
  }

  export type DiscountContainerUncheckedCreateWithoutDiscountsInput = {
    id: number
    shopId: number
    description: string
    type: DiscountRelation
  }

  export type DiscountContainerCreateOrConnectWithoutDiscountsInput = {
    where: DiscountContainerWhereUniqueInput
    create: XOR<DiscountContainerCreateWithoutDiscountsInput, DiscountContainerUncheckedCreateWithoutDiscountsInput>
  }

  export type DiscountUpsertWithoutDiscountInContainerInput = {
    update: XOR<DiscountUpdateWithoutDiscountInContainerInput, DiscountUncheckedUpdateWithoutDiscountInContainerInput>
    create: XOR<DiscountCreateWithoutDiscountInContainerInput, DiscountUncheckedCreateWithoutDiscountInContainerInput>
  }

  export type DiscountUpdateWithoutDiscountInContainerInput = {
    id?: IntFieldUpdateOperationsInput | number
    shop?: ShopUpdateOneRequiredWithoutDiscountsInput
    kind?: EnumDiscountKindsFieldUpdateOperationsInput | DiscountKinds
    simpleDiscount?: SimpleDiscountUpdateOneWithoutDiscountInput
    conditionalDiscount?: ConditionalDiscountUpdateOneWithoutDiscountInput
    discountContainer?: DiscountContainerUpdateOneWithoutDiscountInput
  }

  export type DiscountUncheckedUpdateWithoutDiscountInContainerInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    kind?: EnumDiscountKindsFieldUpdateOperationsInput | DiscountKinds
    simpleDiscount?: SimpleDiscountUncheckedUpdateOneWithoutDiscountInput
    conditionalDiscount?: ConditionalDiscountUncheckedUpdateOneWithoutDiscountInput
    discountContainer?: DiscountContainerUncheckedUpdateOneWithoutDiscountInput
  }

  export type DiscountContainerUpsertWithoutDiscountsInput = {
    update: XOR<DiscountContainerUpdateWithoutDiscountsInput, DiscountContainerUncheckedUpdateWithoutDiscountsInput>
    create: XOR<DiscountContainerCreateWithoutDiscountsInput, DiscountContainerUncheckedCreateWithoutDiscountsInput>
  }

  export type DiscountContainerUpdateWithoutDiscountsInput = {
    discount?: DiscountUpdateOneRequiredWithoutDiscountContainerInput
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountRelationFieldUpdateOperationsInput | DiscountRelation
  }

  export type DiscountContainerUncheckedUpdateWithoutDiscountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountRelationFieldUpdateOperationsInput | DiscountRelation
  }

  export type ShopCreateWithoutPoliciesInput = {
    id: number
    name: string
    status: ShopStatus
    member: MemberCreateNestedOneWithoutShopsInput
    rate?: ShopRate
    description?: string | null
    role?: RoleCreateNestedManyWithoutShopInput
    products?: ProductCreateNestedManyWithoutShopInput
    products_in_shop?: ProductInShopCreateNestedManyWithoutShopInput
    bags?: ShoppingBagCreateNestedManyWithoutShopInput
    discounts?: DiscountCreateNestedManyWithoutShopInput
    offers?: OfferCreateNestedManyWithoutShopInput
    appointments?: AppointmentCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutPoliciesInput = {
    id: number
    name: string
    status: ShopStatus
    shop_founder: string
    rate?: ShopRate
    description?: string | null
    role?: RoleUncheckedCreateNestedManyWithoutShopInput
    products?: ProductUncheckedCreateNestedManyWithoutShopInput
    products_in_shop?: ProductInShopUncheckedCreateNestedManyWithoutShopInput
    bags?: ShoppingBagUncheckedCreateNestedManyWithoutShopInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutShopInput
    offers?: OfferUncheckedCreateNestedManyWithoutShopInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutPoliciesInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutPoliciesInput, ShopUncheckedCreateWithoutPoliciesInput>
  }

  export type SimplePolicyCreateWithoutPolicyInput = {
    okay: boolean
    message: string
  }

  export type SimplePolicyUncheckedCreateWithoutPolicyInput = {
    okay: boolean
    message: string
  }

  export type SimplePolicyCreateOrConnectWithoutPolicyInput = {
    where: SimplePolicyWhereUniqueInput
    create: XOR<SimplePolicyCreateWithoutPolicyInput, SimplePolicyUncheckedCreateWithoutPolicyInput>
  }

  export type ConditionalPolicyCreateWithoutPolicyInput = {
    dependent: number
    dependentShopId: number
    dependentOn: number
    dependentOnShopId: number
    description: string
    policyPredicate?: PolicyPredicateCreateNestedOneWithoutPolicyInput
  }

  export type ConditionalPolicyUncheckedCreateWithoutPolicyInput = {
    dependent: number
    dependentShopId: number
    dependentOn: number
    dependentOnShopId: number
    description: string
    policyPredicate?: PolicyPredicateUncheckedCreateNestedOneWithoutPolicyInput
  }

  export type ConditionalPolicyCreateOrConnectWithoutPolicyInput = {
    where: ConditionalPolicyWhereUniqueInput
    create: XOR<ConditionalPolicyCreateWithoutPolicyInput, ConditionalPolicyUncheckedCreateWithoutPolicyInput>
  }

  export type LogicalPolicyCreateWithoutPolicyInput = {
    description: string
    purchasePoliciesRelation: PurchasePoliciesRelation
    policies?: PolicyInContainerCreateNestedManyWithoutPolicyContainerInput
  }

  export type LogicalPolicyUncheckedCreateWithoutPolicyInput = {
    description: string
    purchasePoliciesRelation: PurchasePoliciesRelation
    policies?: PolicyInContainerUncheckedCreateNestedManyWithoutPolicyContainerInput
  }

  export type LogicalPolicyCreateOrConnectWithoutPolicyInput = {
    where: LogicalPolicyWhereUniqueInput
    create: XOR<LogicalPolicyCreateWithoutPolicyInput, LogicalPolicyUncheckedCreateWithoutPolicyInput>
  }

  export type PolicyInContainerCreateWithoutPolicyInput = {
    policyContainer: LogicalPolicyCreateNestedOneWithoutPoliciesInput
  }

  export type PolicyInContainerUncheckedCreateWithoutPolicyInput = {
    containingPolicy: number
  }

  export type PolicyInContainerCreateOrConnectWithoutPolicyInput = {
    where: PolicyInContainerWhereUniqueInput
    create: XOR<PolicyInContainerCreateWithoutPolicyInput, PolicyInContainerUncheckedCreateWithoutPolicyInput>
  }

  export type ShopUpsertWithoutPoliciesInput = {
    update: XOR<ShopUpdateWithoutPoliciesInput, ShopUncheckedUpdateWithoutPoliciesInput>
    create: XOR<ShopCreateWithoutPoliciesInput, ShopUncheckedCreateWithoutPoliciesInput>
  }

  export type ShopUpdateWithoutPoliciesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | ShopStatus
    member?: MemberUpdateOneRequiredWithoutShopsInput
    rate?: EnumShopRateFieldUpdateOperationsInput | ShopRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
    role?: RoleUpdateManyWithoutShopInput
    products?: ProductUpdateManyWithoutShopInput
    products_in_shop?: ProductInShopUpdateManyWithoutShopInput
    bags?: ShoppingBagUpdateManyWithoutShopInput
    discounts?: DiscountUpdateManyWithoutShopInput
    offers?: OfferUpdateManyWithoutShopInput
    appointments?: AppointmentUpdateManyWithoutShopInput
  }

  export type ShopUncheckedUpdateWithoutPoliciesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | ShopStatus
    shop_founder?: StringFieldUpdateOperationsInput | string
    rate?: EnumShopRateFieldUpdateOperationsInput | ShopRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
    role?: RoleUncheckedUpdateManyWithoutShopInput
    products?: ProductUncheckedUpdateManyWithoutShopInput
    products_in_shop?: ProductInShopUncheckedUpdateManyWithoutShopInput
    bags?: ShoppingBagUncheckedUpdateManyWithoutShopInput
    discounts?: DiscountUncheckedUpdateManyWithoutShopInput
    offers?: OfferUncheckedUpdateManyWithoutShopInput
    appointments?: AppointmentUncheckedUpdateManyWithoutShopInput
  }

  export type SimplePolicyUpsertWithoutPolicyInput = {
    update: XOR<SimplePolicyUpdateWithoutPolicyInput, SimplePolicyUncheckedUpdateWithoutPolicyInput>
    create: XOR<SimplePolicyCreateWithoutPolicyInput, SimplePolicyUncheckedCreateWithoutPolicyInput>
  }

  export type SimplePolicyUpdateWithoutPolicyInput = {
    okay?: BoolFieldUpdateOperationsInput | boolean
    message?: StringFieldUpdateOperationsInput | string
  }

  export type SimplePolicyUncheckedUpdateWithoutPolicyInput = {
    okay?: BoolFieldUpdateOperationsInput | boolean
    message?: StringFieldUpdateOperationsInput | string
  }

  export type ConditionalPolicyUpsertWithoutPolicyInput = {
    update: XOR<ConditionalPolicyUpdateWithoutPolicyInput, ConditionalPolicyUncheckedUpdateWithoutPolicyInput>
    create: XOR<ConditionalPolicyCreateWithoutPolicyInput, ConditionalPolicyUncheckedCreateWithoutPolicyInput>
  }

  export type ConditionalPolicyUpdateWithoutPolicyInput = {
    dependent?: IntFieldUpdateOperationsInput | number
    dependentShopId?: IntFieldUpdateOperationsInput | number
    dependentOn?: IntFieldUpdateOperationsInput | number
    dependentOnShopId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    policyPredicate?: PolicyPredicateUpdateOneWithoutPolicyInput
  }

  export type ConditionalPolicyUncheckedUpdateWithoutPolicyInput = {
    dependent?: IntFieldUpdateOperationsInput | number
    dependentShopId?: IntFieldUpdateOperationsInput | number
    dependentOn?: IntFieldUpdateOperationsInput | number
    dependentOnShopId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    policyPredicate?: PolicyPredicateUncheckedUpdateOneWithoutPolicyInput
  }

  export type LogicalPolicyUpsertWithoutPolicyInput = {
    update: XOR<LogicalPolicyUpdateWithoutPolicyInput, LogicalPolicyUncheckedUpdateWithoutPolicyInput>
    create: XOR<LogicalPolicyCreateWithoutPolicyInput, LogicalPolicyUncheckedCreateWithoutPolicyInput>
  }

  export type LogicalPolicyUpdateWithoutPolicyInput = {
    description?: StringFieldUpdateOperationsInput | string
    purchasePoliciesRelation?: EnumPurchasePoliciesRelationFieldUpdateOperationsInput | PurchasePoliciesRelation
    policies?: PolicyInContainerUpdateManyWithoutPolicyContainerInput
  }

  export type LogicalPolicyUncheckedUpdateWithoutPolicyInput = {
    description?: StringFieldUpdateOperationsInput | string
    purchasePoliciesRelation?: EnumPurchasePoliciesRelationFieldUpdateOperationsInput | PurchasePoliciesRelation
    policies?: PolicyInContainerUncheckedUpdateManyWithoutPolicyContainerInput
  }

  export type PolicyInContainerUpsertWithoutPolicyInput = {
    update: XOR<PolicyInContainerUpdateWithoutPolicyInput, PolicyInContainerUncheckedUpdateWithoutPolicyInput>
    create: XOR<PolicyInContainerCreateWithoutPolicyInput, PolicyInContainerUncheckedCreateWithoutPolicyInput>
  }

  export type PolicyInContainerUpdateWithoutPolicyInput = {
    policyContainer?: LogicalPolicyUpdateOneRequiredWithoutPoliciesInput
  }

  export type PolicyInContainerUncheckedUpdateWithoutPolicyInput = {
    containingPolicy?: IntFieldUpdateOperationsInput | number
  }

  export type PolicyCreateWithoutSimplePolicyInput = {
    id: number
    shop: ShopCreateNestedOneWithoutPoliciesInput
    conditionalPolicy?: ConditionalPolicyCreateNestedOneWithoutPolicyInput
    logicalPolicy?: LogicalPolicyCreateNestedOneWithoutPolicyInput
    policyInContainer?: PolicyInContainerCreateNestedOneWithoutPolicyInput
  }

  export type PolicyUncheckedCreateWithoutSimplePolicyInput = {
    id: number
    shopId: number
    conditionalPolicy?: ConditionalPolicyUncheckedCreateNestedOneWithoutPolicyInput
    logicalPolicy?: LogicalPolicyUncheckedCreateNestedOneWithoutPolicyInput
    policyInContainer?: PolicyInContainerUncheckedCreateNestedOneWithoutPolicyInput
  }

  export type PolicyCreateOrConnectWithoutSimplePolicyInput = {
    where: PolicyWhereUniqueInput
    create: XOR<PolicyCreateWithoutSimplePolicyInput, PolicyUncheckedCreateWithoutSimplePolicyInput>
  }

  export type PolicyUpsertWithoutSimplePolicyInput = {
    update: XOR<PolicyUpdateWithoutSimplePolicyInput, PolicyUncheckedUpdateWithoutSimplePolicyInput>
    create: XOR<PolicyCreateWithoutSimplePolicyInput, PolicyUncheckedCreateWithoutSimplePolicyInput>
  }

  export type PolicyUpdateWithoutSimplePolicyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shop?: ShopUpdateOneRequiredWithoutPoliciesInput
    conditionalPolicy?: ConditionalPolicyUpdateOneWithoutPolicyInput
    logicalPolicy?: LogicalPolicyUpdateOneWithoutPolicyInput
    policyInContainer?: PolicyInContainerUpdateOneWithoutPolicyInput
  }

  export type PolicyUncheckedUpdateWithoutSimplePolicyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    conditionalPolicy?: ConditionalPolicyUncheckedUpdateOneWithoutPolicyInput
    logicalPolicy?: LogicalPolicyUncheckedUpdateOneWithoutPolicyInput
    policyInContainer?: PolicyInContainerUncheckedUpdateOneWithoutPolicyInput
  }

  export type PolicyCreateWithoutConditionalPolicyInput = {
    id: number
    shop: ShopCreateNestedOneWithoutPoliciesInput
    simplePolicy?: SimplePolicyCreateNestedOneWithoutPolicyInput
    logicalPolicy?: LogicalPolicyCreateNestedOneWithoutPolicyInput
    policyInContainer?: PolicyInContainerCreateNestedOneWithoutPolicyInput
  }

  export type PolicyUncheckedCreateWithoutConditionalPolicyInput = {
    id: number
    shopId: number
    simplePolicy?: SimplePolicyUncheckedCreateNestedOneWithoutPolicyInput
    logicalPolicy?: LogicalPolicyUncheckedCreateNestedOneWithoutPolicyInput
    policyInContainer?: PolicyInContainerUncheckedCreateNestedOneWithoutPolicyInput
  }

  export type PolicyCreateOrConnectWithoutConditionalPolicyInput = {
    where: PolicyWhereUniqueInput
    create: XOR<PolicyCreateWithoutConditionalPolicyInput, PolicyUncheckedCreateWithoutConditionalPolicyInput>
  }

  export type PolicyPredicateCreateWithoutPolicyInput = {
    policyType: SimplePolicyType
    relation: RelationType
    value: number
    description: string
    productId?: number | null
    productCategory?: ProductCategory | null
    guest?: string | null
  }

  export type PolicyPredicateUncheckedCreateWithoutPolicyInput = {
    policyType: SimplePolicyType
    relation: RelationType
    value: number
    description: string
    productId?: number | null
    productCategory?: ProductCategory | null
    guest?: string | null
  }

  export type PolicyPredicateCreateOrConnectWithoutPolicyInput = {
    where: PolicyPredicateWhereUniqueInput
    create: XOR<PolicyPredicateCreateWithoutPolicyInput, PolicyPredicateUncheckedCreateWithoutPolicyInput>
  }

  export type PolicyUpsertWithoutConditionalPolicyInput = {
    update: XOR<PolicyUpdateWithoutConditionalPolicyInput, PolicyUncheckedUpdateWithoutConditionalPolicyInput>
    create: XOR<PolicyCreateWithoutConditionalPolicyInput, PolicyUncheckedCreateWithoutConditionalPolicyInput>
  }

  export type PolicyUpdateWithoutConditionalPolicyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shop?: ShopUpdateOneRequiredWithoutPoliciesInput
    simplePolicy?: SimplePolicyUpdateOneWithoutPolicyInput
    logicalPolicy?: LogicalPolicyUpdateOneWithoutPolicyInput
    policyInContainer?: PolicyInContainerUpdateOneWithoutPolicyInput
  }

  export type PolicyUncheckedUpdateWithoutConditionalPolicyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    simplePolicy?: SimplePolicyUncheckedUpdateOneWithoutPolicyInput
    logicalPolicy?: LogicalPolicyUncheckedUpdateOneWithoutPolicyInput
    policyInContainer?: PolicyInContainerUncheckedUpdateOneWithoutPolicyInput
  }

  export type PolicyPredicateUpsertWithoutPolicyInput = {
    update: XOR<PolicyPredicateUpdateWithoutPolicyInput, PolicyPredicateUncheckedUpdateWithoutPolicyInput>
    create: XOR<PolicyPredicateCreateWithoutPolicyInput, PolicyPredicateUncheckedCreateWithoutPolicyInput>
  }

  export type PolicyPredicateUpdateWithoutPolicyInput = {
    policyType?: EnumSimplePolicyTypeFieldUpdateOperationsInput | SimplePolicyType
    relation?: EnumRelationTypeFieldUpdateOperationsInput | RelationType
    value?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    productCategory?: NullableEnumProductCategoryFieldUpdateOperationsInput | ProductCategory | null
    guest?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PolicyPredicateUncheckedUpdateWithoutPolicyInput = {
    policyType?: EnumSimplePolicyTypeFieldUpdateOperationsInput | SimplePolicyType
    relation?: EnumRelationTypeFieldUpdateOperationsInput | RelationType
    value?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    productCategory?: NullableEnumProductCategoryFieldUpdateOperationsInput | ProductCategory | null
    guest?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConditionalPolicyCreateWithoutPolicyPredicateInput = {
    policy: PolicyCreateNestedOneWithoutConditionalPolicyInput
    dependent: number
    dependentShopId: number
    dependentOn: number
    dependentOnShopId: number
    description: string
  }

  export type ConditionalPolicyUncheckedCreateWithoutPolicyPredicateInput = {
    id: number
    shopId: number
    dependent: number
    dependentShopId: number
    dependentOn: number
    dependentOnShopId: number
    description: string
  }

  export type ConditionalPolicyCreateOrConnectWithoutPolicyPredicateInput = {
    where: ConditionalPolicyWhereUniqueInput
    create: XOR<ConditionalPolicyCreateWithoutPolicyPredicateInput, ConditionalPolicyUncheckedCreateWithoutPolicyPredicateInput>
  }

  export type ConditionalPolicyUpsertWithoutPolicyPredicateInput = {
    update: XOR<ConditionalPolicyUpdateWithoutPolicyPredicateInput, ConditionalPolicyUncheckedUpdateWithoutPolicyPredicateInput>
    create: XOR<ConditionalPolicyCreateWithoutPolicyPredicateInput, ConditionalPolicyUncheckedCreateWithoutPolicyPredicateInput>
  }

  export type ConditionalPolicyUpdateWithoutPolicyPredicateInput = {
    policy?: PolicyUpdateOneRequiredWithoutConditionalPolicyInput
    dependent?: IntFieldUpdateOperationsInput | number
    dependentShopId?: IntFieldUpdateOperationsInput | number
    dependentOn?: IntFieldUpdateOperationsInput | number
    dependentOnShopId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ConditionalPolicyUncheckedUpdateWithoutPolicyPredicateInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    dependent?: IntFieldUpdateOperationsInput | number
    dependentShopId?: IntFieldUpdateOperationsInput | number
    dependentOn?: IntFieldUpdateOperationsInput | number
    dependentOnShopId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
  }

  export type PolicyCreateWithoutLogicalPolicyInput = {
    id: number
    shop: ShopCreateNestedOneWithoutPoliciesInput
    simplePolicy?: SimplePolicyCreateNestedOneWithoutPolicyInput
    conditionalPolicy?: ConditionalPolicyCreateNestedOneWithoutPolicyInput
    policyInContainer?: PolicyInContainerCreateNestedOneWithoutPolicyInput
  }

  export type PolicyUncheckedCreateWithoutLogicalPolicyInput = {
    id: number
    shopId: number
    simplePolicy?: SimplePolicyUncheckedCreateNestedOneWithoutPolicyInput
    conditionalPolicy?: ConditionalPolicyUncheckedCreateNestedOneWithoutPolicyInput
    policyInContainer?: PolicyInContainerUncheckedCreateNestedOneWithoutPolicyInput
  }

  export type PolicyCreateOrConnectWithoutLogicalPolicyInput = {
    where: PolicyWhereUniqueInput
    create: XOR<PolicyCreateWithoutLogicalPolicyInput, PolicyUncheckedCreateWithoutLogicalPolicyInput>
  }

  export type PolicyInContainerCreateWithoutPolicyContainerInput = {
    policy: PolicyCreateNestedOneWithoutPolicyInContainerInput
  }

  export type PolicyInContainerUncheckedCreateWithoutPolicyContainerInput = {
    containedPolicy: number
  }

  export type PolicyInContainerCreateOrConnectWithoutPolicyContainerInput = {
    where: PolicyInContainerWhereUniqueInput
    create: XOR<PolicyInContainerCreateWithoutPolicyContainerInput, PolicyInContainerUncheckedCreateWithoutPolicyContainerInput>
  }

  export type PolicyInContainerCreateManyPolicyContainerInputEnvelope = {
    data: Enumerable<PolicyInContainerCreateManyPolicyContainerInput>
    skipDuplicates?: boolean
  }

  export type PolicyUpsertWithoutLogicalPolicyInput = {
    update: XOR<PolicyUpdateWithoutLogicalPolicyInput, PolicyUncheckedUpdateWithoutLogicalPolicyInput>
    create: XOR<PolicyCreateWithoutLogicalPolicyInput, PolicyUncheckedCreateWithoutLogicalPolicyInput>
  }

  export type PolicyUpdateWithoutLogicalPolicyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shop?: ShopUpdateOneRequiredWithoutPoliciesInput
    simplePolicy?: SimplePolicyUpdateOneWithoutPolicyInput
    conditionalPolicy?: ConditionalPolicyUpdateOneWithoutPolicyInput
    policyInContainer?: PolicyInContainerUpdateOneWithoutPolicyInput
  }

  export type PolicyUncheckedUpdateWithoutLogicalPolicyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    simplePolicy?: SimplePolicyUncheckedUpdateOneWithoutPolicyInput
    conditionalPolicy?: ConditionalPolicyUncheckedUpdateOneWithoutPolicyInput
    policyInContainer?: PolicyInContainerUncheckedUpdateOneWithoutPolicyInput
  }

  export type PolicyInContainerUpsertWithWhereUniqueWithoutPolicyContainerInput = {
    where: PolicyInContainerWhereUniqueInput
    update: XOR<PolicyInContainerUpdateWithoutPolicyContainerInput, PolicyInContainerUncheckedUpdateWithoutPolicyContainerInput>
    create: XOR<PolicyInContainerCreateWithoutPolicyContainerInput, PolicyInContainerUncheckedCreateWithoutPolicyContainerInput>
  }

  export type PolicyInContainerUpdateWithWhereUniqueWithoutPolicyContainerInput = {
    where: PolicyInContainerWhereUniqueInput
    data: XOR<PolicyInContainerUpdateWithoutPolicyContainerInput, PolicyInContainerUncheckedUpdateWithoutPolicyContainerInput>
  }

  export type PolicyInContainerUpdateManyWithWhereWithoutPolicyContainerInput = {
    where: PolicyInContainerScalarWhereInput
    data: XOR<PolicyInContainerUpdateManyMutationInput, PolicyInContainerUncheckedUpdateManyWithoutPoliciesInput>
  }

  export type PolicyInContainerScalarWhereInput = {
    AND?: Enumerable<PolicyInContainerScalarWhereInput>
    OR?: Enumerable<PolicyInContainerScalarWhereInput>
    NOT?: Enumerable<PolicyInContainerScalarWhereInput>
    containedPolicy?: IntFilter | number
    shopId?: IntFilter | number
    containingPolicy?: IntFilter | number
  }

  export type PolicyCreateWithoutPolicyInContainerInput = {
    id: number
    shop: ShopCreateNestedOneWithoutPoliciesInput
    simplePolicy?: SimplePolicyCreateNestedOneWithoutPolicyInput
    conditionalPolicy?: ConditionalPolicyCreateNestedOneWithoutPolicyInput
    logicalPolicy?: LogicalPolicyCreateNestedOneWithoutPolicyInput
  }

  export type PolicyUncheckedCreateWithoutPolicyInContainerInput = {
    id: number
    shopId: number
    simplePolicy?: SimplePolicyUncheckedCreateNestedOneWithoutPolicyInput
    conditionalPolicy?: ConditionalPolicyUncheckedCreateNestedOneWithoutPolicyInput
    logicalPolicy?: LogicalPolicyUncheckedCreateNestedOneWithoutPolicyInput
  }

  export type PolicyCreateOrConnectWithoutPolicyInContainerInput = {
    where: PolicyWhereUniqueInput
    create: XOR<PolicyCreateWithoutPolicyInContainerInput, PolicyUncheckedCreateWithoutPolicyInContainerInput>
  }

  export type LogicalPolicyCreateWithoutPoliciesInput = {
    policy: PolicyCreateNestedOneWithoutLogicalPolicyInput
    description: string
    purchasePoliciesRelation: PurchasePoliciesRelation
  }

  export type LogicalPolicyUncheckedCreateWithoutPoliciesInput = {
    id: number
    shopId: number
    description: string
    purchasePoliciesRelation: PurchasePoliciesRelation
  }

  export type LogicalPolicyCreateOrConnectWithoutPoliciesInput = {
    where: LogicalPolicyWhereUniqueInput
    create: XOR<LogicalPolicyCreateWithoutPoliciesInput, LogicalPolicyUncheckedCreateWithoutPoliciesInput>
  }

  export type PolicyUpsertWithoutPolicyInContainerInput = {
    update: XOR<PolicyUpdateWithoutPolicyInContainerInput, PolicyUncheckedUpdateWithoutPolicyInContainerInput>
    create: XOR<PolicyCreateWithoutPolicyInContainerInput, PolicyUncheckedCreateWithoutPolicyInContainerInput>
  }

  export type PolicyUpdateWithoutPolicyInContainerInput = {
    id?: IntFieldUpdateOperationsInput | number
    shop?: ShopUpdateOneRequiredWithoutPoliciesInput
    simplePolicy?: SimplePolicyUpdateOneWithoutPolicyInput
    conditionalPolicy?: ConditionalPolicyUpdateOneWithoutPolicyInput
    logicalPolicy?: LogicalPolicyUpdateOneWithoutPolicyInput
  }

  export type PolicyUncheckedUpdateWithoutPolicyInContainerInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    simplePolicy?: SimplePolicyUncheckedUpdateOneWithoutPolicyInput
    conditionalPolicy?: ConditionalPolicyUncheckedUpdateOneWithoutPolicyInput
    logicalPolicy?: LogicalPolicyUncheckedUpdateOneWithoutPolicyInput
  }

  export type LogicalPolicyUpsertWithoutPoliciesInput = {
    update: XOR<LogicalPolicyUpdateWithoutPoliciesInput, LogicalPolicyUncheckedUpdateWithoutPoliciesInput>
    create: XOR<LogicalPolicyCreateWithoutPoliciesInput, LogicalPolicyUncheckedCreateWithoutPoliciesInput>
  }

  export type LogicalPolicyUpdateWithoutPoliciesInput = {
    policy?: PolicyUpdateOneRequiredWithoutLogicalPolicyInput
    description?: StringFieldUpdateOperationsInput | string
    purchasePoliciesRelation?: EnumPurchasePoliciesRelationFieldUpdateOperationsInput | PurchasePoliciesRelation
  }

  export type LogicalPolicyUncheckedUpdateWithoutPoliciesInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    purchasePoliciesRelation?: EnumPurchasePoliciesRelationFieldUpdateOperationsInput | PurchasePoliciesRelation
  }

  export type MemberCreateWithoutOffersInput = {
    username: string
    roles?: RoleCreateNestedManyWithoutMemberInput
    shops?: ShopCreateNestedManyWithoutMemberInput
    ShoppingCart?: ShoppingCartCreateNestedOneWithoutMemberInput
    MemberCredentials?: MemberCredentialsCreateNestedOneWithoutMemberInput
    offerApprovers?: OfferApproverCreateNestedManyWithoutMemberInput
    appointments?: AppointmentCreateNestedManyWithoutMemberInput
    messageRecipients?: MessageRecipientsCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutOffersInput = {
    username: string
    roles?: RoleUncheckedCreateNestedManyWithoutMemberInput
    shops?: ShopUncheckedCreateNestedManyWithoutMemberInput
    ShoppingCart?: ShoppingCartUncheckedCreateNestedOneWithoutMemberInput
    MemberCredentials?: MemberCredentialsUncheckedCreateNestedOneWithoutMemberInput
    offerApprovers?: OfferApproverUncheckedCreateNestedManyWithoutMemberInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutMemberInput
    messageRecipients?: MessageRecipientsUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutOffersInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutOffersInput, MemberUncheckedCreateWithoutOffersInput>
  }

  export type ShopCreateWithoutOffersInput = {
    id: number
    name: string
    status: ShopStatus
    member: MemberCreateNestedOneWithoutShopsInput
    rate?: ShopRate
    description?: string | null
    role?: RoleCreateNestedManyWithoutShopInput
    products?: ProductCreateNestedManyWithoutShopInput
    products_in_shop?: ProductInShopCreateNestedManyWithoutShopInput
    bags?: ShoppingBagCreateNestedManyWithoutShopInput
    discounts?: DiscountCreateNestedManyWithoutShopInput
    policies?: PolicyCreateNestedManyWithoutShopInput
    appointments?: AppointmentCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutOffersInput = {
    id: number
    name: string
    status: ShopStatus
    shop_founder: string
    rate?: ShopRate
    description?: string | null
    role?: RoleUncheckedCreateNestedManyWithoutShopInput
    products?: ProductUncheckedCreateNestedManyWithoutShopInput
    products_in_shop?: ProductInShopUncheckedCreateNestedManyWithoutShopInput
    bags?: ShoppingBagUncheckedCreateNestedManyWithoutShopInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutShopInput
    policies?: PolicyUncheckedCreateNestedManyWithoutShopInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutOffersInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutOffersInput, ShopUncheckedCreateWithoutOffersInput>
  }

  export type ProductCreateWithoutOffersInput = {
    id: number
    name: string
    shop: ShopCreateNestedOneWithoutProductsInput
    category?: ProductCategory
    rate?: ProductRate
    description?: string | null
    products_in_shop?: ProductInShopCreateNestedManyWithoutProductInput
    products_in_bag?: ProductInBagCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOffersInput = {
    id: number
    name: string
    shopId: number
    category?: ProductCategory
    rate?: ProductRate
    description?: string | null
    products_in_shop?: ProductInShopUncheckedCreateNestedManyWithoutProductInput
    products_in_bag?: ProductInBagUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOffersInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOffersInput, ProductUncheckedCreateWithoutOffersInput>
  }

  export type OfferApproverCreateWithoutOfferInput = {
    member: MemberCreateNestedOneWithoutOfferApproversInput
    answered?: boolean
    approved?: boolean
  }

  export type OfferApproverUncheckedCreateWithoutOfferInput = {
    username: string
    answered?: boolean
    approved?: boolean
  }

  export type OfferApproverCreateOrConnectWithoutOfferInput = {
    where: OfferApproverWhereUniqueInput
    create: XOR<OfferApproverCreateWithoutOfferInput, OfferApproverUncheckedCreateWithoutOfferInput>
  }

  export type OfferApproverCreateManyOfferInputEnvelope = {
    data: Enumerable<OfferApproverCreateManyOfferInput>
    skipDuplicates?: boolean
  }

  export type MemberUpsertWithoutOffersInput = {
    update: XOR<MemberUpdateWithoutOffersInput, MemberUncheckedUpdateWithoutOffersInput>
    create: XOR<MemberCreateWithoutOffersInput, MemberUncheckedCreateWithoutOffersInput>
  }

  export type MemberUpdateWithoutOffersInput = {
    username?: StringFieldUpdateOperationsInput | string
    roles?: RoleUpdateManyWithoutMemberInput
    shops?: ShopUpdateManyWithoutMemberInput
    ShoppingCart?: ShoppingCartUpdateOneWithoutMemberInput
    MemberCredentials?: MemberCredentialsUpdateOneWithoutMemberInput
    offerApprovers?: OfferApproverUpdateManyWithoutMemberInput
    appointments?: AppointmentUpdateManyWithoutMemberInput
    messageRecipients?: MessageRecipientsUpdateManyWithoutMemberInput
  }

  export type MemberUncheckedUpdateWithoutOffersInput = {
    username?: StringFieldUpdateOperationsInput | string
    roles?: RoleUncheckedUpdateManyWithoutMemberInput
    shops?: ShopUncheckedUpdateManyWithoutMemberInput
    ShoppingCart?: ShoppingCartUncheckedUpdateOneWithoutMemberInput
    MemberCredentials?: MemberCredentialsUncheckedUpdateOneWithoutMemberInput
    offerApprovers?: OfferApproverUncheckedUpdateManyWithoutMemberInput
    appointments?: AppointmentUncheckedUpdateManyWithoutMemberInput
    messageRecipients?: MessageRecipientsUncheckedUpdateManyWithoutMemberInput
  }

  export type ShopUpsertWithoutOffersInput = {
    update: XOR<ShopUpdateWithoutOffersInput, ShopUncheckedUpdateWithoutOffersInput>
    create: XOR<ShopCreateWithoutOffersInput, ShopUncheckedCreateWithoutOffersInput>
  }

  export type ShopUpdateWithoutOffersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | ShopStatus
    member?: MemberUpdateOneRequiredWithoutShopsInput
    rate?: EnumShopRateFieldUpdateOperationsInput | ShopRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
    role?: RoleUpdateManyWithoutShopInput
    products?: ProductUpdateManyWithoutShopInput
    products_in_shop?: ProductInShopUpdateManyWithoutShopInput
    bags?: ShoppingBagUpdateManyWithoutShopInput
    discounts?: DiscountUpdateManyWithoutShopInput
    policies?: PolicyUpdateManyWithoutShopInput
    appointments?: AppointmentUpdateManyWithoutShopInput
  }

  export type ShopUncheckedUpdateWithoutOffersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | ShopStatus
    shop_founder?: StringFieldUpdateOperationsInput | string
    rate?: EnumShopRateFieldUpdateOperationsInput | ShopRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
    role?: RoleUncheckedUpdateManyWithoutShopInput
    products?: ProductUncheckedUpdateManyWithoutShopInput
    products_in_shop?: ProductInShopUncheckedUpdateManyWithoutShopInput
    bags?: ShoppingBagUncheckedUpdateManyWithoutShopInput
    discounts?: DiscountUncheckedUpdateManyWithoutShopInput
    policies?: PolicyUncheckedUpdateManyWithoutShopInput
    appointments?: AppointmentUncheckedUpdateManyWithoutShopInput
  }

  export type ProductUpsertWithoutOffersInput = {
    update: XOR<ProductUpdateWithoutOffersInput, ProductUncheckedUpdateWithoutOffersInput>
    create: XOR<ProductCreateWithoutOffersInput, ProductUncheckedCreateWithoutOffersInput>
  }

  export type ProductUpdateWithoutOffersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shop?: ShopUpdateOneRequiredWithoutProductsInput
    category?: EnumProductCategoryFieldUpdateOperationsInput | ProductCategory
    rate?: EnumProductRateFieldUpdateOperationsInput | ProductRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
    products_in_shop?: ProductInShopUpdateManyWithoutProductInput
    products_in_bag?: ProductInBagUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutOffersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shopId?: IntFieldUpdateOperationsInput | number
    category?: EnumProductCategoryFieldUpdateOperationsInput | ProductCategory
    rate?: EnumProductRateFieldUpdateOperationsInput | ProductRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
    products_in_shop?: ProductInShopUncheckedUpdateManyWithoutProductInput
    products_in_bag?: ProductInBagUncheckedUpdateManyWithoutProductInput
  }

  export type OfferApproverUpsertWithWhereUniqueWithoutOfferInput = {
    where: OfferApproverWhereUniqueInput
    update: XOR<OfferApproverUpdateWithoutOfferInput, OfferApproverUncheckedUpdateWithoutOfferInput>
    create: XOR<OfferApproverCreateWithoutOfferInput, OfferApproverUncheckedCreateWithoutOfferInput>
  }

  export type OfferApproverUpdateWithWhereUniqueWithoutOfferInput = {
    where: OfferApproverWhereUniqueInput
    data: XOR<OfferApproverUpdateWithoutOfferInput, OfferApproverUncheckedUpdateWithoutOfferInput>
  }

  export type OfferApproverUpdateManyWithWhereWithoutOfferInput = {
    where: OfferApproverScalarWhereInput
    data: XOR<OfferApproverUpdateManyMutationInput, OfferApproverUncheckedUpdateManyWithoutOfferApproverInput>
  }

  export type MemberCreateWithoutOfferApproversInput = {
    username: string
    roles?: RoleCreateNestedManyWithoutMemberInput
    shops?: ShopCreateNestedManyWithoutMemberInput
    ShoppingCart?: ShoppingCartCreateNestedOneWithoutMemberInput
    MemberCredentials?: MemberCredentialsCreateNestedOneWithoutMemberInput
    offers?: OfferCreateNestedManyWithoutMemberInput
    appointments?: AppointmentCreateNestedManyWithoutMemberInput
    messageRecipients?: MessageRecipientsCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutOfferApproversInput = {
    username: string
    roles?: RoleUncheckedCreateNestedManyWithoutMemberInput
    shops?: ShopUncheckedCreateNestedManyWithoutMemberInput
    ShoppingCart?: ShoppingCartUncheckedCreateNestedOneWithoutMemberInput
    MemberCredentials?: MemberCredentialsUncheckedCreateNestedOneWithoutMemberInput
    offers?: OfferUncheckedCreateNestedManyWithoutMemberInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutMemberInput
    messageRecipients?: MessageRecipientsUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutOfferApproversInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutOfferApproversInput, MemberUncheckedCreateWithoutOfferApproversInput>
  }

  export type OfferCreateWithoutOfferApproverInput = {
    id: number
    member: MemberCreateNestedOneWithoutOffersInput
    shop: ShopCreateNestedOneWithoutOffersInput
    product: ProductCreateNestedOneWithoutOffersInput
    price: number
  }

  export type OfferUncheckedCreateWithoutOfferApproverInput = {
    id: number
    username: string
    shopId: number
    productId: number
    price: number
  }

  export type OfferCreateOrConnectWithoutOfferApproverInput = {
    where: OfferWhereUniqueInput
    create: XOR<OfferCreateWithoutOfferApproverInput, OfferUncheckedCreateWithoutOfferApproverInput>
  }

  export type MemberUpsertWithoutOfferApproversInput = {
    update: XOR<MemberUpdateWithoutOfferApproversInput, MemberUncheckedUpdateWithoutOfferApproversInput>
    create: XOR<MemberCreateWithoutOfferApproversInput, MemberUncheckedCreateWithoutOfferApproversInput>
  }

  export type MemberUpdateWithoutOfferApproversInput = {
    username?: StringFieldUpdateOperationsInput | string
    roles?: RoleUpdateManyWithoutMemberInput
    shops?: ShopUpdateManyWithoutMemberInput
    ShoppingCart?: ShoppingCartUpdateOneWithoutMemberInput
    MemberCredentials?: MemberCredentialsUpdateOneWithoutMemberInput
    offers?: OfferUpdateManyWithoutMemberInput
    appointments?: AppointmentUpdateManyWithoutMemberInput
    messageRecipients?: MessageRecipientsUpdateManyWithoutMemberInput
  }

  export type MemberUncheckedUpdateWithoutOfferApproversInput = {
    username?: StringFieldUpdateOperationsInput | string
    roles?: RoleUncheckedUpdateManyWithoutMemberInput
    shops?: ShopUncheckedUpdateManyWithoutMemberInput
    ShoppingCart?: ShoppingCartUncheckedUpdateOneWithoutMemberInput
    MemberCredentials?: MemberCredentialsUncheckedUpdateOneWithoutMemberInput
    offers?: OfferUncheckedUpdateManyWithoutMemberInput
    appointments?: AppointmentUncheckedUpdateManyWithoutMemberInput
    messageRecipients?: MessageRecipientsUncheckedUpdateManyWithoutMemberInput
  }

  export type OfferUpsertWithoutOfferApproverInput = {
    update: XOR<OfferUpdateWithoutOfferApproverInput, OfferUncheckedUpdateWithoutOfferApproverInput>
    create: XOR<OfferCreateWithoutOfferApproverInput, OfferUncheckedCreateWithoutOfferApproverInput>
  }

  export type OfferUpdateWithoutOfferApproverInput = {
    id?: IntFieldUpdateOperationsInput | number
    member?: MemberUpdateOneRequiredWithoutOffersInput
    shop?: ShopUpdateOneRequiredWithoutOffersInput
    product?: ProductUpdateOneRequiredWithoutOffersInput
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type OfferUncheckedUpdateWithoutOfferApproverInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    shopId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type MemberCreateWithoutAppointmentsInput = {
    username: string
    roles?: RoleCreateNestedManyWithoutMemberInput
    shops?: ShopCreateNestedManyWithoutMemberInput
    ShoppingCart?: ShoppingCartCreateNestedOneWithoutMemberInput
    MemberCredentials?: MemberCredentialsCreateNestedOneWithoutMemberInput
    offers?: OfferCreateNestedManyWithoutMemberInput
    offerApprovers?: OfferApproverCreateNestedManyWithoutMemberInput
    messageRecipients?: MessageRecipientsCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutAppointmentsInput = {
    username: string
    roles?: RoleUncheckedCreateNestedManyWithoutMemberInput
    shops?: ShopUncheckedCreateNestedManyWithoutMemberInput
    ShoppingCart?: ShoppingCartUncheckedCreateNestedOneWithoutMemberInput
    MemberCredentials?: MemberCredentialsUncheckedCreateNestedOneWithoutMemberInput
    offers?: OfferUncheckedCreateNestedManyWithoutMemberInput
    offerApprovers?: OfferApproverUncheckedCreateNestedManyWithoutMemberInput
    messageRecipients?: MessageRecipientsUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutAppointmentsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutAppointmentsInput, MemberUncheckedCreateWithoutAppointmentsInput>
  }

  export type ShopCreateWithoutAppointmentsInput = {
    id: number
    name: string
    status: ShopStatus
    member: MemberCreateNestedOneWithoutShopsInput
    rate?: ShopRate
    description?: string | null
    role?: RoleCreateNestedManyWithoutShopInput
    products?: ProductCreateNestedManyWithoutShopInput
    products_in_shop?: ProductInShopCreateNestedManyWithoutShopInput
    bags?: ShoppingBagCreateNestedManyWithoutShopInput
    discounts?: DiscountCreateNestedManyWithoutShopInput
    policies?: PolicyCreateNestedManyWithoutShopInput
    offers?: OfferCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutAppointmentsInput = {
    id: number
    name: string
    status: ShopStatus
    shop_founder: string
    rate?: ShopRate
    description?: string | null
    role?: RoleUncheckedCreateNestedManyWithoutShopInput
    products?: ProductUncheckedCreateNestedManyWithoutShopInput
    products_in_shop?: ProductInShopUncheckedCreateNestedManyWithoutShopInput
    bags?: ShoppingBagUncheckedCreateNestedManyWithoutShopInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutShopInput
    policies?: PolicyUncheckedCreateNestedManyWithoutShopInput
    offers?: OfferUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutAppointmentsInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutAppointmentsInput, ShopUncheckedCreateWithoutAppointmentsInput>
  }

  export type AppointmentAgreementCreateWithoutAppointmentInput = {
    approver: string
    answered?: boolean
    approved?: boolean
  }

  export type AppointmentAgreementUncheckedCreateWithoutAppointmentInput = {
    approver: string
    answered?: boolean
    approved?: boolean
  }

  export type AppointmentAgreementCreateOrConnectWithoutAppointmentInput = {
    where: AppointmentAgreementWhereUniqueInput
    create: XOR<AppointmentAgreementCreateWithoutAppointmentInput, AppointmentAgreementUncheckedCreateWithoutAppointmentInput>
  }

  export type AppointmentAgreementCreateManyAppointmentInputEnvelope = {
    data: Enumerable<AppointmentAgreementCreateManyAppointmentInput>
    skipDuplicates?: boolean
  }

  export type MemberUpsertWithoutAppointmentsInput = {
    update: XOR<MemberUpdateWithoutAppointmentsInput, MemberUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<MemberCreateWithoutAppointmentsInput, MemberUncheckedCreateWithoutAppointmentsInput>
  }

  export type MemberUpdateWithoutAppointmentsInput = {
    username?: StringFieldUpdateOperationsInput | string
    roles?: RoleUpdateManyWithoutMemberInput
    shops?: ShopUpdateManyWithoutMemberInput
    ShoppingCart?: ShoppingCartUpdateOneWithoutMemberInput
    MemberCredentials?: MemberCredentialsUpdateOneWithoutMemberInput
    offers?: OfferUpdateManyWithoutMemberInput
    offerApprovers?: OfferApproverUpdateManyWithoutMemberInput
    messageRecipients?: MessageRecipientsUpdateManyWithoutMemberInput
  }

  export type MemberUncheckedUpdateWithoutAppointmentsInput = {
    username?: StringFieldUpdateOperationsInput | string
    roles?: RoleUncheckedUpdateManyWithoutMemberInput
    shops?: ShopUncheckedUpdateManyWithoutMemberInput
    ShoppingCart?: ShoppingCartUncheckedUpdateOneWithoutMemberInput
    MemberCredentials?: MemberCredentialsUncheckedUpdateOneWithoutMemberInput
    offers?: OfferUncheckedUpdateManyWithoutMemberInput
    offerApprovers?: OfferApproverUncheckedUpdateManyWithoutMemberInput
    messageRecipients?: MessageRecipientsUncheckedUpdateManyWithoutMemberInput
  }

  export type ShopUpsertWithoutAppointmentsInput = {
    update: XOR<ShopUpdateWithoutAppointmentsInput, ShopUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<ShopCreateWithoutAppointmentsInput, ShopUncheckedCreateWithoutAppointmentsInput>
  }

  export type ShopUpdateWithoutAppointmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | ShopStatus
    member?: MemberUpdateOneRequiredWithoutShopsInput
    rate?: EnumShopRateFieldUpdateOperationsInput | ShopRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
    role?: RoleUpdateManyWithoutShopInput
    products?: ProductUpdateManyWithoutShopInput
    products_in_shop?: ProductInShopUpdateManyWithoutShopInput
    bags?: ShoppingBagUpdateManyWithoutShopInput
    discounts?: DiscountUpdateManyWithoutShopInput
    policies?: PolicyUpdateManyWithoutShopInput
    offers?: OfferUpdateManyWithoutShopInput
  }

  export type ShopUncheckedUpdateWithoutAppointmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | ShopStatus
    shop_founder?: StringFieldUpdateOperationsInput | string
    rate?: EnumShopRateFieldUpdateOperationsInput | ShopRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
    role?: RoleUncheckedUpdateManyWithoutShopInput
    products?: ProductUncheckedUpdateManyWithoutShopInput
    products_in_shop?: ProductInShopUncheckedUpdateManyWithoutShopInput
    bags?: ShoppingBagUncheckedUpdateManyWithoutShopInput
    discounts?: DiscountUncheckedUpdateManyWithoutShopInput
    policies?: PolicyUncheckedUpdateManyWithoutShopInput
    offers?: OfferUncheckedUpdateManyWithoutShopInput
  }

  export type AppointmentAgreementUpsertWithWhereUniqueWithoutAppointmentInput = {
    where: AppointmentAgreementWhereUniqueInput
    update: XOR<AppointmentAgreementUpdateWithoutAppointmentInput, AppointmentAgreementUncheckedUpdateWithoutAppointmentInput>
    create: XOR<AppointmentAgreementCreateWithoutAppointmentInput, AppointmentAgreementUncheckedCreateWithoutAppointmentInput>
  }

  export type AppointmentAgreementUpdateWithWhereUniqueWithoutAppointmentInput = {
    where: AppointmentAgreementWhereUniqueInput
    data: XOR<AppointmentAgreementUpdateWithoutAppointmentInput, AppointmentAgreementUncheckedUpdateWithoutAppointmentInput>
  }

  export type AppointmentAgreementUpdateManyWithWhereWithoutAppointmentInput = {
    where: AppointmentAgreementScalarWhereInput
    data: XOR<AppointmentAgreementUpdateManyMutationInput, AppointmentAgreementUncheckedUpdateManyWithoutAppointmentAgreementsInput>
  }

  export type AppointmentAgreementScalarWhereInput = {
    AND?: Enumerable<AppointmentAgreementScalarWhereInput>
    OR?: Enumerable<AppointmentAgreementScalarWhereInput>
    NOT?: Enumerable<AppointmentAgreementScalarWhereInput>
    username?: StringFilter | string
    shopId?: IntFilter | number
    approver?: StringFilter | string
    answered?: BoolFilter | boolean
    approved?: BoolFilter | boolean
  }

  export type AppointmentCreateWithoutAppointmentAgreementsInput = {
    member: MemberCreateNestedOneWithoutAppointmentsInput
    shop: ShopCreateNestedOneWithoutAppointmentsInput
    assigner: string
  }

  export type AppointmentUncheckedCreateWithoutAppointmentAgreementsInput = {
    username: string
    shopId: number
    assigner: string
  }

  export type AppointmentCreateOrConnectWithoutAppointmentAgreementsInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutAppointmentAgreementsInput, AppointmentUncheckedCreateWithoutAppointmentAgreementsInput>
  }

  export type AppointmentUpsertWithoutAppointmentAgreementsInput = {
    update: XOR<AppointmentUpdateWithoutAppointmentAgreementsInput, AppointmentUncheckedUpdateWithoutAppointmentAgreementsInput>
    create: XOR<AppointmentCreateWithoutAppointmentAgreementsInput, AppointmentUncheckedCreateWithoutAppointmentAgreementsInput>
  }

  export type AppointmentUpdateWithoutAppointmentAgreementsInput = {
    member?: MemberUpdateOneRequiredWithoutAppointmentsInput
    shop?: ShopUpdateOneRequiredWithoutAppointmentsInput
    assigner?: StringFieldUpdateOperationsInput | string
  }

  export type AppointmentUncheckedUpdateWithoutAppointmentAgreementsInput = {
    username?: StringFieldUpdateOperationsInput | string
    shopId?: IntFieldUpdateOperationsInput | number
    assigner?: StringFieldUpdateOperationsInput | string
  }

  export type RoleCreateManyMemberInput = {
    shopId: number
    job_type: JobType
    permissions?: RoleCreatepermissionsInput | Enumerable<Permissions>
  }

  export type ShopCreateManyMemberInput = {
    id: number
    name: string
    status: ShopStatus
    rate?: ShopRate
    description?: string | null
  }

  export type OfferCreateManyMemberInput = {
    id: number
    shopId: number
    productId: number
    price: number
  }

  export type OfferApproverCreateManyMemberInput = {
    offerId: number
    answered?: boolean
    approved?: boolean
  }

  export type AppointmentCreateManyMemberInput = {
    shopId: number
    assigner: string
  }

  export type MessageRecipientsCreateManyMemberInput = {
    messageId: number
  }

  export type RoleUpdateWithoutMemberInput = {
    shop?: ShopUpdateOneRequiredWithoutRoleInput
    job_type?: EnumJobTypeFieldUpdateOperationsInput | JobType
    permissions?: RoleUpdatepermissionsInput | Enumerable<Permissions>
    shop_owners?: ShopOwnerUpdateManyWithoutRoleInput
    shop_managers?: ShopManagerUpdateManyWithoutRoleInput
  }

  export type RoleUncheckedUpdateWithoutMemberInput = {
    shopId?: IntFieldUpdateOperationsInput | number
    job_type?: EnumJobTypeFieldUpdateOperationsInput | JobType
    permissions?: RoleUpdatepermissionsInput | Enumerable<Permissions>
    shop_owners?: ShopOwnerUncheckedUpdateManyWithoutRoleInput
    shop_managers?: ShopManagerUncheckedUpdateManyWithoutRoleInput
  }

  export type RoleUncheckedUpdateManyWithoutRolesInput = {
    shopId?: IntFieldUpdateOperationsInput | number
    job_type?: EnumJobTypeFieldUpdateOperationsInput | JobType
    permissions?: RoleUpdatepermissionsInput | Enumerable<Permissions>
  }

  export type ShopUpdateWithoutMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | ShopStatus
    rate?: EnumShopRateFieldUpdateOperationsInput | ShopRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
    role?: RoleUpdateManyWithoutShopInput
    products?: ProductUpdateManyWithoutShopInput
    products_in_shop?: ProductInShopUpdateManyWithoutShopInput
    bags?: ShoppingBagUpdateManyWithoutShopInput
    discounts?: DiscountUpdateManyWithoutShopInput
    policies?: PolicyUpdateManyWithoutShopInput
    offers?: OfferUpdateManyWithoutShopInput
    appointments?: AppointmentUpdateManyWithoutShopInput
  }

  export type ShopUncheckedUpdateWithoutMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | ShopStatus
    rate?: EnumShopRateFieldUpdateOperationsInput | ShopRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
    role?: RoleUncheckedUpdateManyWithoutShopInput
    products?: ProductUncheckedUpdateManyWithoutShopInput
    products_in_shop?: ProductInShopUncheckedUpdateManyWithoutShopInput
    bags?: ShoppingBagUncheckedUpdateManyWithoutShopInput
    discounts?: DiscountUncheckedUpdateManyWithoutShopInput
    policies?: PolicyUncheckedUpdateManyWithoutShopInput
    offers?: OfferUncheckedUpdateManyWithoutShopInput
    appointments?: AppointmentUncheckedUpdateManyWithoutShopInput
  }

  export type ShopUncheckedUpdateManyWithoutShopsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | ShopStatus
    rate?: EnumShopRateFieldUpdateOperationsInput | ShopRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OfferUpdateWithoutMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    shop?: ShopUpdateOneRequiredWithoutOffersInput
    product?: ProductUpdateOneRequiredWithoutOffersInput
    price?: FloatFieldUpdateOperationsInput | number
    offerApprover?: OfferApproverUpdateManyWithoutOfferInput
  }

  export type OfferUncheckedUpdateWithoutMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    offerApprover?: OfferApproverUncheckedUpdateManyWithoutOfferInput
  }

  export type OfferUncheckedUpdateManyWithoutOffersInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type OfferApproverUpdateWithoutMemberInput = {
    offer?: OfferUpdateOneRequiredWithoutOfferApproverInput
    answered?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OfferApproverUncheckedUpdateWithoutMemberInput = {
    offerId?: IntFieldUpdateOperationsInput | number
    answered?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OfferApproverUncheckedUpdateManyWithoutOfferApproversInput = {
    offerId?: IntFieldUpdateOperationsInput | number
    answered?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AppointmentUpdateWithoutMemberInput = {
    shop?: ShopUpdateOneRequiredWithoutAppointmentsInput
    assigner?: StringFieldUpdateOperationsInput | string
    appointmentAgreements?: AppointmentAgreementUpdateManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedUpdateWithoutMemberInput = {
    shopId?: IntFieldUpdateOperationsInput | number
    assigner?: StringFieldUpdateOperationsInput | string
    appointmentAgreements?: AppointmentAgreementUncheckedUpdateManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedUpdateManyWithoutAppointmentsInput = {
    shopId?: IntFieldUpdateOperationsInput | number
    assigner?: StringFieldUpdateOperationsInput | string
  }

  export type MessageRecipientsUpdateWithoutMemberInput = {
    message?: MessageUpdateOneRequiredWithoutRecipientsInput
  }

  export type MessageRecipientsUncheckedUpdateWithoutMemberInput = {
    messageId?: IntFieldUpdateOperationsInput | number
  }

  export type MessageRecipientsUncheckedUpdateManyWithoutMessageRecipientsInput = {
    messageId?: IntFieldUpdateOperationsInput | number
  }

  export type ShopOwnerCreateManyRoleInput = {

  }

  export type ShopManagerCreateManyRoleInput = {

  }

  export type ShopOwnerUpdateWithoutRoleInput = {

  }

  export type ShopOwnerUncheckedUpdateWithoutRoleInput = {

  }

  export type ShopOwnerUncheckedUpdateManyWithoutShop_ownersInput = {

  }

  export type ShopManagerUpdateWithoutRoleInput = {

  }

  export type ShopManagerUncheckedUpdateWithoutRoleInput = {

  }

  export type ShopManagerUncheckedUpdateManyWithoutShop_managersInput = {

  }

  export type ProductInShopCreateManyProductInput = {
    shopId: number
    product_quantity?: number
  }

  export type ProductInBagCreateManyProductInput = {
    username: string
    shopId: number
    product_quantity?: number
  }

  export type OfferCreateManyProductInput = {
    id: number
    username: string
    shopId: number
    price: number
  }

  export type ProductInShopUpdateWithoutProductInput = {
    shop?: ShopUpdateOneRequiredWithoutProducts_in_shopInput
    product_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ProductInShopUncheckedUpdateWithoutProductInput = {
    shopId?: IntFieldUpdateOperationsInput | number
    product_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ProductInShopUncheckedUpdateManyWithoutProducts_in_shopInput = {
    shopId?: IntFieldUpdateOperationsInput | number
    product_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ProductInBagUpdateWithoutProductInput = {
    shoppingBag?: ShoppingBagUpdateOneRequiredWithoutProducts_in_bagInput
    product_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ProductInBagUncheckedUpdateWithoutProductInput = {
    username?: StringFieldUpdateOperationsInput | string
    shopId?: IntFieldUpdateOperationsInput | number
    product_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ProductInBagUncheckedUpdateManyWithoutProducts_in_bagInput = {
    username?: StringFieldUpdateOperationsInput | string
    shopId?: IntFieldUpdateOperationsInput | number
    product_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type OfferUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    member?: MemberUpdateOneRequiredWithoutOffersInput
    shop?: ShopUpdateOneRequiredWithoutOffersInput
    price?: FloatFieldUpdateOperationsInput | number
    offerApprover?: OfferApproverUpdateManyWithoutOfferInput
  }

  export type OfferUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    shopId?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    offerApprover?: OfferApproverUncheckedUpdateManyWithoutOfferInput
  }

  export type RoleCreateManyShopInput = {
    username: string
    job_type: JobType
    permissions?: RoleCreatepermissionsInput | Enumerable<Permissions>
  }

  export type ProductCreateManyShopInput = {
    id: number
    name: string
    category?: ProductCategory
    rate?: ProductRate
    description?: string | null
  }

  export type ProductInShopCreateManyShopInput = {
    productId: number
    product_quantity?: number
  }

  export type ShoppingBagCreateManyShopInput = {
    username: string
  }

  export type DiscountCreateManyShopInput = {
    id: number
    kind: DiscountKinds
  }

  export type PolicyCreateManyShopInput = {
    id: number
  }

  export type OfferCreateManyShopInput = {
    id: number
    username: string
    productId: number
    price: number
  }

  export type AppointmentCreateManyShopInput = {
    username: string
    assigner: string
  }

  export type RoleUpdateWithoutShopInput = {
    member?: MemberUpdateOneRequiredWithoutRolesInput
    job_type?: EnumJobTypeFieldUpdateOperationsInput | JobType
    permissions?: RoleUpdatepermissionsInput | Enumerable<Permissions>
    shop_owners?: ShopOwnerUpdateManyWithoutRoleInput
    shop_managers?: ShopManagerUpdateManyWithoutRoleInput
  }

  export type RoleUncheckedUpdateWithoutShopInput = {
    username?: StringFieldUpdateOperationsInput | string
    job_type?: EnumJobTypeFieldUpdateOperationsInput | JobType
    permissions?: RoleUpdatepermissionsInput | Enumerable<Permissions>
    shop_owners?: ShopOwnerUncheckedUpdateManyWithoutRoleInput
    shop_managers?: ShopManagerUncheckedUpdateManyWithoutRoleInput
  }

  export type RoleUncheckedUpdateManyWithoutRoleInput = {
    username?: StringFieldUpdateOperationsInput | string
    job_type?: EnumJobTypeFieldUpdateOperationsInput | JobType
    permissions?: RoleUpdatepermissionsInput | Enumerable<Permissions>
  }

  export type ProductUpdateWithoutShopInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumProductCategoryFieldUpdateOperationsInput | ProductCategory
    rate?: EnumProductRateFieldUpdateOperationsInput | ProductRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
    products_in_shop?: ProductInShopUpdateManyWithoutProductInput
    products_in_bag?: ProductInBagUpdateManyWithoutProductInput
    offers?: OfferUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutShopInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumProductCategoryFieldUpdateOperationsInput | ProductCategory
    rate?: EnumProductRateFieldUpdateOperationsInput | ProductRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
    products_in_shop?: ProductInShopUncheckedUpdateManyWithoutProductInput
    products_in_bag?: ProductInBagUncheckedUpdateManyWithoutProductInput
    offers?: OfferUncheckedUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateManyWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumProductCategoryFieldUpdateOperationsInput | ProductCategory
    rate?: EnumProductRateFieldUpdateOperationsInput | ProductRate
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductInShopUpdateWithoutShopInput = {
    product?: ProductUpdateOneRequiredWithoutProducts_in_shopInput
    product_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ProductInShopUncheckedUpdateWithoutShopInput = {
    productId?: IntFieldUpdateOperationsInput | number
    product_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ShoppingBagUpdateWithoutShopInput = {
    shoppingCart?: ShoppingCartUpdateOneRequiredWithoutBagsInput
    products_in_bag?: ProductInBagUpdateManyWithoutShoppingBagInput
  }

  export type ShoppingBagUncheckedUpdateWithoutShopInput = {
    username?: StringFieldUpdateOperationsInput | string
    products_in_bag?: ProductInBagUncheckedUpdateManyWithoutShoppingBagInput
  }

  export type ShoppingBagUncheckedUpdateManyWithoutBagsInput = {
    username?: StringFieldUpdateOperationsInput | string
  }

  export type DiscountUpdateWithoutShopInput = {
    id?: IntFieldUpdateOperationsInput | number
    kind?: EnumDiscountKindsFieldUpdateOperationsInput | DiscountKinds
    simpleDiscount?: SimpleDiscountUpdateOneWithoutDiscountInput
    conditionalDiscount?: ConditionalDiscountUpdateOneWithoutDiscountInput
    discountContainer?: DiscountContainerUpdateOneWithoutDiscountInput
    discountInContainer?: DiscountInContainerUpdateOneWithoutDiscountInput
  }

  export type DiscountUncheckedUpdateWithoutShopInput = {
    id?: IntFieldUpdateOperationsInput | number
    kind?: EnumDiscountKindsFieldUpdateOperationsInput | DiscountKinds
    simpleDiscount?: SimpleDiscountUncheckedUpdateOneWithoutDiscountInput
    conditionalDiscount?: ConditionalDiscountUncheckedUpdateOneWithoutDiscountInput
    discountContainer?: DiscountContainerUncheckedUpdateOneWithoutDiscountInput
    discountInContainer?: DiscountInContainerUncheckedUpdateOneWithoutDiscountInput
  }

  export type DiscountUncheckedUpdateManyWithoutDiscountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    kind?: EnumDiscountKindsFieldUpdateOperationsInput | DiscountKinds
  }

  export type PolicyUpdateWithoutShopInput = {
    id?: IntFieldUpdateOperationsInput | number
    simplePolicy?: SimplePolicyUpdateOneWithoutPolicyInput
    conditionalPolicy?: ConditionalPolicyUpdateOneWithoutPolicyInput
    logicalPolicy?: LogicalPolicyUpdateOneWithoutPolicyInput
    policyInContainer?: PolicyInContainerUpdateOneWithoutPolicyInput
  }

  export type PolicyUncheckedUpdateWithoutShopInput = {
    id?: IntFieldUpdateOperationsInput | number
    simplePolicy?: SimplePolicyUncheckedUpdateOneWithoutPolicyInput
    conditionalPolicy?: ConditionalPolicyUncheckedUpdateOneWithoutPolicyInput
    logicalPolicy?: LogicalPolicyUncheckedUpdateOneWithoutPolicyInput
    policyInContainer?: PolicyInContainerUncheckedUpdateOneWithoutPolicyInput
  }

  export type PolicyUncheckedUpdateManyWithoutPoliciesInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type OfferUpdateWithoutShopInput = {
    id?: IntFieldUpdateOperationsInput | number
    member?: MemberUpdateOneRequiredWithoutOffersInput
    product?: ProductUpdateOneRequiredWithoutOffersInput
    price?: FloatFieldUpdateOperationsInput | number
    offerApprover?: OfferApproverUpdateManyWithoutOfferInput
  }

  export type OfferUncheckedUpdateWithoutShopInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    offerApprover?: OfferApproverUncheckedUpdateManyWithoutOfferInput
  }

  export type AppointmentUpdateWithoutShopInput = {
    member?: MemberUpdateOneRequiredWithoutAppointmentsInput
    assigner?: StringFieldUpdateOperationsInput | string
    appointmentAgreements?: AppointmentAgreementUpdateManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedUpdateWithoutShopInput = {
    username?: StringFieldUpdateOperationsInput | string
    assigner?: StringFieldUpdateOperationsInput | string
    appointmentAgreements?: AppointmentAgreementUncheckedUpdateManyWithoutAppointmentInput
  }

  export type ShoppingBagCreateManyShoppingCartInput = {
    shopId: number
  }

  export type ShoppingBagUpdateWithoutShoppingCartInput = {
    shop?: ShopUpdateOneRequiredWithoutBagsInput
    products_in_bag?: ProductInBagUpdateManyWithoutShoppingBagInput
  }

  export type ShoppingBagUncheckedUpdateWithoutShoppingCartInput = {
    shopId?: IntFieldUpdateOperationsInput | number
    products_in_bag?: ProductInBagUncheckedUpdateManyWithoutShoppingBagInput
  }

  export type ProductInBagCreateManyShoppingBagInput = {
    productId: number
    product_quantity?: number
  }

  export type ProductInBagUpdateWithoutShoppingBagInput = {
    product?: ProductUpdateOneRequiredWithoutProducts_in_bagInput
    product_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ProductInBagUncheckedUpdateWithoutShoppingBagInput = {
    productId?: IntFieldUpdateOperationsInput | number
    product_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type MessageRecipientsCreateManyMessageInput = {
    username: string
  }

  export type MessageRecipientsUpdateWithoutMessageInput = {
    member?: MemberUpdateOneRequiredWithoutMessageRecipientsInput
  }

  export type MessageRecipientsUncheckedUpdateWithoutMessageInput = {
    username?: StringFieldUpdateOperationsInput | string
  }

  export type MessageRecipientsUncheckedUpdateManyWithoutRecipientsInput = {
    username?: StringFieldUpdateOperationsInput | string
  }

  export type DiscountInContainerCreateManyDiscountContainerInput = {
    containedDiscount: number
  }

  export type DiscountInContainerUpdateWithoutDiscountContainerInput = {
    discount?: DiscountUpdateOneRequiredWithoutDiscountInContainerInput
  }

  export type DiscountInContainerUncheckedUpdateWithoutDiscountContainerInput = {
    containedDiscount?: IntFieldUpdateOperationsInput | number
  }

  export type DiscountInContainerUncheckedUpdateManyWithoutDiscountsInput = {
    containedDiscount?: IntFieldUpdateOperationsInput | number
  }

  export type PolicyInContainerCreateManyPolicyContainerInput = {
    containedPolicy: number
  }

  export type PolicyInContainerUpdateWithoutPolicyContainerInput = {
    policy?: PolicyUpdateOneRequiredWithoutPolicyInContainerInput
  }

  export type PolicyInContainerUncheckedUpdateWithoutPolicyContainerInput = {
    containedPolicy?: IntFieldUpdateOperationsInput | number
  }

  export type PolicyInContainerUncheckedUpdateManyWithoutPoliciesInput = {
    containedPolicy?: IntFieldUpdateOperationsInput | number
  }

  export type OfferApproverCreateManyOfferInput = {
    username: string
    answered?: boolean
    approved?: boolean
  }

  export type OfferApproverUpdateWithoutOfferInput = {
    member?: MemberUpdateOneRequiredWithoutOfferApproversInput
    answered?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OfferApproverUncheckedUpdateWithoutOfferInput = {
    username?: StringFieldUpdateOperationsInput | string
    answered?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OfferApproverUncheckedUpdateManyWithoutOfferApproverInput = {
    username?: StringFieldUpdateOperationsInput | string
    answered?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AppointmentAgreementCreateManyAppointmentInput = {
    approver: string
    answered?: boolean
    approved?: boolean
  }

  export type AppointmentAgreementUpdateWithoutAppointmentInput = {
    approver?: StringFieldUpdateOperationsInput | string
    answered?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AppointmentAgreementUncheckedUpdateWithoutAppointmentInput = {
    approver?: StringFieldUpdateOperationsInput | string
    answered?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AppointmentAgreementUncheckedUpdateManyWithoutAppointmentAgreementsInput = {
    approver?: StringFieldUpdateOperationsInput | string
    answered?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}